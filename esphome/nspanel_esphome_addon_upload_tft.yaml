#####################################################################################################
##### NSPANEL ESPHOME created by Blackymas - https://github.com/Blackymas/NSPanel_HA_Blueprint  #####
##### TFT Upload engine                                                                         #####
##### PLEASE only make changes if it is necessary and also the required knowledge is available. #####
##### For normal use with the Blueprint, no changes are necessary.                              #####
#####################################################################################################
##### ATTENTION: This will add advanced elements to the core system and requires the core part. #####
#####################################################################################################
---
substitutions:
  ##############################
  ## Change only in your      ##
  ## local yaml substitutions ##
  ##############################

  ################## Defaults ##################
  # Just in case user forgets to set something #
  nextion_update_base_url: "https://raw.githubusercontent.com/Blackymas/NSPanel_HA_Blueprint/"
  nextion_update_url: "${nextion_update_base_url}/main/hmi/nspanel_blank.tft"
  ##############################################
  TAG_UPLOAD_TFT: "nspanel.addon.upload_tft"

esphome:
  platformio_options:
    build_flags:
      - -D NSPANEL_HA_BLUEPRINT_ADDON_UPLOAD_TFT

# yamllint disable rule:comments-indentation
api:
  actions:
    ##### TFT File Update Service: `upload_tft`
    # Updates the panel's TFT file remotely from a specified URL or the default location, requiring the "Upload TFT" add-on.
    # Usage: Essential for applying custom TFT designs or updates, especially when direct repository access is unavailable.
    #
    # Parameters:
    # - `url` (string): URL for the TFT file. If "default" or empty, uses the URL from "Update TFT - Display Model" in Home Assistant settings.
    #
    # Example:
    # service: esphome.<your_panel_name>_upload_tft
    # data:
    #   url: "http://homeassistant.local:8123/local/custom_tft_file.tft"  # Custom or default URL to the TFT file
    #
    # [!NOTE]
    # Utilize "default" to automatically use the URL associated with the display model set in Home Assistant.
    #
    # [!ATTENTION]
    # Requires the "Upload TFT" add-on for functionality.
    - action: upload_tft
      variables:
        url: string
      then:
        - lambda: |-
            if (not is_system_flag_set(NSPanelFlag::TFT_UPLOAD_ACTIVE))
              upload_tft->execute(url.c_str());

button:
  ##### UPDATE TFT DISPLAY #####
  - id: tft_update
    name: Update TFT display
    platform: template
    icon: mdi:file-sync
    entity_category: config
    on_press:
      then:
        - script.execute:
            id: upload_tft
            url: ""

display:
  - id: !extend disp1
    tft_url: ${nextion_update_url}
    exit_reparse_on_start: true

nspanel_ha_blueprint:
  lwip_tcp_mss: 1400
  task_wdt_timeout_s: 30

script:
  - id: !extend check_versions
    then:
      - if:
          condition:
            - switch.is_on: tft_update_automatically
            - lambda: return tft_file_model->state != "NSPanel Blank";
          then:
            - script.execute: wait_for_version_tft
            - script.wait: wait_for_version_tft
            - if:
                condition:
                  - lambda: return version_tft->state != "${version}";
                then:
                  - lambda: |-
                      ESP_LOGI("${TAG_UPLOAD_TFT}", "Auto updating TFT");
                      upload_tft->execute("");

  - id: !extend dump_config
    then:
      - lambda: |-
          if (is_system_flag_set(NSPanelFlag::TFT_UPLOAD_ACTIVE))
            ESP_LOGW("${TAG_UPLOAD_TFT}", "TFT upload in progress");
          ESP_LOGCONFIG("${TAG_UPLOAD_TFT}", "Add-on Upload TFT:");
          ESP_LOGCONFIG("${TAG_UPLOAD_TFT}", "  File model: %s", tft_file_model->state.c_str());
          ESP_LOGCONFIG("${TAG_UPLOAD_TFT}", "  Valid TFT:  %s", YESNO((display_mode > 0 and display_mode < 4)));

  - id: nextion_status
    mode: restart
    then:
      - lambda: |-
          ESP_LOGD("${TAG_UPLOAD_TFT}", "Nextion status:");
          ESP_LOGD("${TAG_UPLOAD_TFT}", "  Is detected: %s", YESNO(disp1->is_detected()));
          ESP_LOGD("${TAG_UPLOAD_TFT}", "  Is setup:    %s", YESNO(disp1->is_setup()));
          ESP_LOGD("${TAG_UPLOAD_TFT}", "  Queue size:  %d", disp1->queue_size());

  - id: nextion_upload
    mode: single
    parameters:
      baud_rate: uint32_t
    then:
      - lambda: |-
          ESP_LOGD("${TAG_UPLOAD_TFT}", "Waiting for empty UART and Nextion queues");
      - wait_until:
          condition:
            - lambda: return (disp1->queue_size() < 1);
            - lambda: return (tf_uart->available() < 1);
          timeout: 10s
      - delay: 2s
      - lambda: |-
          ESP_LOGD("${TAG_UPLOAD_TFT}", "Starting TFT upload...");
          tft_upload_result = disp1->upload_tft(baud_rate, !disp1->is_setup());
          ESP_LOGV("${TAG_UPLOAD_TFT}", "TFT upload: %s", YESNO(tft_upload_result));

  - id: open_upload_dialog
    mode: restart
    then:
      - lambda: |-
          ESP_LOGV("${TAG_UPLOAD_TFT}", "Showing upload dialog page");
          disp1->goto_page("confirm");
      - wait_until:
          condition:
            - lambda: return (current_page_id == ${PAGE_CONFIRM_ID});
          timeout: 2s
      - lambda: |-
          if (current_page_id == ${PAGE_CONFIRM_ID}) {
            disp1->hide_component("bclose");
            disp1->hide_component("bt_accept");
            disp1->hide_component("bt_clear");
          }
          #ifdef ARDUINO
          disp1->set_component_text("confirm.title", "Upload TFT\\rArduino");
          #elif defined(USE_ESP_IDF)
          disp1->set_component_text("confirm.title", "Upload TFT\\rESP-IDF");
          #endif

  - id: report_upload_progress
    mode: restart
    parameters:
      message: string
    then:
      - lambda: |-
          ESP_LOGD("${TAG_UPLOAD_TFT}", message.c_str());
          if ((display_mode > 0 and display_mode < 4)) {
            if (current_page->state != "confirm") open_upload_dialog->execute();
            disp1->set_component_text("confirm.body", wrapText(message.c_str(), 18, id(mui_bytes_per_char)).c_str());
            disp1->set_backlight_brightness(1);
            App.feed_wdt();
          }

  - id: !extend stop_all
    then:
      - script.stop: nextion_status

  - id: upload_tft
    mode: single
    parameters:
      url: string
    then:
      # Make sure the screen is ON
      - if:
          condition:
            - switch.is_off: screen_power
          then:
            - switch.turn_on: screen_power
            - delay: 5s
      - lambda: if ((display_mode > 0 and display_mode < 4)) disp1->goto_page("home");
      - delay: 2s
      - script.execute: open_upload_dialog
      - script.wait: open_upload_dialog
      - wait_until:
          condition:
            - lambda: return (current_page_id == ${PAGE_CONFIRM_ID});
          timeout: 2s
      - script.execute:
          id: report_upload_progress
          message: "Set Nextion unavailable for blueprint calls"
      - script.wait: report_upload_progress
      - binary_sensor.template.publish:
          id: nextion_init
          state: false
      - script.execute:
          id: report_upload_progress
          message: "Preparing for upload..."
      - script.wait: report_upload_progress

      # Then start the upload
      - script.execute: nextion_status
      - lambda: |-
          set_system_flag(NSPanelFlag::TFT_UPLOAD_ACTIVE);
          ESP_LOGD("${TAG_UPLOAD_TFT}", "Starting the upload script");
          ESP_LOGV("${TAG_UPLOAD_TFT}", "  Valid TFT: %s", YESNO((display_mode > 0 and display_mode < 4)));
          ESP_LOGV("${TAG_UPLOAD_TFT}", "  Current baud rate: %" PRIu32, tf_uart->get_baud_rate());
          ESP_LOGV("${TAG_UPLOAD_TFT}", "  Target upload baud rate: %s", tft_upload_baud_rate->state.c_str());

          // Calculate URL if needed
          std::string resolved_url = url;

          // Convert to lowercase and trim
          std::transform(resolved_url.begin(), resolved_url.end(), resolved_url.begin(),
                        [](unsigned char c){ return std::tolower(c); });
          auto endPos = resolved_url.find_last_not_of(" \t");
          if (std::string::npos != endPos) {
            resolved_url = resolved_url.substr(0, endPos + 1);
          }

          // Calculate URL if empty
          if (resolved_url.empty()) {
            auto idx_opt = tft_file_model->active_index();
            if (!idx_opt.has_value()) {
              resolved_url = "${nextion_update_url}";  // Fallback if no valid index
            } else {
              const int idx = idx_opt.value();

              if (idx == 0) {
                resolved_url = "${nextion_update_url}";
              } else if (idx >= 1 && idx <= 7) {
                static const char* const FILENAME_PARTS[] = {
                  nullptr, "blank", "eu", "us", "us_land", "CJK_eu", "CJK_us", "CJK_us_land"
                };

                const std::string version = "v${version}";
                const char* branch = "main";
                for (char c : version) {
                  if (c == 'b') { branch = "beta"; break; }
                  if (c == 'd') { branch = "dev"; break; }
                }
                if (branch[0] == 'm' && version != "main" && !version.empty()) {
                  branch = version.c_str();
                }

                resolved_url = "${nextion_update_base_url}" + std::string(branch) +
                              "/hmi/nspanel_" + FILENAME_PARTS[idx] + ".tft";
              } else {
                resolved_url = "${nextion_update_url}";
              }
            }
          }

          ESP_LOGV("${TAG_UPLOAD_TFT}", "  Upload URL: %s", resolved_url.c_str());
          disp1->set_tft_url(resolved_url.c_str());

      # Stop Bluetooth
      - lambda: |-
          #ifdef USE_BLUETOOTH
          ESP_LOGI("${TAG_UPLOAD_TFT}", "Disabling Bluetooth and releasing memory...");

          // Stop BLE operations
          esp_ble_gap_stop_advertising();
          esp_ble_gap_stop_scanning();

          // Stop Classic Bluetooth operations
          esp_bt_gap_set_scan_mode(ESP_BT_NON_CONNECTABLE, ESP_BT_NON_DISCOVERABLE);
          esp_bt_gap_cancel_discovery();

          // Disable and deinitialize Bluedroid stack
          if (esp_bluedroid_get_status() == ESP_BLUEDROID_STATUS_ENABLED) {
            esp_bluedroid_disable();
          }  // if esp_bluedroid_get_status()

          if (esp_bluedroid_get_status() != ESP_BLUEDROID_STATUS_UNINITIALIZED) {
            esp_bluedroid_deinit();
          }  // if esp_bluedroid_get_status()

          // Disable and deinitialize Bluetooth controller
          if (esp_bt_controller_get_status() == ESP_BT_CONTROLLER_STATUS_ENABLED) {
            esp_bt_controller_disable();
          }  // if esp_bt_controller_get_status()

          if (esp_bt_controller_get_status() != ESP_BT_CONTROLLER_STATUS_IDLE) {
            esp_bt_controller_deinit();
          }  // if esp_bt_controller_get_status()

          // Release Bluetooth memory - this is the key step!
          esp_err_t err = esp_bt_mem_release(ESP_BT_MODE_BTDM);
          if (err == ESP_OK) {
            ESP_LOGI("${TAG_UPLOAD_TFT}", "Bluetooth memory released successfully");
          } else {
            ESP_LOGE("${TAG_UPLOAD_TFT}", "Failed to release BT memory: %s", esp_err_to_name(err));
          }  // if err == ESP_OK

          #else
          ESP_LOGV("${TAG_UPLOAD_TFT}", "Bluetooth not compiled in");
          #endif  // USE_BLUETOOTH

      - lambda: |-
          if ((display_mode > 0 and display_mode < 4))
            disp1->goto_page(${PAGE_HOME_ID});

      - delay: 2s
      - script.execute: open_upload_dialog
      - script.wait: open_upload_dialog
      - wait_until:
          condition:
            - lambda: return (current_page_id == ${PAGE_CONFIRM_ID});
          timeout: 2s
      - script.execute:
          id: report_upload_progress
          message: "Stopping other scripts"
      - script.wait: report_upload_progress
      - script.execute: stop_all
      - script.wait: stop_all
      - wait_until:
          condition:
            - lambda: return (!(display_mode > 0 and display_mode < 4));
          timeout: 1s

      ### Attempt twice at the target baud rate
      - script.execute:
          id: upload_tft_sequence_attempt
          baud_rate: !lambda return stoi(tft_upload_baud_rate->state);
      - script.wait: upload_tft_sequence_attempt

      ### Attempt twice at the original baud rate
      - if:
          condition:
            - lambda: return (stoi(tft_upload_baud_rate->state) != tf_uart->get_baud_rate());
          then:
            - script.execute:
                id: upload_tft_sequence_attempt
                baud_rate: 0
            - script.wait: upload_tft_sequence_attempt

      ### Attempt twice at the Nextion's default baud rate (115200bps)
      - if:
          condition:
            - lambda: return (stoi(tft_upload_baud_rate->state) != 115200 and tf_uart->get_baud_rate() != 115200);
          then:
            - script.execute:
                id: upload_tft_sequence_attempt
                baud_rate: 115200
            - script.wait: upload_tft_sequence_attempt

      ### Restart Nextion and attempt twice again at default baud rate (115200bps)
      - script.execute:
          id: report_upload_progress
          message: "Restarting Nextion display"
      - script.wait: report_upload_progress
      - wait_until:
          condition:
            - lambda: return (!(display_mode > 0 and display_mode < 4));
          timeout: 3s
      - switch.turn_off: screen_power
      - delay: 2s
      - switch.turn_on: screen_power
      - delay: 5s
      - script.execute:
          id: upload_tft_sequence_attempt
          baud_rate: 115200
      - script.wait: upload_tft_sequence_attempt

      ### All tries failed ###
      - script.execute:
          id: report_upload_progress
          message: "TFT upload failed"
      - script.wait: report_upload_progress
      - wait_until:
          condition:
            - lambda: return (!(display_mode > 0 and display_mode < 4));
          timeout: 5s
      - script.execute:
          id: report_upload_progress
          message: "Turn off Nextion and restart ESPHome"
      - script.wait: report_upload_progress
      - wait_until:
          condition:
            - lambda: return (!(display_mode > 0 and display_mode < 4));
          timeout: 5s
      - switch.turn_off: screen_power
      - delay: 2s
      # Restart ESPHome
      - lambda: App.safe_reboot();

  - id: upload_tft_sequence_attempt
    mode: single
    parameters:
      baud_rate: uint32_t
    then:
      - script.execute: nextion_status
      - script.wait: nextion_status
      - script.execute:
          id: report_upload_progress
          message: "Setting baud rate"
      - script.wait: report_upload_progress
      - script.execute:
          id: set_baud_rate
          target_baud_rate: !lambda return baud_rate;
          definitive: false
      - script.wait: set_baud_rate
      - delay: 2s
      - repeat:
          count: 2
          then:
            # First attempt
            - script.execute:
                id: upload_tft_attempt
                baud_rate: !lambda return baud_rate;
            - script.wait: upload_tft_attempt
            - delay: 5s

  - id: upload_tft_attempt
    mode: single
    parameters:
      baud_rate: uint32_t
    then:
      - logger.log: "Attempting to upload TFT"
      - lambda: tft_upload_attempt++;
      - lambda: |-
          char update_msg[128];
          sprintf(update_msg, "Attempt #%d at %" PRIu32 " bps", tft_upload_attempt, tf_uart->get_baud_rate());
          tft_upload_result = false;
          report_upload_progress->execute(update_msg);
      - script.wait: report_upload_progress
      - wait_until:
          condition:
            - lambda: return (!(display_mode > 0 and display_mode < 4));
          timeout: 1s
      - script.execute:
          id: nextion_upload
          baud_rate: !lambda return baud_rate;
      - script.wait: nextion_upload
      - lambda: |-
          char update_msg[128];
          sprintf(update_msg, "Attempt #%d at %" PRIu32 " bps returned: %s", tft_upload_attempt,
                  tf_uart->get_baud_rate(), tft_upload_result ? "Success!" : "FAILED");
          report_upload_progress->execute(update_msg);
      - script.wait: report_upload_progress
      - if:
          condition:
            - lambda: return tft_upload_result;
          then:
            - delay: 5s
            - lambda: |-
                ESP_LOGI("addon_upload_tft.script.upload_tft_attempt", "Restarting ESPHome");
                App.safe_reboot();

select:
  - id: tft_file_model
    name: Update TFT display - Model
    platform: template
    options:
      - "Use nextion_update_url"
      - "NSPanel Blank"
      - "NSPanel EU"
      - "NSPanel US"
      - "NSPanel US Landscape"
      - "NSPanel EU (CJK languages)"
      - "NSPanel US (CJK languages)"
      - "NSPanel US Landscape (CJK languages)"
    initial_option: "NSPanel EU"
    optimistic: true
    restore_value: true
    internal: false
    entity_category: config
    disabled_by_default: false
    icon: mdi:file-sync
    update_interval: never

  - id: tft_upload_baud_rate
    name: Update TFT display - Baud rate
    platform: template
    options:
      - "2400"
      - "4800"
      - "9600"
      - "19200"
      - "31250"
      - "38400"
      - "57600"
      - "115200"
      - "230400"
      - "250000"
      - "256000"
      - "512000"
      - "921600"
    initial_option: "921600"
    optimistic: true
    restore_value: true
    internal: false
    entity_category: config
    disabled_by_default: true
    icon: mdi:swap-horizontal
    update_interval: never

switch:
  - id: tft_update_automatically
    name: Update TFT automatically
    platform: template
    icon: mdi:file-sync
    entity_category: config
    internal: false
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      then:
        - script.execute:
            id: check_versions
            reset_flag: false
...

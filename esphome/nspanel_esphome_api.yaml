#####################################################################################################
##### NSPANEL ESPHOME created by Blackymas - https://github.com/Blackymas/NSPanel_HA_Blueprint  #####
##### ESPHOME CORE - API                                                                        #####
##### PLEASE only make changes if it is necessary and also the required knowledge is available. #####
##### For normal use with the Blueprint, no changes are necessary.                              #####
#####################################################################################################
---
substitutions:
  ##############################
  ## Change only in your      ##
  ## local yaml substitutions ##
  ##############################
  BOOT_STEP_API: 30
  TAG_API: nspanel.api
  EVENT_NAME: esphome.nspanel_ha_blueprint

api:
  id: api_server
  homeassistant_services: true
  reboot_timeout: 60min

  on_client_connected:
    then:
      - lambda: |-
          system_flags.api_ready = true;
          boot_log->execute("API", "Client connected");
          refresh_wifi_icon->execute();
          dump_config->execute();

  on_client_disconnected:
    then:
      - lambda: |-
          if (!api_server->is_connected())
            system_flags.api_ready = false;
          refresh_wifi_icon->execute();

  actions:
    # Sends custom commands directly to the display for dynamic interactions and updates.
    - action: command
      variables:
        cmd: string  # Command string to be sent. Refer to the Nextion Instruction Set for supported commands: https://nextion.tech/instruction-set/
      then:
        - lambda: |-
            ESP_LOGV("${TAG_API}", "Action: command");
            ESP_LOGV("${TAG_API}", "  cmd: %s", cmd.c_str());
            disp1->send_command(cmd.c_str());

    # Changes the foreground color of a specified component on the display.
    - action: component_color
      variables:
        page: string  # Send `mem` for a memory var
        id: string    # Identifier of the component to change color. Ensure this matches the component's ID in your display layout.
        color: int[]  # New color for the component, specified as an RGB array (e.g., [255, 0, 0] for red).
      then:
        - lambda: |-
            action_component_color->execute(
              page.c_str(),
              id.c_str(),
              rgbTo565(color)
            );

    # Updates the text of a specified component on the display.
    - action: component_text
      variables:
        page: string  # Send `mem` for a memory var
        id: string    # Identifier of the component. Ensure it matches the component's ID in your display layout.
        txt: string   # New text content to be displayed. Supports both static and dynamic content.
      then:
        - lambda: |-
            action_component_text->execute(
              page.c_str(),
              id.c_str(),
              txt.c_str()
            );

    # Updates the value of a specified component on the display.
    - action: component_val
      variables:
        page: string  # Send `mem` for a memory var
        id: string    # Identifier of the component to update. Must match the component's ID in the display layout.
        val: int      # New integer value to set for the component. Adjust based on the data type you're displaying.
      then:
        - lambda: |-
            action_component_val->execute(
              page.c_str(),
              id.c_str(),
              val
            );

    # Hides or shows a specified component on the display.
    # Supports both simple component IDs and page-specific IDs (page.component format).
    - action: components_visibility
      variables:
        page: string  # Send `mem` for a memory var
        ids: string[]  # Identifier of the component to be hidden/shown. Can be 'component' or 'page.component' format.
        visible: bool  # Set to true to show the component, or false to hide it.
      then:
        - lambda: |-
            ESP_LOGV("${TAG_API}", "Action: components_visibility");
            ESP_LOGV("${TAG_API}", "  page: %s", page.c_str());

            for (const std::string& component_id : ids) {
              if (component_id.empty()) {
                ESP_LOGW("${TAG_API}", "Skipping empty component ID");
                continue;
              }

              ESP_LOGV("${TAG_API}", "Processing component ID: %s", component_id.c_str());
              if (page.empty() or current_page->state == page) {
                ESP_LOGV("${TAG_API}", "  Applying visibility changes");
                if (visible) {
                  disp1->show_component(component_id.c_str());
                } else {
                  disp1->hide_component(component_id.c_str());
                }
              } else {
                ESP_LOGV("${TAG_API}",
                          "  Current page (%s) doesn't match specified page (%s), skipping visibility update",
                          current_page->state.c_str(), page.c_str());
              }

            } // #endfor component_id iteration

            ESP_LOGV("${TAG_API}", "Processed %zu component IDs with visibility: %s",
                    ids.size(), YESNO(visible));

    # Displays detailed information for a specific entity.
    - action: entity_details_show
      variables:
        entity: string     # The ID of the entity for which details are shown. Supports "embedded_climate" for built-in climate control.
        back_page: string  # Specifies the page to return to. Accepts "home" or "buttonpage01" to "buttonpage04".
      then:
        - lambda: |-
            ESP_LOGV("${TAG_API}", "Action: entity_details_show");
            ESP_LOGV("${TAG_API}", "  entity: %s", entity.c_str());
            ESP_LOGV("${TAG_API}", "  back_page: %s", back_page.c_str());
            HomeAssistantEntity entity_id = extractHomeAssistantEntity(entity);
            if (entity == "embedded_climate") entity_id.domain = "climate";
            else if (entity_id.domain == "alarm_control_panel") entity_id.domain = "alarm";
            if (entity_id.domain != "invalid" or entity == "embedded_climate") {
              detailed_entity->publish_state(entity);
              delay(${DELAY_DEFAULT});
              goto_page->execute(get_page_id(entity_id.domain.c_str()));
              delay(${DELAY_DEFAULT});
              disp1->send_command_printf("back_page_id=%" PRIu8, get_page_id(back_page.c_str()));
              if (entity_id.domain == "climate")
                delay(${DELAY_DEFAULT});
                disp1->set_component_value("climate.embedded", (entity == "embedded_climate") ? 1 : 0);
            }

    - action: icon  # Updates icon, color, and visibility for display components
      variables:
        page: string       # Page name for visibility control. If empty, visibility is applied immediately.
        id: string         # Identifier of the component.
        icon: string       # Icon codepoint, e.g., "/uE6E8" for `mdi:lightbulb-on-outline`.
        icon_color: int[]  # RGB color array for the icon, e.g., [0, 255, 0] for green.
        visible: bool      # Set to `true` for visible or `false` for hidden.
      then:
        - lambda: |-
            ESP_LOGV("${TAG_API}", "Action: icon");

            if (id.empty()) {
              ESP_LOGW("${TAG_API}", "Empty component ID provided");
              return;
            }

            ESP_LOGV("${TAG_API}", "Processing component ID: %s", id.c_str());
            ESP_LOGV("${TAG_API}", "  page: %s", page.empty() ? "none (global)" : page.c_str());
            #if ESP_LOG_LEVEL >= ESP_LOG_VERBOSE
            const uint16_t icon_len = icon.length();
            if (icon_len == 3) {
              const uint32_t codepoint = decode_utf8(icon.c_str());
              ESP_LOGV("${TAG_API}", "  icon: %s (\\u%04" PRIx32 ")", icon.c_str(), codepoint);
            } else if (icon_len > 0) {
              ESP_LOGV("${TAG_API}", "  icon: '%s' (len=%" PRIu16 ")", icon.c_str(), icon_len);
            } else {
              ESP_LOGV("${TAG_API}", "  icon: null (len=0)");
            }
            #endif  // ESP_LOG_LEVEL >= ESP_LOG_VERBOSE
            ESP_LOGV("${TAG_API}", "  icon_color: %" PRIu16, rgbTo565(icon_color));
            ESP_LOGV("${TAG_API}", "  visible: %s", YESNO(visible));

            // Always set icon and color using the full ID as-is
            disp1->set_component_text(id.c_str(), icon.c_str());

            // Set icon color if provided
            if (icon_color.size() == 3) {
              disp1->set_component_font_color(id.c_str(), rgbTo565(icon_color));
            }

            if (page.empty() or current_page->state == page) {
              ESP_LOGV("${TAG_API}", "  Applying visibility changes");
              if (visible) {
                disp1->show_component(id.c_str());
              } else {
                disp1->hide_component(id.c_str());
              }
            } else {
              ESP_LOGV("${TAG_API}",
                        "  Current page (%s) doesn't match specified page (%s), skipping visibility update",
                        current_page->state.c_str(), page.c_str());
            }

    # Dynamically displays QR codes on the ESPHome UI for sharing information such as WiFi passwords or website links.
    - action: qrcode
      variables:
        title: string   # Heading or title for the QR code, offering context or instructions.
        qrcode: string  # Data or URL to be encoded into the QR code.
        show: bool      # Flag to immediately display the QR code page upon service invocation.
      then:
        - lambda: |-
            if (current_page_id == ${PAGE_HOME_ID})
              disp1->send_command_printf("vis bt_qrcode,%i", qrcode.empty() ? 0 : 1);
            disp1->set_component_text("qrcode.qrcode_label", title.c_str());
            disp1->set_component_text("qrcode.qrcode_value", qrcode.c_str());
            if (show)
              goto_page->execute(${PAGE_QRCODE_ID});

            // Update blueprint status
            blueprint_status_flags.qrcode = true;

    # Utilities group refresh
    - action: utilities_group_refresh
      variables:
        group_id: string
        value1: string
        value2: string
        direction: int
        constructor: bool
      then:
        - lambda: |-
            ESP_LOGV("${TAG_API}", "Action: utilities_group_refresh");
            ESP_LOGV("${TAG_API}", "  group_id: %s", group_id.c_str());
            ESP_LOGV("${TAG_API}", "  value1: %s", value1.c_str());
            ESP_LOGV("${TAG_API}", "  value2: %s", value2.c_str());
            ESP_LOGV("${TAG_API}", "  direction: %i", direction);
            ESP_LOGV("${TAG_API}", "  constructor: %s", YESNO(constructor));
            if (group_id.empty()) {
              ESP_LOGW("${TAG_API}", "`group_id` is empty");
              return;
            }

            uint8_t id = findUtilitiesGroupIndex(group_id.c_str());
            if (id == UINT8_MAX) {
              ESP_LOGW("${TAG_API}", "`group_id` not found");
              return;
            }
            // Update Value 1
            if (!value1.empty() and
                (constructor or strcmp(value1.c_str(), UtilitiesGroups[id].value1) != 0)) {
              copyStringToCharArray(UtilitiesGroups[id].value1, value1);
              disp1->set_component_text(group_id.c_str(), value1.c_str());
              delay(${DELAY_DEFAULT});
            }

            // Update Value 2
            if (!value2.empty() and
                (constructor or strcmp(value2.c_str(), UtilitiesGroups[id].value2) != 0)) {
              copyStringToCharArray(UtilitiesGroups[id].value2, value2);
              disp1->set_component_text((group_id + "b").c_str(), value2.c_str());
              delay(${DELAY_DEFAULT});
            }

            // Update direction
            if (group_id != "grid" and !isnan(direction) and
                (constructor or direction != UtilitiesGroups[id].direction)) {
              UtilitiesGroups[id].direction = direction;
              disp1->set_component_value((group_id + "_line_d").c_str(), direction);
              delay(${DELAY_DEFAULT});
            }

    # Wake Up Service
    - action: wake_up
      variables:
        reset_timer: bool  # Determines whether to reset the sleep and dimming timers upon waking the display.
      then:
        - lambda: wakeup->execute(reset_timer);

esphome:
  platformio_options:
    build_flags:
      - -D NSPANEL_HA_BLUEPRINT_API

script:
  - id: action_component_color
    mode: single
    parameters:
      page: string       # Send `mem` for a memory var
      component: string  # Identifier of the component to change color. Ensure this matches the component's ID in your display layout.
      color: uint16_t    # New color for the component, rgb565.
    then:
      - lambda: |-
          ESP_LOGV("${TAG_API}", "Script: action_component_color");
          ESP_LOGV("${TAG_API}", "  page: %s", page.c_str());
          ESP_LOGV("${TAG_API}", "  component: %s", component.c_str());
          ESP_LOGV("${TAG_API}", "  color: %" PRIu16, color);
          if (page.empty()) {
            disp1->set_component_font_color(component.c_str(), color);
            return;
          }
          if (page != "mem") {
            disp1->send_command_printf("%s.%s.pco=%" PRIu16, page.c_str(), component.c_str(), color);
            return;
          }

  - id: action_component_text
    mode: single
    parameters:
      page: string       # Send `mem` for a memory var
      component: string  # Identifier of the component. Ensure it matches the component's ID in your display layout.
      txt: string        # New text content to be displayed. Supports both static and dynamic content.
    then:
      - lambda: |-
          ESP_LOGV("${TAG_API}", "Script: action_component_text");
          ESP_LOGV("${TAG_API}", "  page: %s", page.c_str());
          ESP_LOGV("${TAG_API}", "  component: %s", component.c_str());
          ESP_LOGV("${TAG_API}", "  txt: %s", txt.c_str());
          if (page.empty()) {
            disp1->set_component_text(component.c_str(), txt.c_str());
            return;
          }
          if (page != "mem") {
            disp1->send_command_printf("%s.%s.txt=\"%s\"", page.c_str(), component.c_str(), txt.c_str());
            return;
          }

  - id: action_component_val
    mode: single
    parameters:
      page: string       # Send `mem` for a memory var
      component: string  # Identifier of the component to update. Must match the component's ID in the display layout.
      val: int32_t       # New integer value to set for the component. Adjust based on the data type you're displaying.
    then:
      # Extended by:
      # - hw_buttons
      # - page_home
      - lambda: |-
          ESP_LOGV("${TAG_API}", "Script: action_component_val");
          ESP_LOGV("${TAG_API}", "  page: %s", page.c_str());
          ESP_LOGV("${TAG_API}", "  component: %s", component.c_str());
          ESP_LOGV("${TAG_API}", "  val: %i", val);
          if (page.empty()) {
            disp1->set_component_value(component.c_str(), val);
            return;
          }
          if (page != "mem") {
            disp1->send_command_printf("%s.%s.val=%" PRId32, page.c_str(), component.c_str(), val);
            return;
          }

  - id: api_recover_from_failed
    mode: single
    then:
      - while:
          condition:
            - lambda: return api_server->is_failed();
          then:
            - lambda: |-
                ESP_LOGW("${TAG_API}", "API reported a failed state. Recovering...");
                api_server->setup();
            - delay: 5s

  - id: !extend dump_config
    then:
      - lambda: |-
          // Report API status
          if (api_server->is_connected()) {
            ESP_LOGCONFIG("${TAG_API}", "API: Connected");
          } else {
            ESP_LOGW("${TAG_API}", "API: DISCONNECTED");
          }

  - id: ha_button
    mode: parallel
    parameters:
      page: string
      component: string
      command: string
    then:
      - lambda: timer_reset_all->execute();
      - homeassistant.event:
          event: ${EVENT_NAME}
          data:
            device_name: !lambda return cached_device_name.c_str();
            type: button_click
            page: !lambda return page;
            component: !lambda return component;
            command: !lambda return command;

  - id: !extend stop_all
    then:
      - lambda: |-
          api_recover_from_failed->stop();
          ha_button->stop();

  - id: !extend watchdog_round
    then:
      - lambda: |-
          if (!api_server->is_connected() and
              current_page_id != ${PAGE_BOOT_ID} and
              current_page_id != ${PAGE_CONFIRM_ID} and
              current_page_id != ${PAGE_HOME_ID} and
              current_page_id != ${PAGE_QRCODE_ID} and
              current_page_id != ${PAGE_SCREENSAVER_ID} and
              current_page_id != ${PAGE_SETTINGS_ID} and
              current_page->state != "blank") {
            ESP_LOGW("${TAG_DATETIME}", "API disconnected. Falling back to Home page.");
            goto_page->execute(${PAGE_HOME_ID});
          }
wifi:
  on_connect:
    then:
      - lambda: api_recover_from_failed->execute();
...

#####################################################################################################
##### NSPANEL ESPHOME created by Blackymas - https://github.com/Blackymas/NSPanel_HA_Blueprint  #####
##### ESPHOME CORE - API                                                                        #####
##### PLEASE only make changes if it is necessary and also the required knowledge is available. #####
##### For normal use with the Blueprint, no changes are necessary.                              #####
#####################################################################################################
---
substitutions:
  ##############################
  ## Change only in your      ##
  ## local yaml substitutions ##
  ##############################
  BOOT_STEP_API: '30'
  TAG_API: nspanel.api
  EVENT_NAME: esphome.nspanel_ha_blueprint

api:
  id: api_server
  homeassistant_services: true
  reboot_timeout: 60min

  on_client_connected:
    then:
      - lambda: set_system_flag(NSPanelFlag::API_READY);
      - if:
          condition:
            - text_sensor.state:
                id: current_page
                state: boot
          then:
            - script.execute:
                id: boot_log
                category: API
                log_message: "Client connected"
      - script.execute: refresh_wifi_icon
      - script.execute: dump_config
  on_client_disconnected:
    then:
      - if:
          condition:
            not:
              api.connected:
          then:
            - lambda: clear_system_flag(NSPanelFlag::API_READY);
      - script.execute: refresh_wifi_icon

  actions:
    # Dynamically configures button properties on a specified page,
    # enhancing UI interactivity by allowing updates to button appearance and behavior based on given parameters.
    - action: button
      variables:
        page: string       # Identifier of the page where the button is located.
        id: string         # Unique identifier for the button.
        state: bool        # Determines the button's state, influencing background and other visual aspects.
        icon: string       # Icon codepoint from HASwitchPlate Material Design Icons. Example: "\uE6E8" for mdi:lightbulb-on-outline.
        icon_color: int[]  # RGB color array for the icon.
        icon_font: int     # Nextion font identifier for the icon, default is 8.
        bri: string        # Brightness level or other dynamic info to be displayed close to the icon.
        label: string      # Main text label for the button.
      then:
        - lambda: |-
            ESP_LOGV("${TAG_API}", "Action `button` triggered:");
            ESP_LOGV("${TAG_API}", "  page: %s", page.c_str());
            ESP_LOGV("${TAG_API}", "  id: %s", id.c_str());
            ESP_LOGV("${TAG_API}", "  state: %s", ONOFF(state));
            ESP_LOGV("${TAG_API}", "  icon_color: %" PRIu16, icon_color);
            ESP_LOGV("${TAG_API}", "  icon_font: %i", icon_font);
            ESP_LOGV("${TAG_API}", "  bri: %s", bri.c_str());
            ESP_LOGV("${TAG_API}", "  label: %s", label.c_str());

            if (page != current_page->state) {
              ESP_LOGW("${TAG_API}", "Page '%s' visible while '%s' was expected", current_page->state.c_str(), page.c_str());
              return;
            }

            disp1->set_component_picc((id + "pic").c_str(), state ? 47 : 46);
            disp1->set_component_picc((id + "bri").c_str(), state ? 47 : 46);
            disp1->set_component_picc((id + "text").c_str(), state ? 47 : 46);
            disp1->set_component_picc((id + "icon").c_str(), state ? 47 : 46);
            disp1->set_component_font((id + "icon").c_str(), icon_font);
            disp1->set_component_foreground_color((id + "bri").c_str(), state ? 10597 : 65535);
            disp1->set_component_foreground_color((id + "text").c_str(), state ? 10597 : 65535);
            disp1->set_component_font_color((id + "icon").c_str(), rgbTo565(icon_color));
            disp1->set_component_text((id + "icon").c_str(), icon.c_str());

            display_wrapped_text->execute((id + "text").c_str(), label.c_str(), 10);
            disp1->set_component_text((id + "bri").c_str(), (strcmp(bri.c_str(), "0") == 0) ? " " : bri.c_str());

            set_component_visibility->execute((id + "pic").c_str(), true);
            set_component_visibility->execute((id + "icon").c_str(), true);
            set_component_visibility->execute((id + "text").c_str(), true);
            set_component_visibility->execute((id + "bri").c_str(), true);
            set_component_visibility->execute(id.c_str(), true);

    # Sends custom commands directly to the display for dynamic interactions and updates.
    - action: command
      variables:
        cmd: string  # Command string to be sent. Refer to the Nextion Instruction Set for supported commands: https://nextion.tech/instruction-set/
      then:
        - lambda: |-
            ESP_LOGV("${TAG_API}", "Action: command");
            ESP_LOGV("${TAG_API}", "  cmd: %s", cmd.c_str());
            disp1->send_command(cmd.c_str());

    # Changes the foreground color of a specified component on the display.
    - action: component_color
      variables:
        id: string    # Identifier of the component to change color. Ensure this matches the component's ID in your display layout.
        color: int[]  # New color for the component, specified as an RGB array (e.g., [255, 0, 0] for red).
      then:
        - lambda: |-
            ESP_LOGV("${TAG_API}", "Action: component_color");
            ESP_LOGV("${TAG_API}", "  id: %s", id.c_str());
            ESP_LOGV("${TAG_API}", "  color: %i", rgbTo565(color));
            disp1->set_component_font_color(id.c_str(), rgbTo565(color));

    # Updates the text of a specified component on the display.
    - action: component_text
      variables:
        id: string   # Identifier of the component. Ensure it matches the component's ID in your display layout.
        txt: string  # New text content to be displayed. Supports both static and dynamic content.
      then:
        - lambda: |-
            ESP_LOGV("${TAG_API}", "Action: component_text");
            ESP_LOGV("${TAG_API}", "  component_id: %s", id.c_str());
            ESP_LOGV("${TAG_API}", "  txt: %s", txt.c_str());
            disp1->set_component_text(id.c_str(), txt.c_str());

    # Updates the value of a specified component on the display.
    - action: component_val
      variables:
        id: string  # Identifier of the component to update. Must match the component's ID in the display layout.
        val: int    # New integer value to set for the component. Adjust based on the data type you're displaying.
      then:
        - lambda: |-
            ESP_LOGV("${TAG_API}", "Action: component_val");
            ESP_LOGV("${TAG_API}", "  id: %s", id.c_str());
            ESP_LOGV("${TAG_API}", "  val: %i", val);
            disp1->set_component_value(id.c_str(), val);

    # Hides or shows a specified component on the display.
    - action: components_visibility
      variables:
        ids: string[]  # Identifier of the component to be hidden/shown. Ensure this matches the component's ID in your display layout.
        visible: bool  # Set to true to show the component, or false to hide it.
      then:
        - lambda: |-
            ESP_LOGV("${TAG_API}", "Action: components_visibility");
            for (const std::string& component_id : ids) {
              if (not component_id.empty()) {
                ESP_LOGV("${TAG_API}", "  id: %s", component_id.c_str());
                set_component_visibility->execute(component_id.c_str(), visible);
              }
            }
            ESP_LOGV("${TAG_API}", "  ids count: %i", ids.size());
            ESP_LOGV("${TAG_API}", "  visible: %s", YESNO(visible));

    # Displays detailed information for a specific entity.
    - action: entity_details_show
      variables:
        entity: string     # The ID of the entity for which details are shown. Supports "embedded_climate" for built-in climate control.
        back_page: string  # Specifies the page to return to. Accepts "home" or "buttonpage01" to "buttonpage04".
      then:
        - lambda: |-
            ESP_LOGV("${TAG_API}", "Action: entity_details_show");
            ESP_LOGV("${TAG_API}", "  entity: %s", entity.c_str());
            ESP_LOGV("${TAG_API}", "  back_page: %s", back_page.c_str());
            HomeAssistantEntity entity_id = extractHomeAssistantEntity(entity);
            if (entity == "embedded_climate") entity_id.domain = "climate";
            else if (entity_id.domain == "alarm_control_panel") entity_id.domain = "alarm";
            if (entity_id.domain != "invalid" or entity == "embedded_climate") {
              detailed_entity->publish_state(entity);
              delay(${DELAY_DEFAULT});
              goto_page->execute(entity_id.domain.c_str());
              delay(${DELAY_DEFAULT});
              disp1->send_command_printf("back_page_id=%" PRIu8, get_page_id(back_page.c_str()));
              if (entity_id.domain == "climate")
                delay(${DELAY_DEFAULT});
                disp1->set_component_value("climate.embedded", (entity == "embedded_climate") ? 1 : 0);
            }

    # Hardware Button State Indication Service
    - action: hw_button_state
      variables:
        button_mask: int  # Bitwise value for buttons: 1 for "left button", 2 for "right button", 3 for both buttons
        state: bool       # State for the button(s) indication: true for active, false for inactive
      then:
        - lambda: |-
            ESP_LOGV("${TAG_API}", "Action: hw_button_state");
            ESP_LOGV("${TAG_API}", "  button_mask: %i", button_mask);
            ESP_LOGV("${TAG_API}", "  state: %s", ONOFF(state));
            // Updates the visual state indication for hardware buttons
            // Use bitwise AND to check specific bits
            if (button_mask & 1) // Checks if the least significant bit is set (left button)
              update_bitwise_setting(id(buttons_settings), state, ButtonSettings::ButtonLeft_State);
            if (button_mask & 2) // Checks if the second least significant bit is set (right button)
              update_bitwise_setting(id(buttons_settings), state, ButtonSettings::ButtonRight_State);
        # Refreshes the indication bars on the display
        - script.execute:
            id: refresh_hardware_buttons_bars
            button_mask: !lambda return button_mask;

    # Icon Service
    - action: icon
      variables:
        id: string         # Identifier of the component. See "Screen components" in the documentation.
        icon: string       # Icon codepoint, e.g., "/uE6E8" for `mdi:lightbulb-on-outline`.
        icon_color: int[]  # RGB color array for the icon, e.g., [0, 255, 0] for green.
        visible: bool      # Set to `true` for visible or `false` for hidden.
      then:
        - lambda: |-
            ESP_LOGV("${TAG_API}", "Action: icon");
            ESP_LOGV("${TAG_API}", "  id: %s", id.c_str());
            ESP_LOGV("${TAG_API}", "  icon: %s", icon.c_str());
            ESP_LOGV("${TAG_API}", "  icon_color: %" PRIu16, rgbTo565(icon_color));
            ESP_LOGV("${TAG_API}", "  visible: %s", YESNO(visible));
            disp1->set_component_text(id.c_str(), visible ? icon.c_str() : "");
            if (icon_color.size() == 3) {
              disp1->set_component_font_color(id.c_str(), rgbTo565(icon_color));
            }
            set_component_visibility->execute(id.c_str(), visible);

    # Transfers global settings from the blueprint to ESPHome, configuring the necessary parameters for optimal operation.
    - action: init_global
      variables:
        blueprint_version: string      # Version of the blueprint in use.
        ent_value_xcen: int            # Alignment of values on entities pages (0 for right (default), 1 for center or 2 for left).
        mui_please_confirm: string     # Localized message for confirmation prompts.
        mui_unavailable: string        # Localized message indicating unavailability.
        screensaver_time: bool         # Toggles the screensaver time display.
        screensaver_time_font: int     # Specifies the font id for the screensaver time display.
        screensaver_time_color: int[]  # RGB color for the screensaver time display, e.g., [165, 42, 42] for reddish-brown.
        decimal_separator: string      # The char to be used as decimal separator.
      then:
        - lambda: boot_log->execute("Service", "init_global");
        - script.execute:
            id: global_settings
            blueprint_version: !lambda return blueprint_version;
            ent_value_xcen: !lambda return ent_value_xcen;
            mui_please_confirm: !lambda return mui_please_confirm;
            mui_unavailable: !lambda return mui_unavailable;
            screensaver_time: !lambda return screensaver_time;
            screensaver_time_font: !lambda return screensaver_time_font;
            screensaver_time_color: !lambda return screensaver_time_color;
            decimal_separator: !lambda return decimal_separator;
        - lambda: set_blueprint_status_flag(BlueprintStatusFlag::GLOBAL_SETTINGS);
        - script.wait: global_settings

    # Configures NSPanel hardware (buttons, relays, etc.) settings
    - action: init_hardware
      variables:
        relay1_local_control: bool              # Enable/disable local control for Relay 1.
        relay1_icon: string                     # Icon for Relay 1 (e.g., "\uE3A5" for mdi:numeric-1-box-outline).
        relay1_icon_color: int[]                # RGB color array for Relay 1's icon.
        relay1_fallback: bool                   # Fallback state for Relay 1 in case of communication loss.
        relay2_local_control: bool              # Enable/disable local control for Relay 2.
        relay2_icon: string                     # Icon for Relay 2 (e.g., "\uE3A8" for mdi:numeric-2-box-outline).
        relay2_icon_color: int[]                # RGB color array for Relay 2's icon.
        relay2_fallback: bool                   # Fallback state for Relay 2 in case of communication loss.
        button_left: bool                       # Enable/disable left button status visualization.
        button_right: bool                      # Enable/disable right button status visualization.
        button_bar_pages: int                   # As uint representing the list of pages where the buttons bars will be visible
        button_bar_color_on: int[]              # RGB color array for the hardware button bar when the status is `On`.
        button_bar_color_off: int[]             # RGB color array for the hardware button bar when the status is `Off`.
        embedded_climate: bool                  # Indicates if climate control is integrated.
        embedded_climate_friendly_name: string  # Friendly name for the climate control feature.
        embedded_indoor_temperature: bool       # Enables indoor temperature display.
      then:
        - lambda: boot_log->execute("Service", "init_hardware");
        - delay: ${DELAY_DEFAULT}ms
        - script.execute:
            id: init_hardware_climate
            embedded_climate: !lambda return embedded_climate;
            embedded_climate_friendly_name: !lambda return embedded_climate_friendly_name;
            embedded_indoor_temperature: !lambda return embedded_indoor_temperature;

        # Relay settings
        - delay: ${DELAY_DEFAULT}ms
        - lambda: |-
            using namespace esphome::display;
            update_bitwise_setting(id(relay_settings), relay1_local_control, RelaySettings::Relay1_Local);
            update_bitwise_setting(id(relay_settings), relay1_fallback, RelaySettings::Relay1_Fallback);
            update_bitwise_setting(id(relay_settings), relay2_local_control, RelaySettings::Relay2_Local);
            update_bitwise_setting(id(relay_settings), relay2_fallback, RelaySettings::Relay2_Fallback);

        # Relay icons
        - delay: ${DELAY_DEFAULT}ms
        - lambda: |-
            using namespace esphome::display;
            if (not relay1_icon.empty()) id(home_relay1_icon) = relay1_icon;
            if (not relay2_icon.empty()) id(home_relay2_icon) = relay2_icon;

            // Relay icon's colors
            if (relay1_icon_color.size() == 3) {
              id(home_relay1_icon_color) = rgbTo565(relay1_icon_color);
              disp1->set_component_font_color("home.chip_relay1", id(home_relay1_icon_color));
            }
            if (relay2_icon_color.size() == 3) {
              id(home_relay2_icon_color) = rgbTo565(relay2_icon_color);
              disp1->set_component_font_color("home.chip_relay2", id(home_relay2_icon_color));
            }

        # Buttons bars settings
        - delay: ${DELAY_DEFAULT}ms
        - globals.set:
            id: buttons_bars_pages
            value: !lambda return button_bar_pages;
        - lambda: |-
            using namespace esphome::display;
            update_bitwise_setting(id(buttons_settings), button_left, ButtonSettings::ButtonLeft_Enabled);
            update_bitwise_setting(id(buttons_settings), button_right, ButtonSettings::ButtonRight_Enabled);
        - if:
            condition:
              - lambda: return (button_bar_color_on.size() == 3);
            then:
              - globals.set:
                  id: buttons_color_on
                  value: !lambda return rgbTo565(button_bar_color_on);
        - if:
            condition:
              - lambda: return (button_bar_color_off.size() == 3);
            then:
              - globals.set:
                  id: buttons_color_off
                  value: !lambda return rgbTo565(button_bar_color_off);

        # Update relays icons
        - delay: ${DELAY_DEFAULT}ms
        - script.execute:
            id: refresh_relays
            relay_mask: 3
        # Update buttons bars
        - delay: ${DELAY_DEFAULT}ms
        - script.execute:
            id: refresh_hardware_buttons_bars
            button_mask: 3

        # Update blueprint status
        - lambda: set_blueprint_status_flag(BlueprintStatusFlag::RELAY_SETTINGS);

    # Populates the "Settings" page with user-configurable options, aligning with the project's blueprint for a cohesive and intuitive settings interface.
    - action: init_page_settings
      variables:
        reboot: string      # Label for the reboot button, directing users on restarting the device.
        brightness: string  # Caption for brightness adjustment controls.
        bright: string      # Text label for the high brightness level slider, signaling a brighter screen option.
        dim: string         # Text label for the dim brightness level slider, signaling a lower light option for energy saving.
      then:
        - lambda: |-
            boot_log->execute("Service", "init_page_settings");
            if (not reboot.empty()) disp1->set_component_text_printf("settings.lbl_reboot", " %s", reboot.c_str());
            disp1->set_component_text_printf("settings.lbl_brightness", " %s", brightness.c_str());
        - script.execute:
            id: display_wrapped_text
            component: "settings.lbl_bright"
            text_to_display: !lambda return bright;
            line_length_limit: !lambda |-
              return display_mode->state == 2 ? 25 : 10;
        - script.execute:
            id: display_wrapped_text
            component: "settings.lbl_dim"
            text_to_display: !lambda return dim;
            line_length_limit: !lambda |-
              return display_mode->state == 2 ? 25 : 10;

        # Update blueprint status
        - lambda: set_blueprint_status_flag(BlueprintStatusFlag::PAGE_SETTINGS);

    # Dynamically updates the climate page with the latest climate control settings and status.
    - action: page_climate
      variables:
        current_temp: float      # Current temperature reading.
        supported_features: int  # Bitmask indicating the supported features of the climate device, such as temperature control (1) and fan mode (4).
        target_temp: float       # Desired target temperature setting.
        target_temp_high: float  # Upper limit of the target temperature range for devices supporting ranges.
        target_temp_low: float   # Lower limit of the target temperature range.
        temp_step: int           # Temperature adjustment step size, indicating the granularity of changes (multiplied by 10 for precision).
        total_steps: int         # Total adjustment steps available, derived from the device's temperature range and step size.
        temp_offset: int         # Calibration offset applied to the temperature reading (multiplied by 10 for precision).
        climate_icon: string     # Icon codepoint representing the current climate status, chosen from HASwitchPlate Material Design Icons.
        embedded_climate: bool   # Indicates if climate control is integrated into the interface.
        entity: string           # Entity ID of the climate device, allowing for direct control and status updates.
      then:
        - lambda: |-
            ESP_LOGV("${TAG_API}", "Action: page_climate");
            ESP_LOGV("${TAG_API}", "  current_temp: %f", current_temp);
            ESP_LOGV("${TAG_API}", "  supported_features: %i", supported_features);
            ESP_LOGV("${TAG_API}", "  target_temp: %i", target_temp);
            ESP_LOGV("${TAG_API}", "  target_temp_high: %f", target_temp_high);
            ESP_LOGV("${TAG_API}", "  target_temp_low: %f", target_temp_low);
            ESP_LOGV("${TAG_API}", "  temp_step: %i", temp_step);
            ESP_LOGV("${TAG_API}", "  total_steps: %i", total_steps);
            ESP_LOGV("${TAG_API}", "  temp_offset: %i", temp_offset);
            ESP_LOGV("${TAG_API}", "  climate_icon: %s", climate_icon.c_str());
            ESP_LOGV("${TAG_API}", "  embedded_climate: %s", YESNO(embedded_climate));
            ESP_LOGV("${TAG_API}", "  entity: %s", entity.c_str());
        - if:
            condition:
              - text_sensor.state:
                  id: current_page
                  state: climate
            then:  # Update climate page
              # Set detailed entity sensor
              - text_sensor.template.publish:
                  id: detailed_entity
                  state: !lambda return entity;
        - script.execute:
            id: set_climate
            current_temp: !lambda return current_temp;
            supported_features: !lambda return supported_features;
            target_temp: !lambda return target_temp;
            target_temp_high: !lambda return target_temp_high;
            target_temp_low: !lambda return target_temp_low;
            temp_step: !lambda return temp_step;
            total_steps: !lambda return total_steps;
            temp_offset: !lambda return temp_offset;
            climate_icon: !lambda return climate_icon;
            embedded_climate: !lambda return embedded_climate;
        - delay: 1s

    # Dynamically displays QR codes on the ESPHome UI for sharing information such as WiFi passwords or website links.
    - action: qrcode
      variables:
        title: string   # Heading or title for the QR code, offering context or instructions.
        qrcode: string  # Data or URL to be encoded into the QR code.
        show: bool      # Flag to immediately display the QR code page upon service invocation.
      then:
        - script.execute:
            id: set_component_visibility
            component_id: "home.bt_qrcode"
            show: !lambda return !(qrcode.empty());
        - lambda: |-
            disp1->set_component_text("qrcode.qrcode_label", title.c_str());
            disp1->set_component_text("qrcode.qrcode_value", qrcode.c_str());
        - if:
            condition:
              - lambda: return show;
            then:
              - script.execute:
                  id: goto_page
                  page: qrcode

        # Update blueprint status
        - lambda: set_blueprint_status_flag(BlueprintStatusFlag::QRCODE);

    - action: set_bool
      variables:
        component: string
        val: bool
      then:
        - script.execute:
            id: set_bool_action
            component: !lambda return component;
            val: !lambda return val;

    - action: set_int
      variables:
        component: string
        val: int
      then:
        - if:
            condition:
              - lambda: return (component == "bytes_per_char");
            then:
              - globals.set:
                  id: mui_bytes_per_char
                  value: !lambda return val;

    - action: set_string
      variables:
        component: string
        val: string
      then:
        - if:
            condition:
              - lambda: return (component == "timezone");
            then:
              - script.execute:
                  id: set_timezone
                  timezone: !lambda return val;

    - action: set_timezone  # To do: Merge this on another init service for v4.4.0
      variables:
        timezone: string
      then:
        - script.execute:
            id: set_timezone
            timezone: !lambda return timezone;

    # Utilities group refresh
    - action: utilities_group_refresh
      variables:
        group_id: string
        value1: string
        value2: string
        direction: int
        constructor: bool
      then:
        - if:
            condition:
              - lambda: return group_id.empty();
            then:
              - lambda: ESP_LOGW("${TAG_API}", "`group_id` is empty");
            else:
              - lambda: |-
                  uint8_t id = findUtilitiesGroupIndex(group_id.c_str());
                  if (id != UINT8_MAX) {
                    // Update Value 1
                    if (!value1.empty() and
                        (constructor or strcmp(value1.c_str(), UtilitiesGroups[id].value1) != 0)) {
                      copyStringToCharArray(UtilitiesGroups[id].value1, value1);
                      disp1->set_component_text(group_id.c_str(), value1.c_str());
                      delay(${DELAY_DEFAULT});
                    }

                    // Update Value 2
                    if (!value2.empty() and
                        (constructor or strcmp(value2.c_str(), UtilitiesGroups[id].value2) != 0)) {
                      copyStringToCharArray(UtilitiesGroups[id].value2, value2);
                      disp1->set_component_text((group_id + "b").c_str(), value2.c_str());
                      delay(${DELAY_DEFAULT});
                    }

                    // Update direction
                    if (group_id != "grid" and !isnan(direction) and
                        (constructor or direction != UtilitiesGroups[id].direction)) {
                      UtilitiesGroups[id].direction = direction;
                      disp1->set_component_value((group_id + "_line_d").c_str(), direction);
                      delay(${DELAY_DEFAULT});
                    }
                  }

    # Updates an entity to display specific values with dynamic icons, names, and color codes.
    - action: value
      variables:
        id: string          # Identifier of the entity. See "Screen components" for entity IDs.
        icon: string        # Icon codepoint (e.g., "/uE6E8" for mdi:thermometer) from HASwitchPlate Material Design Icons.
        icon_color: int[]   # RGB color array for the icon (e.g., [255, 0, 0] for red).
        name: string        # Display name for the entity (e.g., "Temperature").
        value: string       # Actual value to display (e.g., "75°F").
        value_color: int[]  # RGB color array for the value text (e.g., [255, 255, 0] for yellow).
      then:
        - lambda: |-
            ESP_LOGV("${TAG_API}", "Action: value");
            ESP_LOGV("${TAG_API}", "  id: %s", id.c_str());
            ESP_LOGV("${TAG_API}", "  icon: %s", icon.c_str());
            ESP_LOGV("${TAG_API}", "  icon_color: %" PRIu16, rgbTo565(value_color));
            ESP_LOGV("${TAG_API}", "  name: %s", name.c_str());
            ESP_LOGV("${TAG_API}", "  value: %s", value.c_str());
            ESP_LOGV("${TAG_API}", "  value_color: %" PRIu16, rgbTo565(value_color));

            // Stop if Id is empty
            if (id.empty()) {
              ESP_LOGW("${TAG_API}", "`id` is empty");
              return;
            }

            // Icon
            if (not icon.empty()) {
              disp1->set_component_text((id + "_icon").c_str(), icon.c_str());
            }

            // Icon color
            if (icon_color.size() == 3) {
              disp1->set_component_font_color((id + "_icon").c_str(), rgbTo565(icon_color));
            }

            // Label
            if (not name.empty()) {
              disp1->set_component_text((id + "_label").c_str(), name.c_str());
            }

            // Value
            if (not value.empty()) {
              disp1->set_component_text(
                        id.c_str(),
                        adjustDecimalSeparator(
                                                value,
                                                id(mui_decimal_separator).empty() ? '.' : id(mui_decimal_separator)[0]
                                              ).c_str()
              );
            }

            // Value color
            if (value_color.size() == 3)
              disp1->set_component_font_color(id.c_str(), rgbTo565(value_color));

            // Value font
            if ((not value.empty()) and (current_page->state.find("entitypage") == 0)) {
              // Adjusted length starts at 0
              float adjusted_length = 0.0;

              // Iterate over each character in the string
              for (char const &c: value) {
                // Check if character is a space or other specified exceptions
                if (display_charset->state == 2 or std::string(" iljtIf'-,;:!.\"|()[]{}").find(c) != std::string::npos) {
                  adjusted_length += 0.5; // Count these as half
                } else {
                  adjusted_length += 1.0; // Count all other characters as 1
                }
              }

              // Decide which font to use based on adjusted length
              if (adjusted_length > 8.0 and adjusted_length <= 12.0) {
                disp1->set_component_font(id.c_str(), 1);
              } else if (adjusted_length > 12.0) {
              disp1->set_component_font(id.c_str(), 0);
              }
            }

    # Wake Up Service
    - action: wake_up
      variables:
        reset_timer: bool  # Determines whether to reset the sleep and dimming timers upon waking the display.
      then:
        - if:
            condition:
              - text_sensor.state:
                  id: current_page
                  state: screensaver
            then:
              - script.execute:
                  id: goto_page
                  page: !lambda return wakeup_page_name->state;
        - if:
            condition:
              - lambda: return reset_timer;
            then:
              - script.execute: timer_reset_all
            else:
              - script.execute: timer_sleep
              - script.execute: timer_dim

esphome:
  platformio_options:
    build_flags:
      - -D NSPANEL_HA_BLUEPRINT_API

script:
  - id: api_recover_from_failed
    mode: single
    then:
      - while:
          condition:
            - lambda: return api_server->is_failed();
          then:
            - lambda: |-
                ESP_LOGW("${TAG_API}", "API reported a failed state. Recovering...");
                api_server->setup();
            - delay: 5s

  - id: !extend dump_config
    then:
      # Report API status
      - if:
          condition:
            - api.connected:
          then:
            - lambda: |-
                ESP_LOGCONFIG("${TAG_API}", "API: Connected");
          else:
            - lambda: |-
                ESP_LOGW("${TAG_API}", "API: DISCONNECTED");

  - id: ha_button
    mode: parallel
    parameters:
      page: string
      component: string
      command: string
    then:
      - script.execute: timer_reset_all
      - homeassistant.event:
          event: ${EVENT_NAME}
          data:
            device_name: !lambda return device_name->state.c_str();
            esphome_version: ${version}
            type: button_click
            page: !lambda return page;
            component: !lambda return component;
            command: !lambda return command;

  - id: ha_call_action
    mode: single
    parameters:
      service: string
      key: string
      value: string
    then:
      - lambda: |-
          ESP_LOGV("${TAG_API}", "Home Assistand Call Action:");
          ESP_LOGV("${TAG_API}", "  service: %s", service.c_str());
          ESP_LOGV("${TAG_API}", "  key:     %s", key.c_str());
          ESP_LOGV("${TAG_API}", "  value:   %s", value.c_str());
      - if:
          condition:
            - lambda: return !service.empty();
          then:
            - lambda: |-
                ESP_LOGVV("${TAG_API}", "  Sending to Home Assistant...");
            - homeassistant.event:
                event: ${EVENT_NAME}
                data:
                  device_name: !lambda return device_name->state.c_str();
                  esphome_version: ${version}
                  type: service_call
                  service: !lambda return service;
                  key: !lambda return key;
                  value: !lambda return value;
                  entity: !lambda return detailed_entity->state.c_str();
            - lambda: |-
                ESP_LOGVV("${TAG_API}", "  Action call sent!");

  - id: !extend stop_all
    then:
      - script.stop: api_recover_from_failed
      - script.stop: ha_button
      - script.stop: ha_call_action

  - id: set_bool_action
    mode: queued
    max_runs: 3
    parameters:
      component: string
      val: bool
    then:
      - if:
          condition:
            - lambda: return (component == "is_climate");
          then:
            - globals.set:
                id: is_climate
                value: !lambda return val;
      # int is_buttonpage01=0, is_buttonpage02=0, is_buttonpage03=0, is_buttonpage04=0
      # int is_entitypage01=0, is_entitypage02=0, is_entitypage03=0, is_entitypage04=0

  - id: !extend watchdog
    then:
      - if:
          condition:
            - not:
                - api.connected:
            - not:
                - text_sensor.state:
                    id: current_page
                    state: blank
            - not:
                - text_sensor.state:
                    id: current_page
                    state: boot
            - not:
                - text_sensor.state:
                    id: current_page
                    state: confirm
            - not:
                - text_sensor.state:
                    id: current_page
                    state: home
            - not:
                - text_sensor.state:
                    id: current_page
                    state: qrcode
            - not:
                - text_sensor.state:
                    id: current_page
                    state: screensaver
            - not:
                - text_sensor.state:
                    id: current_page
                    state: settings
          then:
            - lambda: |-
                  ESP_LOGW("${TAG_DATETIME}", "API disconnected. Falling back to Home page.");
            - script.execute:
                id: goto_page
                page: home
            - sensor.template.publish:
                id: blueprint_status
                state: 0

wifi:
  on_connect:
    then:
      - script.execute: api_recover_from_failed
...

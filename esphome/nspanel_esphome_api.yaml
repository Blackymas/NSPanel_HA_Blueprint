#####################################################################################################
##### NSPANEL ESPHOME created by Blackymas - https://github.com/Blackymas/NSPanel_HA_Blueprint  #####
##### ESPHOME CORE - API                                                                        #####
##### PLEASE only make changes if it is necessary and also the required knowledge is available. #####
##### For normal use with the Blueprint, no changes are necessary.                              #####
#####################################################################################################
---
substitutions:
  ##############################
  ## Change only in your      ##
  ## local yaml substitutions ##
  ##############################
  BOOT_STEP_API: 30
  TAG_API: nspanel.api
  EVENT_NAME: esphome.nspanel_ha_blueprint

api:
  id: api_server
  homeassistant_services: true
  reboot_timeout: 60min

  on_client_connected:
    then:
      - lambda: |-
          set_system_flag(NSPanelFlag::API_READY);
          boot_log->execute("API", "Client connected");
          refresh_wifi_icon->execute();
          dump_config->execute();

  on_client_disconnected:
    then:
      - if:
          condition:
            not:
              api.connected:
          then:
            - lambda: clear_system_flag(NSPanelFlag::API_READY);
      - script.execute: refresh_wifi_icon

  actions:
    # Sends custom commands directly to the display for dynamic interactions and updates.
    - action: command
      variables:
        cmd: string  # Command string to be sent. Refer to the Nextion Instruction Set for supported commands: https://nextion.tech/instruction-set/
      then:
        - lambda: |-
            ESP_LOGV("${TAG_API}", "Action: command");
            ESP_LOGV("${TAG_API}", "  cmd: %s", cmd.c_str());
            disp1->send_command(cmd.c_str());

    # Changes the foreground color of a specified component on the display.
    - action: component_color
      variables:
        page: string  # Send `mem` for a memory var
        id: string    # Identifier of the component to change color. Ensure this matches the component's ID in your display layout.
        color: int[]  # New color for the component, specified as an RGB array (e.g., [255, 0, 0] for red).
      then:
        - lambda: |-
            action_component_color->execute(
              page.c_str(),
              id.c_str(),
              rgbTo565(color)
            );

    # Updates the text of a specified component on the display.
    - action: component_text
      variables:
        page: string  # Send `mem` for a memory var
        id: string    # Identifier of the component. Ensure it matches the component's ID in your display layout.
        txt: string   # New text content to be displayed. Supports both static and dynamic content.
      then:
        - lambda: |-
            action_component_text->execute(
              page.c_str(),
              id.c_str(),
              txt.c_str()
            );

    # Updates the value of a specified component on the display.
    - action: component_val
      variables:
        page: string  # Send `mem` for a memory var
        id: string    # Identifier of the component to update. Must match the component's ID in the display layout.
        val: int      # New integer value to set for the component. Adjust based on the data type you're displaying.
      then:
        - lambda: |-
            action_component_val->execute(
              page.c_str(),
              id.c_str(),
              val
            );

    # Hides or shows a specified component on the display.
    # Supports both simple component IDs and page-specific IDs (page.component format).
    - action: components_visibility
      variables:
        page: string  # Send `mem` for a memory var
        ids: string[]  # Identifier of the component to be hidden/shown. Can be 'component' or 'page.component' format.
        visible: bool  # Set to true to show the component, or false to hide it.
      then:
        - lambda: |-
            ESP_LOGV("${TAG_API}", "Action: components_visibility");
            ESP_LOGV("${TAG_API}", "  page: %s", page.c_str());

            for (const std::string& component_id : ids) {
              if (component_id.empty()) {
                ESP_LOGW("${TAG_API}", "Skipping empty component ID");
                continue;
              }

              ESP_LOGV("${TAG_API}", "Processing component ID: %s", component_id.c_str());
              // Apply visibility if global component or on correct page
              ComponentVisibility* component_visibility = get_component_visibility(page.empty() ? current_page_id
                                                                                                : get_page_id(page),
                                                                                  component_id.c_str());

              if (not component_visibility) {
                ESP_LOGE("${TAG_API}", "Component '%s.%s' not found", page.c_str(), component_id.c_str());
                return;
              }

              if (component_visibility->visible != visible) {
                component_visibility->visible = visible;
                if (page.empty() or current_page->state == page) {
                  ESP_LOGV("${TAG_API}", "  Applying visibility changes");
                  if (visible) {
                    disp1->show_component(component_id.c_str());
                  } else {
                    disp1->hide_component(component_id.c_str());
                  }
                } else {
                  ESP_LOGV("${TAG_API}",
                            "  Current page (%s) doesn't match specified page (%s), skipping visibility update",
                            current_page->state.c_str(), page.c_str());
                }
              } // #endif visibility check

            } // #endfor component_id iteration

            ESP_LOGV("${TAG_API}", "Processed %zu component IDs with visibility: %s",
                    ids.size(), YESNO(visible));

    # Displays detailed information for a specific entity.
    - action: entity_details_show
      variables:
        entity: string     # The ID of the entity for which details are shown. Supports "embedded_climate" for built-in climate control.
        back_page: string  # Specifies the page to return to. Accepts "home" or "buttonpage01" to "buttonpage04".
      then:
        - lambda: |-
            ESP_LOGV("${TAG_API}", "Action: entity_details_show");
            ESP_LOGV("${TAG_API}", "  entity: %s", entity.c_str());
            ESP_LOGV("${TAG_API}", "  back_page: %s", back_page.c_str());
            HomeAssistantEntity entity_id = extractHomeAssistantEntity(entity);
            if (entity == "embedded_climate") entity_id.domain = "climate";
            else if (entity_id.domain == "alarm_control_panel") entity_id.domain = "alarm";
            if (entity_id.domain != "invalid" or entity == "embedded_climate") {
              detailed_entity->publish_state(entity);
              delay(${DELAY_DEFAULT});
              goto_page->execute(get_page_id(entity_id.domain.c_str()));
              delay(${DELAY_DEFAULT});
              disp1->send_command_printf("back_page_id=%" PRIu8, get_page_id(back_page.c_str()));
              if (entity_id.domain == "climate")
                delay(${DELAY_DEFAULT});
                disp1->set_component_value("climate.embedded", (entity == "embedded_climate") ? 1 : 0);
            }

    - action: icon  # Updates icon, color, and visibility for display components
      variables:
        page: string       # Page name for visibility control. If empty, visibility is applied immediately.
        id: string         # Identifier of the component.
        icon: string       # Icon codepoint, e.g., "/uE6E8" for `mdi:lightbulb-on-outline`.
        icon_color: int[]  # RGB color array for the icon, e.g., [0, 255, 0] for green.
        visible: bool      # Set to `true` for visible or `false` for hidden.
      then:
        - lambda: |-
            ESP_LOGV("${TAG_API}", "Action: icon");

            if (id.empty()) {
              ESP_LOGW("${TAG_API}", "Empty component ID provided");
              return;
            }

            ESP_LOGV("${TAG_API}", "Processing component ID: %s", id.c_str());
            ESP_LOGV("${TAG_API}", "  page: %s", page.empty() ? "none (global)" : page.c_str());
            ESP_LOGV("${TAG_API}", "  icon: %s", icon.c_str());
            ESP_LOGV("${TAG_API}", "  icon_color: %" PRIu16, rgbTo565(icon_color));
            ESP_LOGV("${TAG_API}", "  visible: %s", YESNO(visible));

            // Always set icon and color using the full ID as-is
            disp1->set_component_text(id.c_str(), icon.c_str());

            // Set icon color if provided
            if (icon_color.size() == 3) {
              disp1->set_component_font_color(id.c_str(), rgbTo565(icon_color));
            }

            // Handle visibility - apply if global component or on correct page
            ComponentVisibility* component_visibility = get_component_visibility(page.empty() ? current_page_id
                                                                                              : get_page_id(page),
                                                                                id.c_str());

            if (not component_visibility) {
              ESP_LOGE("${TAG_API}", "Component '%s.%s' not found", page.c_str(), id.c_str());
              return;
            }

            if (component_visibility->visible != visible) {
              component_visibility->visible = visible;
              if (page.empty() or current_page->state == page) {
                ESP_LOGV("${TAG_API}", "  Applying visibility changes");
                if (visible) {
                  disp1->show_component(id.c_str());
                } else {
                  disp1->hide_component(id.c_str());
                }
              } else {
                ESP_LOGV("${TAG_API}",
                          "  Current page (%s) doesn't match specified page (%s), skipping visibility update",
                          current_page->state.c_str(), page.c_str());
              }
            } // #endif visibility check

    # Transfers global settings from the blueprint to ESPHome, configuring the necessary parameters for optimal operation.
    - action: init_global
      variables:
        screensaver_time: bool         # Toggles the screensaver time display.
        screensaver_time_font: int     # Specifies the font id for the screensaver time display.
        screensaver_time_color: int[]  # RGB color for the screensaver time display, e.g., [165, 42, 42] for reddish-brown.
        decimal_separator: string      # The char to be used as decimal separator.
      then:
        - lambda: boot_log->execute("Service", "init_global");
        - script.execute:
            id: global_settings
            screensaver_time: !lambda return screensaver_time;
            screensaver_time_font: !lambda return screensaver_time_font;
            screensaver_time_color: !lambda return screensaver_time_color;
            decimal_separator: !lambda return decimal_separator;
        - script.wait: global_settings

    # Configures NSPanel hardware (buttons, relays, etc.) settings
    - action: init_hardware
      variables:
        relay1_local_control: bool              # Enable/disable local control for Relay 1.
        relay1_icon: string                     # Icon for Relay 1 (e.g., "\uE3A5" for mdi:numeric-1-box-outline).
        relay1_icon_color: int[]                # RGB color array for Relay 1's icon.
        relay1_fallback: bool                   # Fallback state for Relay 1 in case of communication loss.
        relay2_local_control: bool              # Enable/disable local control for Relay 2.
        relay2_icon: string                     # Icon for Relay 2 (e.g., "\uE3A8" for mdi:numeric-2-box-outline).
        relay2_icon_color: int[]                # RGB color array for Relay 2's icon.
        relay2_fallback: bool                   # Fallback state for Relay 2 in case of communication loss.
        button_left: bool                       # Enable/disable left button status visualization.
        button_right: bool                      # Enable/disable right button status visualization.
        button_bar_pages: int                   # As uint representing the list of pages where the buttons bars will be visible
        button_bar_color_on: int[]              # RGB color array for the hardware button bar when the status is `On`.
        button_bar_color_off: int[]             # RGB color array for the hardware button bar when the status is `Off`.
        embedded_climate: bool                  # Indicates if climate control is integrated.
        embedded_climate_friendly_name: string  # Friendly name for the climate control feature.
        embedded_indoor_temperature: bool       # Enables indoor temperature display.
      then:
        - lambda: boot_log->execute("Service", "init_hardware");
        - delay: ${DELAY_DEFAULT}ms
        - script.execute:
            id: init_hardware_climate
            embedded_climate: !lambda return embedded_climate;
            embedded_climate_friendly_name: !lambda return embedded_climate_friendly_name;
            embedded_indoor_temperature: !lambda return embedded_indoor_temperature;

        # Relay settings
        - delay: ${DELAY_DEFAULT}ms
        - lambda: |-
            using namespace esphome::display;
            update_bitwise_setting(id(relay_settings), relay1_local_control, RelaySettings::Relay1_Local);
            update_bitwise_setting(id(relay_settings), relay1_fallback, RelaySettings::Relay1_Fallback);
            update_bitwise_setting(id(relay_settings), relay2_local_control, RelaySettings::Relay2_Local);
            update_bitwise_setting(id(relay_settings), relay2_fallback, RelaySettings::Relay2_Fallback);

        # Relay icons
        - delay: ${DELAY_DEFAULT}ms
        - lambda: |-
            using namespace esphome::display;
            if (not relay1_icon.empty()) id(home_relay1_icon) = relay1_icon;
            if (not relay2_icon.empty()) id(home_relay2_icon) = relay2_icon;

            // Relay icon's colors
            if (relay1_icon_color.size() == 3) {
              id(home_relay1_icon_color) = rgbTo565(relay1_icon_color);
              disp1->set_component_font_color("home.chip_relay1", id(home_relay1_icon_color));
            }
            if (relay2_icon_color.size() == 3) {
              id(home_relay2_icon_color) = rgbTo565(relay2_icon_color);
              disp1->set_component_font_color("home.chip_relay2", id(home_relay2_icon_color));
            }

        # Buttons bars settings
        - delay: ${DELAY_DEFAULT}ms
        - globals.set:
            id: buttons_bars_pages
            value: !lambda return button_bar_pages;
        - lambda: |-
            using namespace esphome::display;
            update_bitwise_setting(buttons_settings, button_left, ButtonSettings::ButtonLeft_Enabled);
            update_bitwise_setting(buttons_settings, button_right, ButtonSettings::ButtonRight_Enabled);
        - if:
            condition:
              - lambda: return (button_bar_color_on.size() == 3);
            then:
              - globals.set:
                  id: buttons_color_on
                  value: !lambda return rgbTo565(button_bar_color_on);
        - if:
            condition:
              - lambda: return (button_bar_color_off.size() == 3);
            then:
              - globals.set:
                  id: buttons_color_off
                  value: !lambda return rgbTo565(button_bar_color_off);

        # Update relays icons
        - delay: ${DELAY_DEFAULT}ms
        - script.execute:
            id: refresh_relays
            relay_mask: 3
        # Update buttons bars
        - delay: ${DELAY_DEFAULT}ms
        - script.execute:
            id: refresh_hardware_buttons_bars
            button_mask: 3

        # Update blueprint status
        - lambda: set_blueprint_status_flag(BlueprintStatusFlag::RELAY_SETTINGS);

    # Dynamically displays QR codes on the ESPHome UI for sharing information such as WiFi passwords or website links.
    - action: qrcode
      variables:
        title: string   # Heading or title for the QR code, offering context or instructions.
        qrcode: string  # Data or URL to be encoded into the QR code.
        show: bool      # Flag to immediately display the QR code page upon service invocation.
      then:
        - if:
            condition:
              - lambda: return (current_page_id == ${PAGE_HOME_ID});
            then:
              - lambda: |-
                  disp1->send_command_printf("vis bt_qrcode,%i", qrcode.empty() ? 0 : 1);
        - lambda: |-
            disp1->set_component_text("qrcode.qrcode_label", title.c_str());
            disp1->set_component_text("qrcode.qrcode_value", qrcode.c_str());
        - if:
            condition:
              - lambda: return show;
            then:
              - script.execute:
                  id: goto_page
                  page_id: ${PAGE_QRCODE_ID}

        # Update blueprint status
        - lambda: set_blueprint_status_flag(BlueprintStatusFlag::QRCODE);

    # Utilities group refresh
    - action: utilities_group_refresh
      variables:
        group_id: string
        value1: string
        value2: string
        direction: int
        constructor: bool
      then:
        - if:
            condition:
              - lambda: return group_id.empty();
            then:
              - lambda: ESP_LOGW("${TAG_API}", "`group_id` is empty");
            else:
              - lambda: |-
                  uint8_t id = findUtilitiesGroupIndex(group_id.c_str());
                  if (id != UINT8_MAX) {
                    // Update Value 1
                    if (!value1.empty() and
                        (constructor or strcmp(value1.c_str(), UtilitiesGroups[id].value1) != 0)) {
                      copyStringToCharArray(UtilitiesGroups[id].value1, value1);
                      disp1->set_component_text(group_id.c_str(), value1.c_str());
                      delay(${DELAY_DEFAULT});
                    }

                    // Update Value 2
                    if (!value2.empty() and
                        (constructor or strcmp(value2.c_str(), UtilitiesGroups[id].value2) != 0)) {
                      copyStringToCharArray(UtilitiesGroups[id].value2, value2);
                      disp1->set_component_text((group_id + "b").c_str(), value2.c_str());
                      delay(${DELAY_DEFAULT});
                    }

                    // Update direction
                    if (group_id != "grid" and !isnan(direction) and
                        (constructor or direction != UtilitiesGroups[id].direction)) {
                      UtilitiesGroups[id].direction = direction;
                      disp1->set_component_value((group_id + "_line_d").c_str(), direction);
                      delay(${DELAY_DEFAULT});
                    }
                  }

    # Updates an entity to display specific values with dynamic icons, names, and color codes.
    - action: value
      variables:
        id: string          # Identifier of the entity. See "Screen components" for entity IDs.
        icon: string        # Icon codepoint (e.g., "/uE6E8" for mdi:thermometer) from HASwitchPlate Material Design Icons.
        icon_color: int[]   # RGB color array for the icon (e.g., [255, 0, 0] for red).
        name: string        # Display name for the entity (e.g., "Temperature").
        value: string       # Actual value to display (e.g., "75°F").
        value_color: int[]  # RGB color array for the value text (e.g., [255, 255, 0] for yellow).
      then:
        - lambda: |-
            ESP_LOGV("${TAG_API}", "Action: value");
            ESP_LOGV("${TAG_API}", "  id: %s", id.c_str());
            ESP_LOGV("${TAG_API}", "  icon: %s", icon.c_str());
            ESP_LOGV("${TAG_API}", "  icon_color: %" PRIu16, rgbTo565(value_color));
            ESP_LOGV("${TAG_API}", "  name: %s", name.c_str());
            ESP_LOGV("${TAG_API}", "  value: %s", value.c_str());
            ESP_LOGV("${TAG_API}", "  value_color: %" PRIu16, rgbTo565(value_color));

            // Stop if Id is empty
            if (id.empty()) {
              ESP_LOGW("${TAG_API}", "`id` is empty");
              return;
            }

            // Icon
            if (not icon.empty()) {
              disp1->set_component_text((id + "_icon").c_str(), icon.c_str());
            }

            // Icon color
            if (icon_color.size() == 3) {
              disp1->set_component_font_color((id + "_icon").c_str(), rgbTo565(icon_color));
            }

            // Label
            if (not name.empty()) {
              disp1->set_component_text((id + "_label").c_str(), name.c_str());
            }

            // Value
            if (not value.empty()) {
              disp1->set_component_text(
                        id.c_str(),
                        adjustDecimalSeparator(
                                                value,
                                                id(mui_decimal_separator).empty() ? '.' : id(mui_decimal_separator)[0]
                                              ).c_str()
              );
            }

            // Value color
            if (value_color.size() == 3)
              disp1->set_component_font_color(id.c_str(), rgbTo565(value_color));

            // Value font
            if ((not value.empty()) and (current_page->state.find("entitypage") == 0)) {
              // Adjusted length starts at 0
              float adjusted_length = 0.0;

              // Iterate over each character in the string
              for (char const &c: value) {
                // Check if character is a space or other specified exceptions
                if (display_charset == 2 or std::string(" iljtIf'-,;:!.\"|()[]{}").find(c) != std::string::npos) {
                  adjusted_length += 0.5; // Count these as half
                } else {
                  adjusted_length += 1.0; // Count all other characters as 1
                }
              }

              // Decide which font to use based on adjusted length
              if (adjusted_length > 8.0 and adjusted_length <= 12.0) {
                disp1->set_component_font(id.c_str(), 1);
              } else if (adjusted_length > 12.0) {
              disp1->set_component_font(id.c_str(), 0);
              }
            }

    # Wake Up Service
    - action: wake_up
      variables:
        reset_timer: bool  # Determines whether to reset the sleep and dimming timers upon waking the display.
      then:
        - lambda: |-
            if (current_page_id == ${PAGE_SCREENSAVER_ID})
              goto_page->execute(wakeup_page_id);
            if (reset_timer) {
              timer_reset_all->execute();
            } else {
              timer_sleep->execute();
              timer_dim->execute();
            }

esphome:
  platformio_options:
    build_flags:
      - -D NSPANEL_HA_BLUEPRINT_API

script:
  - id: action_component_color
    mode: single
    parameters:
      page: string       # Send `mem` for a memory var
      component: string  # Identifier of the component to change color. Ensure this matches the component's ID in your display layout.
      color: uint16_t    # New color for the component, rgb565.
    then:
      - lambda: |-
          ESP_LOGV("${TAG_API}", "Script: action_component_color");
          ESP_LOGV("${TAG_API}", "  page: %s", page.c_str());
          ESP_LOGV("${TAG_API}", "  component: %s", component.c_str());
          ESP_LOGV("${TAG_API}", "  color: %" PRIu16, color);
          if (page.empty()) {
            disp1->set_component_font_color(component.c_str(), color);
            return;
          }
          if (page != "mem") {
            disp1->send_command_printf("%s.%s.pco=%" PRIu16, page.c_str(), component.c_str(), color);
            return;
          }

  - id: action_component_text
    mode: single
    parameters:
      page: string       # Send `mem` for a memory var
      component: string  # Identifier of the component. Ensure it matches the component's ID in your display layout.
      txt: string        # New text content to be displayed. Supports both static and dynamic content.
    then:
      - lambda: |-
          ESP_LOGV("${TAG_API}", "Script: action_component_text");
          ESP_LOGV("${TAG_API}", "  page: %s", page.c_str());
          ESP_LOGV("${TAG_API}", "  component: %s", component.c_str());
          ESP_LOGV("${TAG_API}", "  txt: %s", txt.c_str());
          if (page.empty()) {
            disp1->set_component_text(component.c_str(), txt.c_str());
            return;
          }
          if (page != "mem") {
            disp1->send_command_printf("%s.%s.txt=\"%s\"", page.c_str(), component.c_str(), txt.c_str());
            return;
          }

  - id: action_component_val
    mode: single
    parameters:
      page: string       # Send `mem` for a memory var
      component: string  # Identifier of the component to update. Must match the component's ID in the display layout.
      val: int32_t       # New integer value to set for the component. Adjust based on the data type you're displaying.
    then:
      # Extended by:
      # - hw_buttons
      # - page_home
      - lambda: |-
          ESP_LOGV("${TAG_API}", "Script: action_component_val");
          ESP_LOGV("${TAG_API}", "  page: %s", page.c_str());
          ESP_LOGV("${TAG_API}", "  component: %s", component.c_str());
          ESP_LOGV("${TAG_API}", "  val: %i", val);
          if (page.empty()) {
            disp1->set_component_value(component.c_str(), val);
            return;
          }
          if (page != "mem") {
            disp1->send_command_printf("%s.%s.val=%" PRId32, page.c_str(), component.c_str(), val);
            return;
          }

  - id: api_recover_from_failed
    mode: single
    then:
      - while:
          condition:
            - lambda: return api_server->is_failed();
          then:
            - lambda: |-
                ESP_LOGW("${TAG_API}", "API reported a failed state. Recovering...");
                api_server->setup();
            - delay: 5s

  - id: !extend dump_config
    then:
      # Report API status
      - if:
          condition:
            - api.connected:
          then:
            - lambda: |-
                ESP_LOGCONFIG("${TAG_API}", "API: Connected");
          else:
            - lambda: |-
                ESP_LOGW("${TAG_API}", "API: DISCONNECTED");

  - id: ha_button
    mode: parallel
    parameters:
      page: string
      component: string
      command: string
    then:
      - script.execute: timer_reset_all
      - homeassistant.event:
          event: ${EVENT_NAME}
          data:
            device_name: !lambda return device_name->state.c_str();
            esphome_version: ${version}
            type: button_click
            page: !lambda return page;
            component: !lambda return component;
            command: !lambda return command;

  - id: !extend stop_all
    then:
      - script.stop: api_recover_from_failed
      - script.stop: ha_button

  - id: !extend watchdog_round
    then:
      - if:
          condition:
            - lambda: return (current_page_id != ${PAGE_BOOT_ID});
            - lambda: return (current_page_id != ${PAGE_CONFIRM_ID});
            - lambda: return (current_page_id != ${PAGE_HOME_ID});
            - lambda: return (current_page_id != ${PAGE_QRCODE_ID});
            - lambda: return (current_page_id != ${PAGE_SCREENSAVER_ID});
            - lambda: return (current_page_id != ${PAGE_SETTINGS_ID});
            - not:
                - api.connected:
            - not:
                - text_sensor.state:
                    id: current_page
                    state: blank
          then:
            - lambda: |-
                  ESP_LOGW("${TAG_DATETIME}", "API disconnected. Falling back to Home page.");
            - script.execute:
                id: goto_page
                page_id: ${PAGE_HOME_ID}

wifi:
  on_connect:
    then:
      - script.execute: api_recover_from_failed
...

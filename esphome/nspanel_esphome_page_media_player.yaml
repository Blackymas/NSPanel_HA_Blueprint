#####################################################################################################
##### NSPANEL ESPHOME created by Blackymas - https://github.com/Blackymas/NSPanel_HA_Blueprint  #####
##### ESPHOME - Page media_player                                                               #####
##### PLEASE only make changes if it is necessary and also the required knowledge is available. #####
##### For normal use with the Blueprint, no changes are necessary.                              #####
#####################################################################################################

---
substitutions:
  BOOT_STEP_PAGE_MEDIA_PLAYER: 20
  PAGE_MEDIA_PLAYER_DELAY_DEFAULT: ${DELAY_DEFAULT}
  PAGE_MEDIA_PLAYER_DELAY_LONG: ${DELAY_LONG}
  PAGE_MEDIA_PLAYER_DELAY_SHORT: ${DELAY_SHORT}
  PAGE_MEDIA_PLAYER_ID: 25
  PAGE_MEDIA_PLAYER_NAME: media_player
  COMPONENT_ID_MEDIA_PLAYER_BT_VOL_DOWN: 6
  COMPONENT_ID_MEDIA_PLAYER_BT_VOL_UP: 7
  MEDIA_PLAYER_FEATURE_PAUSE: 1
  MEDIA_PLAYER_FEATURE_SEEK: 2
  MEDIA_PLAYER_FEATURE_VOLUME_SET: 4
  MEDIA_PLAYER_FEATURE_VOLUME_MUTE: 8
  MEDIA_PLAYER_FEATURE_PREVIOUS_TRACK: 16
  MEDIA_PLAYER_FEATURE_NEXT_TRACK: 32
  MEDIA_PLAYER_FEATURE_TURN_ON: 128
  MEDIA_PLAYER_FEATURE_TURN_OFF: 256
  MEDIA_PLAYER_FEATURE_PLAY_MEDIA: 512
  MEDIA_PLAYER_FEATURE_VOLUME_STEP: 1024
  MEDIA_PLAYER_FEATURE_SELECT_SOURCE: 2048
  MEDIA_PLAYER_FEATURE_STOP: 4096
  MEDIA_PLAYER_FEATURE_CLEAR_PLAYLIST: 8192
  MEDIA_PLAYER_FEATURE_PLAY: 16384
  MEDIA_PLAYER_FEATURE_SHUFFLE_SET: 32768
  MEDIA_PLAYER_FEATURE_SELECT_SOUND_MODE: 65536
  MEDIA_PLAYER_FEATURE_BROWSE_MEDIA: 131072
  MEDIA_PLAYER_FEATURE_REPEAT_SET: 262144
  MEDIA_PLAYER_FEATURE_GROUPING: 524288
  MEDIA_PLAYER_FEATURE_MEDIA_ANNOUNCE: 1048576
  MEDIA_PLAYER_FEATURE_MEDIA_ENQUEUE: 2097152
  MDI_ICON_PLAY: "\uE409"                # mdi:play
  MDI_ICON_PAUSE: "\uE3E3"               # mdi:pause
  MDI_ICON_VOLUME_VARIANT_OFF: "\uEE07"  # mdi:volume-variant-off
  MDI_ICON_VOLUME_LOW: "\uE57E"          # mdi:volume-low
  TAG_PAGE_MEDIA_PLAYER: nspanel.page.media_player

api:
  actions:
    # Dynamically updates the media player page with current state and media information.
    - action: page_media_player
      variables:
        entity: string             # Entity ID of the media player, used for state updates and control.
        state: string              # Current playback state of the media player (e.g., "playing", "paused", "stopped").
        is_volume_muted: bool      # Indicates if the media volume is currently muted.
        friendly_name: string      # Display name of the media player, shown as the page title.
        volume_level: int          # Current volume level, typically expressed as a percentage.
        media_title: string        # Title of the currently playing media.
        media_artist: string       # Artist of the currently playing media.
        media_duration: int        # Total duration of the current media in seconds.
        media_position: int        # Current playback position in the media in seconds.
        media_position_delta: int  # Time elapsed since the last media position update in seconds.
        supported_features: int    # Bitmask indicating the media player's supported features (e.g., play, pause, volume control).
      then:
        - lambda: |-
            ESP_LOGD("${TAG_PAGE_MEDIA_PLAYER}", "Action: page_media_player");
            ESP_LOGV("${TAG_PAGE_MEDIA_PLAYER}", "  entity: %s", entity.c_str());
            ESP_LOGV("${TAG_PAGE_MEDIA_PLAYER}", "  state: %s", state.c_str());
            ESP_LOGV("${TAG_PAGE_MEDIA_PLAYER}", "  is_volume_muted: %s", YESNO(is_volume_muted));
            ESP_LOGV("${TAG_PAGE_MEDIA_PLAYER}", "  friendly_name: %s", friendly_name.c_str());
            ESP_LOGV("${TAG_PAGE_MEDIA_PLAYER}", "  volume_level: %i", volume_level);
            ESP_LOGV("${TAG_PAGE_MEDIA_PLAYER}", "  media_title: %s", media_title.c_str());
            ESP_LOGV("${TAG_PAGE_MEDIA_PLAYER}", "  media_artist: %s", media_artist.c_str());
            ESP_LOGV("${TAG_PAGE_MEDIA_PLAYER}", "  media_duration: %i", media_duration);
            ESP_LOGV("${TAG_PAGE_MEDIA_PLAYER}", "  media_position: %i", media_position);
            ESP_LOGV("${TAG_PAGE_MEDIA_PLAYER}", "  media_position_delta: %i", media_position_delta);
            ESP_LOGV("${TAG_PAGE_MEDIA_PLAYER}", "  supported_features: %i", supported_features);
        - if:
            condition:
              - lambda: return current_page_id == ${PAGE_MEDIA_PLAYER_ID};
            then:  # Update media_player page
              # Set detailed entity sensor
              - lambda: |-
                  ESP_LOGV("${TAG_PAGE_MEDIA_PLAYER}", "Set detailed entity sensor");
              - text_sensor.template.publish:
                  id: detailed_entity
                  state: !lambda return entity;
              - delay: ${PAGE_MEDIA_PLAYER_DELAY_SHORT}ms

              # Page header
              - lambda: |-
                  ESP_LOGV("${TAG_PAGE_MEDIA_PLAYER}", "Page header");
                  disp1->set_component_text("page_label", friendly_name.c_str());
              - delay: ${PAGE_MEDIA_PLAYER_DELAY_SHORT}ms

              # Media title
              - lambda: |-
                  ESP_LOGV("${TAG_PAGE_MEDIA_PLAYER}", "Media title");
                  disp1->set_component_text("track",
                                            wrapText(media_title.c_str(),
                                                      display_mode == 2 ? 16 : 27,
                                                      id(mui_bytes_per_char)).c_str());
              - delay: ${PAGE_MEDIA_PLAYER_DELAY_SHORT}ms

              # Media artist
              - lambda: |-
                  ESP_LOGV("${TAG_PAGE_MEDIA_PLAYER}", "Media artist");
                  disp1->set_component_text("artist",
                                            wrapText(media_artist.c_str(),
                                                      display_mode == 2 ? 26 : 40,
                                                      id(mui_bytes_per_char)).c_str());
              - delay: ${PAGE_MEDIA_PLAYER_DELAY_SHORT}ms

              # Button - ON/OFF
              - lambda: |-
                  ESP_LOGV("${TAG_PAGE_MEDIA_PLAYER}", "Button - ON/OFF");
                  if (supported_features & 128 and state == "off") {  //TURN_ON
                    disp1->set_component_foreground_color("bt_on_off", ${COLOR_WHITE});
                    disp1->show_component("bt_on_off");
                  } else if (supported_features & 256 and state != "off") {  //TURN_OFF
                    disp1->set_component_foreground_color("bt_on_off", ${COLOR_BLUE_INDIGO});
                    disp1->show_component("bt_on_off");
                  } else
                    disp1->hide_component("bt_on_off");
              - delay: ${PAGE_MEDIA_PLAYER_DELAY_SHORT}ms

              # Button - Play/Pause
              - lambda: |-
                  ESP_LOGV("${TAG_PAGE_MEDIA_PLAYER}", "Button - Play/Pause");
                  if ((supported_features & 512 or supported_features & 16384) and state != "playing" and state != "off") {  //PLAY_MEDIA+PLAY
                    disp1->set_component_text("bt_play_pause", "\uE409"); // mdi:play
                    disp1->show_component("bt_play_pause");
                  } else if (supported_features & 1 and state == "playing" ) {  //PAUSE
                    disp1->set_component_text("bt_play_pause", "\uE3E3"); // mdi:pause
                    disp1->show_component("bt_play_pause");
                  } else
                    disp1->hide_component("bt_play_pause");
              - delay: ${PAGE_MEDIA_PLAYER_DELAY_SHORT}ms

              # Button - Previous track
              - lambda: |-
                  ESP_LOGV("${TAG_PAGE_MEDIA_PLAYER}", "Button - Previous track");
                  disp1->send_command_printf("vis bt_prev,%i", (supported_features & 16 and state != "off") ? 1 : 0);
              - delay: ${PAGE_MEDIA_PLAYER_DELAY_SHORT}ms

              # Button - Next track
              - lambda: |-
                  ESP_LOGV("${TAG_PAGE_MEDIA_PLAYER}", "Button - Next track");
                  disp1->send_command_printf("vis bt_next,%i", (supported_features & 32 and state != "off") ? 1 : 0);
              - delay: ${PAGE_MEDIA_PLAYER_DELAY_SHORT}ms

              # Button - Mute/Unmute
              - lambda: |-
                  ESP_LOGV("${TAG_PAGE_MEDIA_PLAYER}", "Button - Mute/Unmute");
                  disp1->set_component_value("is_muted", is_volume_muted ? 1 : 0);
                  if (supported_features & 8 and is_volume_muted) {  // unmute
                    disp1->set_component_text("bt_mute", "\uEE07"); // mdi:volume-variant-off
                    disp1->show_component("bt_mute");
                  } else if (supported_features & 8) {  // mute
                    disp1->set_component_text("bt_mute", "\uE57E"); // mdi:volume-low
                    disp1->show_component("bt_mute");
                  } else
                    disp1->hide_component("bt_mute");
              - delay: ${PAGE_MEDIA_PLAYER_DELAY_SHORT}ms

              # Volume set
              - lambda: |-
                  ESP_LOGV("${TAG_PAGE_MEDIA_PLAYER}", "Volume set");
                  if (supported_features & 4) {
                    if (last_volume_level != volume_level) {
                      last_volume_level = volume_level;
                      disp1->set_component_text_printf("vol_text", "%" PRIu32 "%%", volume_level);
                      disp1->set_component_value("vol_slider", volume_level);
                    }
                    disp1->show_component("vol_slider");
                    disp1->show_component("bt_vol_down");
                    disp1->show_component("bt_vol_up");
                    disp1->show_component("vol_text");
                  } else {
                    disp1->hide_component("vol_slider");
                    disp1->hide_component("bt_vol_down");
                    disp1->hide_component("bt_vol_up");
                    disp1->hide_component("vol_text");
                  }
              - delay: ${PAGE_MEDIA_PLAYER_DELAY_SHORT}ms

              # Media progress bar
              - lambda: |-
                  ESP_LOGV("${TAG_PAGE_MEDIA_PLAYER}", "Media progress bar");
                  if (media_duration > 0) {
                    if (media_duration != last_media_duration or media_position != last_media_position) {
                      last_media_duration = media_duration;
                      last_media_position = media_position;
                      disp1->set_component_value("prg_current",
                                                  int(round(min(media_position + media_position_delta,
                                                                media_duration))));
                    }
                    disp1->set_component_value("prg_total", int(round(media_duration)));
                    disp1->send_command_printf("prg_timer.en=%i", (state == "playing") ? 1 : 0);
                    disp1->show_component("time_current");
                    disp1->show_component("time_total");
                    disp1->show_component("time_progress");
                  } else {
                    disp1->send_command("prg_timer.en=0");
                    disp1->hide_component("time_current");
                    disp1->hide_component("time_total");
                    disp1->hide_component("time_progress");
                  }

        - lambda: |-
            ESP_LOGV("${TAG_PAGE_MEDIA_PLAYER}", "Action: page_media_player completed");

esphome:
  platformio_options:
    build_flags:
      - -D NSPANEL_HA_BLUEPRINT_PAGE_MEDIA_PLAYER

script:
  - id: !extend event_from_display
    then:
      - lambda: |-
          if (page == "${PAGE_MEDIA_PLAYER_NAME}") {
            if (json["key"].isNull()) {
              ESP_LOGV("${TAG_PAGE_MEDIA_PLAYER}", "Missing media_player key field");
              return;
            } // endif missing key

            const std::string key = json["key"].as<std::string>();
            ESP_LOGV("${TAG_PAGE_MEDIA_PLAYER}", "Media player control: key=%s", key.c_str());

            if (key == "volume_mute") {
              if (json["value"].isNull()) {
                ESP_LOGV("${TAG_PAGE_MEDIA_PLAYER}", "Missing volume_mute value");
                return;
              } // endif missing value
              const std::string value = json["value"].as<std::string>();
              ESP_LOGV("${TAG_PAGE_MEDIA_PLAYER}", "Setting volume mute: %s", value.c_str());
              esphome::api::CustomAPIDevice ha_event;
              ha_event.fire_homeassistant_event("${EVENT_NAME}", {
                {"device_name", device_name->state.c_str()},
                {"esphome_version", "${version}"},
                {"type", "action_call"},
                {"action", "media_player.volume_mute"},
                {"key", "is_volume_muted"},
                {"value", value.c_str()},
                {"entity", detailed_entity->state.c_str()}
              });
            } else if (key == "volume_set") {
              if (json["value"].isNull()) {
                ESP_LOGV("${TAG_PAGE_MEDIA_PLAYER}", "Missing volume_set value");
                return;
              } // endif missing value
              const float value_float = json["value"].as<float>();
              ESP_LOGV("${TAG_PAGE_MEDIA_PLAYER}", "Setting volume level: %.2f", value_float / 100.0f);
              esphome::api::CustomAPIDevice ha_event;
              ha_event.fire_homeassistant_event("${EVENT_NAME}", {
                {"device_name", device_name->state.c_str()},
                {"esphome_version", "${version}"},
                {"type", "action_call"},
                {"action", "media_player.volume_set"},
                {"key", "volume_level"},
                {"value", to_string(value_float / 100.0f)},
                {"entity", detailed_entity->state.c_str()}
              });
            } else if (!key.empty()) {
              ESP_LOGV("${TAG_PAGE_MEDIA_PLAYER}", "Executing media player action: %s", key.c_str());
              esphome::api::CustomAPIDevice ha_event;
              ha_event.fire_homeassistant_event("${EVENT_NAME}", {
                {"device_name", device_name->state.c_str()},
                {"esphome_version", "${version}"},
                {"type", "action_call"},
                {"action", (std::string("media_player.") + key.c_str())},
                {"entity", detailed_entity->state.c_str()}
              });
            } else {
              ESP_LOGV("${TAG_PAGE_MEDIA_PLAYER}", "Empty media player key, ignoring");
            } // endif key handling
          } // endif page == media_player

  - id: !extend page_change
    then:
      - if:
          condition:
            - lambda: return new_page_id == ${PAGE_MEDIA_PLAYER_ID};
          then:
            - script.execute: page_media_player

  - id: page_media_player
    mode: restart
    then:  # There's nothing here so far

  - id: page_media_player_action
    mode: restart
    parameters:
      entity: string             # Entity ID of the media player, used for state updates and control.
      state: string              # Current playback state of the media player (e.g., "playing", "paused", "stopped").
      is_volume_muted: bool      # Indicates if the media volume is currently muted.
      friendly_name: string      # Display name of the media player, shown as the page title.
      volume_level: int          # Current volume level, typically expressed as a percentage.
      media_title: string        # Title of the currently playing media.
      media_artist: string       # Artist of the currently playing media.
      media_duration: int        # Total duration of the current media in seconds.
      media_position: int        # Current playback position in the media in seconds.
      media_position_delta: int  # Time elapsed since the last media position update in seconds.
      supported_features: int    # Bitmask indicating the media player's supported features (e.g., play, pause, volume control).
    then:

  - id: !extend stop_all
    then:
      - script.stop: page_media_player
      - script.stop: page_media_player_action

  - id: !extend stop_page_constructors
    then:
      - script.stop: page_media_player
...

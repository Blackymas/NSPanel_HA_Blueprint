#####################################################################################################
##### NSPANEL ESPHOME created by Blackymas - https://github.com/Blackymas/NSPanel_HA_Blueprint  #####
##### ESPHOME CORE                                                                              #####
##### PLEASE only make changes if it is necessary and also the required knowledge is available. #####
##### For normal use with the Blueprint, no changes are necessary.                              #####
#####################################################################################################
---
substitutions:
  ##############################
  ## Change only in your      ##
  ## local yaml substitutions ##
  temp_units: "°C"
  invalid_cooldown: "100ms"
  bytes_per_char: "1"
  ##############################

  ##### DON'T CHANGE THIS ######
  NSPANEL_HA_BLUEPRINT_CORE: "true"
  NSPANEL_HA_BLUEPRINT_ADVANCED: "false"
  NSPANEL_HA_BLUEPRINT_ADDON_BLE_TRACKER: "false"
  NSPANEL_HA_BLUEPRINT_ADDON_BLUETOOTH_PROXY: "false"
  NSPANEL_HA_BLUEPRINT_ADDON_UPLOAD_TFT: "false"
  NSPANEL_HA_BLUEPRINT_ADDON_CLIMATE_BASE: "false"
  NSPANEL_HA_BLUEPRINT_ADDON_CLIMATE_COOL: "false"
  NSPANEL_HA_BLUEPRINT_ADDON_CLIMATE_DUAL: "false"
  NSPANEL_HA_BLUEPRINT_ADDON_CLIMATE_HEAT: "false"
  NSPANEL_HA_BLUEPRINT_PREBUILT: "false"
  NSPANEL_HA_BLUEPRINT_PREBUILT_WALL_DISPLAY: "false"
  ##############################
  TAG_CORE: "nspanel.core"
  BAUD_RATE: '115200'
  GPIO_BUTTON_LEFT_PIN: '14'
  GPIO_BUTTON_LEFT_INVERTED: 'true'
  GPIO_BUTTON_RIGHT_PIN: '27'
  GPIO_BUTTON_RIGHT_INVERTED: 'true'
  GPIO_DISPLAY_POWER_PIN: '4'
  GPIO_DISPLAY_POWER_INVERTED: 'true'
  GPIO_DISPLAY_NEXTION_TX_PIN: '16'
  GPIO_DISPLAY_NEXTION_RX_PIN: '17'
  GPIO_BUZZER_OUTPUT_PIN: '21'
  GPIO_BUZZER_OUTPUT_INVERTED: 'false'
  GPIO_RELAY_1_PIN: '22'
  GPIO_RELAY_1_INVERTED: 'false'
  GPIO_RELAY_2_PIN: '19'
  GPIO_RELAY_2_INVERTED: 'false'
  GPIO_TEMPERATURE_ADC_PIN: '38'

  DELAY_DEFAULT: 50  # delay in msec
  DELAY_LONG: 250    # delay in msec
  DELAY_SHORT: 10    # delay in msec

packages:
  # yamllint disable rule:colons
  version:    !include nspanel_esphome_version.yaml
  api:        !include nspanel_esphome_core_api.yaml
  base:       !include nspanel_esphome_core_base.yaml
  boot:       !include nspanel_esphome_core_boot.yaml
  datetime:   !include nspanel_esphome_core_datetime.yaml
  hw_buttons: !include nspanel_esphome_core_hw_buttons.yaml
  hw_memory:  !include nspanel_esphome_core_hw_memory.yaml
  # yamllint enable rule:colons

##### ESPHOME CONFIGURATION #####
esphome:
  platformio_options:
    build_flags:
      - -D NSPANEL_HA_BLUEPRINT_CORE

  on_boot:
    - priority: 1000.0  # This is where most sensors are set up.
      then:
        - lambda: set_boot_flag(nspanel_ha_blueprint::boot_flags, BootFlag::WIFI);
        - sensor.template.publish:
            id: blueprint_status
            state: 0
        - delay: ${DELAY_DEFAULT}ms
        - text_sensor.template.publish:
            id: version_esphome
            state: "${version}"
        - delay: ${DELAY_DEFAULT}ms
        - text_sensor.template.publish:
            id: device_name
            state: "${name}"
        - delay: ${DELAY_DEFAULT}ms
        - text_sensor.template.publish:
            id: notification_label
            state: ""
        - delay: ${DELAY_DEFAULT}ms
        - text_sensor.template.publish:
            id: notification_text
            state: ""
        - delay: ${DELAY_DEFAULT}ms
        - switch.turn_off: notification_unread

esp32:
  board: esp32dev
  framework:
    type: esp-idf

##### WIFI SETUP #####
wifi:
  id: wifi_component
  networks:
    - id: wifi_default
      ssid: ${wifi_ssid}
      password: ${wifi_password}
  on_connect:
    then:
      - lambda: set_boot_flag(nspanel_ha_blueprint::boot_flags, BootFlag::WIFI);
      - script.execute: refresh_wifi_icon
  on_disconnect:
    then:
      - lambda: clear_boot_flag(nspanel_ha_blueprint::boot_flags, BootFlag::WIFI);
      - script.execute: refresh_wifi_icon

##### ENABLE RINGTONE MUSIC SUPPORT #####
rtttl:
  id: buzzer
  output: buzzer_out

##### CONFIGURE INTERNAL BUZZER #####
output:
  ##### BUZZER FOR PLAYING RINGTONES #####
  - id: buzzer_out
    platform: ledc
    pin:
      number: ${GPIO_BUZZER_OUTPUT_PIN}
      inverted: ${GPIO_BUZZER_OUTPUT_INVERTED}

##### UART FOR NEXTION DISPLAY #####
uart:
  - id: tf_uart
    tx_pin: ${GPIO_DISPLAY_NEXTION_TX_PIN}
    rx_pin: ${GPIO_DISPLAY_NEXTION_RX_PIN}
    baud_rate: ${BAUD_RATE}

json:  # Can be replaced by web_server

##### START - DISPLAY START CONFIGURATION #####
display:
  - id: disp1
    platform: nextion
    uart_id: tf_uart
    on_setup:
      - lambda: |-
          set_boot_flag(nspanel_ha_blueprint::boot_flags, BootFlag::NEXTION);
      - binary_sensor.template.publish:
          id: nextion_init
          state: true

    on_page:
      - if:
          condition:
            - lambda: return !id(is_uploading_tft);
            - or:
                - lambda: return (x == 9);
                - lambda: return (current_page->state != page_names[x]);
          then:
            - text_sensor.template.publish:
                id: current_page
                state: !lambda return page_names[x];

    on_touch:
      - script.execute: timer_reset_all
      - if:
          condition:
            - lambda: return !id(is_uploading_tft);
            - lambda: return (!touch_event);  // Only act with release
          then:
            - if:
                condition:
                  - or:
                      - and:
                          - lambda: return (page_id == 0);  // Page boot
                          - lambda: return (component_id == 24);  // Reboot button
                      - and:
                          - lambda: return (page_id == 8);  // Page settings
                          - lambda: return (component_id == 9);  // Reboot button
                then:
                  - lambda: App.safe_reboot();
            - if:
                condition:
                  - lambda: return (page_id == 10);  // Page light
                  - lambda: return (component_id == 32);  // power button
                then:
                  - script.execute:
                      id: ha_call_action
                      service: "light.toggle"
                      key: ""
                      value: ""
                      entity: !lambda return detailed_entity->state.c_str();
            - if:
                condition:
                  - lambda: return (page_id == 16);  // Page notification
                then:
                  - if:
                      condition:
                        - lambda: return (component_id == 7);  // bt_accept
                      then:
                        - text_sensor.template.publish:
                            id: notification_label
                            state: ""
                        - text_sensor.template.publish:
                            id: notification_text
                            state: ""
                        - switch.turn_off: notification_unread
                        - script.execute:
                            id: goto_page
                            page: home
                        - script.execute:
                            id: set_component_visibility
                            component_id: "home.bt_notific"
                            show: false
                  - if:
                      condition:
                        - lambda: return (component_id == 8);  // bt_clear
                      then:
                        - switch.turn_off: notification_unread
                        - script.execute:
                            id: goto_page
                            page: home
            - if:
                condition:
                  - lambda: return (page_id == 22);  // Page fan
                then:
                  - if:
                      condition:
                        - lambda: return (component_id == 13);  // bt_oscillate
                      then:
                        - script.execute:
                            id: ha_call_action
                            service: "fan.oscillate"
                            key: oscillating
                            value: toggle
                            entity: !lambda return detailed_entity->state.c_str();
                  - if:
                      condition:
                        - lambda: return (component_id == 14);  // power_button
                      then:
                        - script.execute:
                            id: ha_call_action
                            service: "fan.toggle"
                            key: ""
                            value: ""
                            entity: !lambda return detailed_entity->state.c_str();

##### START - GLOBALS CONFIGURATION #####
globals:
  - id: is_climate
    type: bool
    restore_value: true
    initial_value: 'true'

  - id: mui_bytes_per_char
    type: uint8_t
    restore_value: true
    initial_value: ${bytes_per_char}

  ####### Relay settings #######
  # Bit # Settings             #
  #  0  # Relay 1 - Local      #
  #  1  # Relay 1 - Fallback   #
  #  2  # reserved             #
  #  3  # reserved             #
  #  4  # Relay 2 - Local      #
  #  5  # Relay 2 - Fallback   #
  #  6  # reserved             #
  #  7  # reserved             #
  ##############################
  - id: relay_settings
    type: uint8_t
    restore_value: true
    initial_value: '0'
  ##### Relay icons #####
  - id: home_relay1_icon
    type: char[4]
    restore_value: true
    initial_value: ''
  - id: home_relay1_icon_color
    type: uint16_t
    restore_value: true
    initial_value: '65535'
  - id: home_relay2_icon
    type: char[4]
    restore_value: true
    initial_value: ''
  - id: home_relay2_icon_color
    type: uint16_t
    restore_value: true
    initial_value: '65535'

  ##### Is uploading TFT #####
  - id: is_uploading_tft
    type: bool
    restore_value: false
    initial_value: 'false'

  ##### Media Player #####
  ###### Last volume level from Home Assistant ######
  - id: last_volume_level
    type: uint8_t
    restore_value: false
    initial_value: '0'
  ###### Last duration from Home Assistant ######
  - id: last_media_duration
    type: uint
    restore_value: false
    initial_value: '0'
  ###### Last duration from Home Assistant ######
  - id: last_media_position
    type: uint
    restore_value: false
    initial_value: '0'

  ##### Add-on Climate #####
  ##### Is embedded thermostat set as main climate entity? #####
  - id: is_embedded_thermostat
    type: bool
    restore_value: true
    initial_value: 'false'

  ##### Is embedded sensor used for indoor temperature? #####
  - id: embedded_indoor_temp
    type: bool
    restore_value: true
    initial_value: 'true'

  ##### Date/time formats #####
  - id: home_date_color
    type: uint16_t
    restore_value: true
    initial_value: '65535'
  - id: mui_time_format
    type: std::string
    restore_value: true
    max_restore_data_length: 15
    initial_value: '"%H:%M"'
  - id: home_time_color
    type: uint16_t
    restore_value: true
    initial_value: '65535'
  - id: mui_meridiem
    type: std::array<std::string, 2>
    restore_value: false
    initial_value: '{"AM", "PM"}'

  #### Localization (MUI) ####
  - id: mui_please_confirm_global
    type: std::string
    restore_value: true
    initial_value: '"Please confirm"'
  - id: mui_unavailable_global
    type: std::string
    restore_value: true
    initial_value: '"Unavailable"'
  - id: mui_decimal_separator
    type: char
    restore_value: true
    initial_value: "'.'"

  ##### Chips #####
  - id: home_chip_font_id
    type: uint8_t
    restore_value: true
    initial_value: '7'

  #### Custom buttons ####
  - id: home_custom_buttons_font_id
    type: uint8_t
    restore_value: true
    initial_value: '8'

  ##### Screensaver #####
  - id: screensaver_display_time
    type: bool
    restore_value: true
    initial_value: 'false'
  - id: screensaver_display_time_font
    type: uint8_t
    restore_value: true
    initial_value: '6'
  - id: screensaver_display_time_color
    type: uint16_t
    restore_value: true
    initial_value: '16904'

  - id: page_entity_value_horizontal_alignment
    type: uint8_t
    restore_value: false
    initial_value: '1'  # Horizontal alignment:0-Left;1-Center;2-Right

##### START - BINARY SENSOR CONFIGURATION #####
binary_sensor:
  ## Delays initial info from HA to the display #####
  - name: Nextion display
    id: nextion_init
    platform: template
    device_class: connectivity
    entity_category: diagnostic
    icon: mdi:tablet-dashboard
    lambda: |-
      return (!id(is_uploading_tft) and disp1->is_setup());
    on_release:
      then:
        - lambda: clear_boot_flag(nspanel_ha_blueprint::boot_flags, BootFlag::NEXTION);

##### START - BUTTON CONFIGURATION #####
button:
  ###### Power cycle Nextion Display ######
  - name: Nextion display - Power cycle
    id: screen_power_cycle
    platform: template
    internal: false
    disabled_by_default: true
    icon: mdi:power-cycle
    entity_category: diagnostic
    on_press:
      - switch.turn_off: screen_power
      - delay: 1s
      - switch.turn_on: screen_power

##### START - NUMBER CONFIGURATION #####
number:
  ##### SCREEN BRIGHTNESS #####
  - id: display_brightness
    name: Display Brightness
    platform: template
    entity_category: config
    unit_of_measurement: '%'
    min_value: 1
    max_value: 100
    initial_value: 100
    step: 1
    restore_value: true
    optimistic: true
    on_value:
      then:
        - lambda: |-
            disp1->send_command_printf("brightness=%i", int(x));
            disp1->set_component_value("settings.brightslider", int(x));
        - if:
            condition:
              - not:
                  - text_sensor.state:
                      id: current_page
                      state: screensaver
            then:
              - script.execute:
                  id: set_brightness
                  brightness: !lambda return int(x);
              - script.execute: timer_dim
              - script.execute: timer_sleep
              - if:
                  condition:
                    - text_sensor.state:
                        id: current_page
                        state: settings
                  then:
                    - lambda: |-
                        disp1->set_component_text_printf("bright_text", "%i%%", int(x));

  ##### SCREEN BRIGHTNESS DIMMED DOWN #####
  - id: display_dim_brightness
    name: Display Brightness Dimdown
    platform: template
    entity_category: config
    unit_of_measurement: '%'
    min_value: 1
    max_value: 100
    initial_value: 25
    step: 1
    restore_value: true
    optimistic: true
    on_value:
      then:
        - lambda: |-
            disp1->send_command_printf("brightness_dim=%i", int(x));
            disp1->set_component_value("settings.dimslider", int(x));
        - if:
            condition:
              - not:
                  - text_sensor.state:
                      id: current_page
                      state: screensaver
              - lambda: return (current_brightness->state != x);
            then:
              - script.execute:
                  id: set_brightness
                  brightness: !lambda return int(x);
              - script.execute: timer_sleep
              - if:
                  condition:
                    - text_sensor.state:
                        id: current_page
                        state: settings
                  then:
                    - lambda: |-
                        disp1->set_component_text_printf("dim_text", "%i%%", int(x));

  ##### SCREEN BRIGHTNESS SLEEP #####
  - id: display_sleep_brightness
    name: Display Brightness Sleep
    platform: template
    entity_category: config
    unit_of_measurement: '%'
    min_value: 0
    max_value: 100
    initial_value: 0
    step: 1
    restore_value: true
    optimistic: true
    on_value:
      then:
        - lambda: |-
            disp1->send_command_printf("brightness_sleep=%i", int(x));
            page_screensaver->execute();

  ##### Temperature Correction #####
  - id: temperature_correction
    name: Temperature Correction
    platform: template
    entity_category: config
    unit_of_measurement: °C
    min_value: -10
    max_value: 10
    initial_value: 0
    step: 0.1
    mode: box
    restore_value: true
    internal: false
    optimistic: true
    on_value:
      - logger.log: Temperature correction changed.
      - delay: 1s
      - lambda: temp_nspanel->publish_state(temp_nspanel->raw_state);

  ##### Timers settings #####
  - name: Timeout Page
    platform: template
    id: timeout_page
    entity_category: config
    min_value: 0
    max_value: 86400
    initial_value: 15
    step: 1
    restore_value: true
    optimistic: true
    icon: mdi:timer
    unit_of_measurement: "s"
    on_value:
      - lambda: timer_page->execute();
  - name: Timeout Dimming
    platform: template
    id: timeout_dim
    entity_category: config
    min_value: 0
    max_value: 86400
    initial_value: 30
    step: 1
    restore_value: true
    optimistic: true
    icon: mdi:timer
    unit_of_measurement: "s"
    on_value:
      - script.execute: timer_dim
  - name: Timeout Sleep
    platform: template
    id: timeout_sleep
    entity_category: config
    min_value: 0
    max_value: 86400
    initial_value: 60
    step: 1
    restore_value: true
    optimistic: true
    icon: mdi:timer
    unit_of_measurement: "s"
    on_value:
      - if:
          condition:
            - lambda: return (x == 0);
            - text_sensor.state:
                id: current_page
                state: screensaver
          then:
            - script.execute:
                id: goto_page
                page: !lambda return wakeup_page_name->state.c_str();
      - script.execute: timer_dim
      - script.execute: timer_sleep

##### START - SELECT CONFIGURATION #####
select:
  - id: baud_rate
    name: Baud rate
    platform: template
    options:
      - "2400"
      - "4800"
      - "9600"
      - "19200"
      - "31250"
      - "38400"
      - "57600"
      - "115200"
      - "230400"
      - "250000"
      - "256000"
      - "512000"
      - "921600"
    initial_option: "115200"
    optimistic: true
    restore_value: true
    internal: false
    entity_category: config
    disabled_by_default: true
    icon: mdi:swap-horizontal
    on_value:
      then:
        - script.execute:
            id: set_baud_rate
            target_baud_rate: !lambda return std::stoi(x);
            definitive: true

  - id: wakeup_page_name
    name: Wake-up page
    platform: template
    options:
      - buttonpage01
      - buttonpage02
      - buttonpage03
      - buttonpage04
      - climate
      - entitypage01
      - entitypage02
      - entitypage03
      - entitypage04
      - home
      - qrcode
      - utilities
    initial_option: home
    optimistic: true
    restore_value: true
    internal: false
    entity_category: config
    icon: mdi:page-next-outline
    on_value:
      - lambda: |-
          page_screensaver->execute();

##### START - SENSOR CONFIGURATION #####
sensor:
  ##### Blueprint status #####
  # Bit # Settings step        #
  #  0  # reserved             #
  #  1  # page_home            #
  #  2  # qrcode               #
  #  3  # page_settings        #
  #  4  # relay_settings       #
  #  5  # global_settings      #
  #  6  # reserved             #
  #  7  # reserved             #
  ##############################
  - id: blueprint_status
    name: Blueprint
    platform: template
    unit_of_measurement: "%"
    accuracy_decimals: 1
    entity_category: diagnostic
    icon: mdi:link-variant
    internal: false
    disabled_by_default: false
    filters:
      - lambda: |-
          if (!isnan(x) and x>0)
            return (x / 62) * 100.0f;
          else
            return 0;
    on_value:
      then:
        - if:
            condition:
              - lambda: return (x == 100);
              - lambda: return !is_boot_flag_set(nspanel_ha_blueprint::boot_flags, BootFlag::BLUEPRINT);
            then:
              - lambda: |-
                  set_boot_flag(nspanel_ha_blueprint::boot_flags, BootFlag::BLUEPRINT);
              - script.execute: refresh_wifi_icon
            else:
              - if:
                  condition:
                    - lambda: return (x != 100);
                    - lambda: return is_boot_flag_set(nspanel_ha_blueprint::boot_flags, BootFlag::BLUEPRINT);
                  then:
                    - lambda: |-
                        clear_boot_flag(nspanel_ha_blueprint::boot_flags, BootFlag::BLUEPRINT);
                    - script.execute: refresh_wifi_icon

  ##### INTERNAL TEMPERATURE SENSOR, ADC VALUE #####
  - id: ntc_source
    platform: adc
    pin: ${GPIO_TEMPERATURE_ADC_PIN}
    attenuation: 12db
    samples: 4
    filters:
      - sliding_window_moving_average:
          window_size: 6
          send_every: 1

  ##### INTERNAL TEMPERATURE SENSOR, adc reading converted to resistance (calculation)#####
  - id: resistance_sensor
    platform: resistance
    sensor: ntc_source
    configuration: DOWNSTREAM
    resistor: 11.2kOhm

  ##### INTERNAL TEMPERATURE SENSOR, resistance to temperature (calculation) #####
  - id: temp_nspanel
    name: Temperature
    platform: ntc
    sensor: resistance_sensor
    unit_of_measurement: °C
    internal: false
    calibration:
      b_constant: 3950
      reference_temperature: 25°C
      reference_resistance: 10kOhm
    filters:
      - lambda: |-
          return x + temperature_correction->state;
    on_value:
      then:
        # Show panel's temperature if API or Wi-Fi are out
        - lambda: display_embedded_temp->execute();

  ###### Display Brightness GET VALUE FROM NSPanel SLIDER #####
  - id: brightslider
    name: brightness Slider
    platform: nextion
    variable_name: brightslider
    internal: true
    on_value:
      then:
        - if:
            condition:
              - lambda: return (int(display_brightness->state) != int(x));
            then:
              - number.set:
                  id: display_brightness
                  value: !lambda return int(x);

  ###### Display DIM Brightness GET VALUE FROM NSPanel SLIDER #####
  - id: dimslider
    name: dim brightness slider
    platform: nextion
    variable_name: dimslider
    internal: true
    on_value:
      then:
        - if:
            condition:
              - lambda: return (int(display_dim_brightness->state) != int(x));
            then:
              - number.set:
                  id: display_dim_brightness
                  value: !lambda return int(x);

  ###### Display Brightness - Current value (%) #####
  - id: current_brightness
    name: Display Current brightness
    platform: nextion
    variable_name: dim
    precision: 0
    accuracy_decimals: 0
    unit_of_measurement: "%"
    icon: mdi:brightness-percent
    internal: false
    disabled_by_default: false

  ##### Charset (1 = International (original), 2 = CJK languages)
  - id: display_charset
    name: Display charset
    platform: nextion
    variable_name: charset
    precision: 0
    accuracy_decimals: 0
    internal: false
    icon: mdi:translate
    entity_category: diagnostic

  ##### Display mode (1 = EU, 2 = US, 3 = US Landscape)
  - id: display_mode
    name: Display mode
    platform: nextion
    variable_name: display_mode
    precision: 0
    accuracy_decimals: 0
    internal: false
    icon: mdi:phone-rotate-portrait
    entity_category: diagnostic

  ##### Wi-Fi Signal stregth
  - name: RSSI
    id: wifi_rssi
    platform: wifi_signal
    internal: false
    disabled_by_default: false
    icon: mdi:wifi
    entity_category: diagnostic

##### START - SWITCH CONFIGURATION #####
switch:
  ##### Notification unread #####
  - name: Notification unread
    platform: template
    id: notification_unread
    entity_category: config
    optimistic: true
    restore_mode: ALWAYS_OFF
    on_turn_on:
      lambda: |-
        esphome::api::CustomAPIDevice ha_event;
        ha_event.fire_homeassistant_event("esphome.nspanel_ha_blueprint", {
          {"device_name", device_name->state.c_str()},
          {"esphome_version", "${version}"},
          {"type", "notification_changed"},
          {"component", "notification_unread"},
          {"action", "turn_on"}
        });
    on_turn_off:
      lambda: |-
        esphome::api::CustomAPIDevice ha_event;
        ha_event.fire_homeassistant_event("esphome.nspanel_ha_blueprint", {
          {"device_name", device_name->state.c_str()},
          {"esphome_version", "${version}"},
          {"type", "notification_changed"},
          {"component", "notification_unread"},
          {"action", "turn_off"}
        });

  ##### Notification sound #####
  - name: Notification sound
    platform: template
    id: notification_sound
    entity_category: config
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  ##### PHYSICAL SWITCH 1 #####
  - name: Relay 1
    platform: gpio
    id: relay_1
    pin:
      number: ${GPIO_RELAY_1_PIN}
      inverted: ${GPIO_RELAY_1_INVERTED}
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      then:
        - lambda: |-
            if (id(relay_settings) & RelaySettings::Relay1_Local)
              update_bitwise_setting(id(buttons_settings), true, ButtonSettings::ButtonLeft_State);
        - script.execute:
            id: refresh_relays
            relay_mask: 1
        - script.execute:
            id: refresh_hardware_buttons_bars
            button_mask: 1
    on_turn_off:
      then:
        - lambda: |-
            if (id(relay_settings) & RelaySettings::Relay1_Local)
              update_bitwise_setting(id(buttons_settings), false, ButtonSettings::ButtonLeft_State);
        - script.execute:
            id: refresh_relays
            relay_mask: 1
        - script.execute:
            id: refresh_hardware_buttons_bars
            button_mask: 1
  ##### PHYSICAL SWITCH 2 ######
  - name: Relay 2
    platform: gpio
    id: relay_2
    pin:
      number: ${GPIO_RELAY_2_PIN}
      inverted: ${GPIO_RELAY_2_INVERTED}
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      then:
        - lambda: |-
            if (id(relay_settings) & RelaySettings::Relay2_Local)
              update_bitwise_setting(id(buttons_settings), true, ButtonSettings::ButtonRight_State);
        - script.execute:
            id: refresh_relays
            relay_mask: 2
        - script.execute:
            id: refresh_hardware_buttons_bars
            button_mask: 2
    on_turn_off:
      then:
        - lambda: |-
            if (id(relay_settings) & RelaySettings::Relay2_Local)
              update_bitwise_setting(id(buttons_settings), false, ButtonSettings::ButtonRight_State);
        - script.execute:
            id: refresh_relays
            relay_mask: 2
        - script.execute:
            id: refresh_hardware_buttons_bars
            button_mask: 2

  ##### DISPLAY ALWAYS ON #####
  - name: Nextion display - Power
    platform: gpio
    id: screen_power
    entity_category: diagnostic
    pin:
      number: 4
      inverted: true
    restore_mode: ALWAYS_ON
    internal: true
    disabled_by_default: false
    on_turn_off:
      then:
        - binary_sensor.template.publish:
            id: nextion_init
            state: false

##### START - TEXT SENSOR CONFIGURATION #####
text_sensor:
  ##### Device name - Used by bluepring to find service's names #####
  - id: device_name
    name: Device Name
    platform: template
    icon: mdi:identifier
    entity_category: diagnostic
    internal: false
    disabled_by_default: false
    lambda: |-
      return {"${name}"};
    filters:
      - lambda: |-
          #ifdef ESP_MAC_WIFI_STA
          std::string suffix = "00ERROR";  // Default suffix in case of an error
          uint8_t mac[6] = {0,0,0,0,0,0};
          if (esp_read_mac(mac, ESP_MAC_WIFI_STA) == ESP_OK) {
            suffix.clear();  // Clear the default error suffix
            for (int i = 3; i < 6; ++i) {  // Use last 3 bytes of MAC
              char hex[3];
              snprintf(hex, sizeof(hex), "%02X", mac[i]);
              suffix += hex;
            }
          }
          // Proceed with suffix (either MAC-based or default error indicator)
          const std::string raw_name = (x + "-" + suffix);
          #else
          const std::string raw_name = x;
          #endif

          std::string result;
          bool last_was_underscore = false;
          for (const char& c : raw_name) {
            if (isalnum(c)) {
              result += tolower(c);  // Add alphanumeric characters as lowercase
              last_was_underscore = false;
            } else if (!last_was_underscore) {  // Replace non-alphanumeric with '_' but avoid consecutive '_'
              result += '_';
              last_was_underscore = true;
            }
          }
          return result;

  ##### Entity Id of the entity displayed on the detailed pages
  - id: detailed_entity
    name: Detailed Entity
    platform: template
    icon: mdi:tablet-dashboard
    internal: false
    disabled_by_default: false

  ##### Current page name #####
  - id: current_page
    name: Current Page
    platform: nextion
    component_name: current_page
    icon: mdi:tablet-dashboard
    internal: false
    disabled_by_default: false
    filters:
      - lambda: |-
          x = x.c_str();
          x.shrink_to_fit();
          return x;
    on_value:
      lambda: |-
        if (!id(is_uploading_tft)) {
          page_changed->execute();
        }

  - id: notification_label
    name: Notification Label
    platform: template
    on_value:
      lambda: |-
        esphome::api::CustomAPIDevice ha_event;
        ha_event.fire_homeassistant_event("esphome.nspanel_ha_blueprint", {
          {"device_name", device_name->state.c_str()},
          {"esphome_version", "${version}"},
          {"type", "notification_changed"},
          {"component", "notification_label"},
          {"action", "new_value"}
        });

  - id: notification_text
    name: Notification Text
    platform: template
    on_value:
      lambda: |-
        esphome::api::CustomAPIDevice ha_event;
        ha_event.fire_homeassistant_event("esphome.nspanel_ha_blueprint", {
          {"device_name", device_name->state.c_str()},
          {"esphome_version", "${version}"},
          {"type", "notification_changed"},
          {"component", "notification_text"},
          {"action", "new_value"}
        });

  ##### NSPanel event - Execute actions from ESPHome - NO push to HA #####
  - id: disp1_local_event
    name: NSPanel local event
    platform: nextion
    nextion_id: disp1
    component_name: localevent
    internal: true
    on_value:
      then:
        - lambda: |-
            JsonDocument json;
            DeserializationError error = deserializeJson(json, x.c_str());
            if (error) {
                ESP_LOGE("text_sensor.disp1_local_event", "Error parsing json: %s", x.c_str());
                ESP_LOGE("text_sensor.disp1_local_event", "Error: %s", error.c_str());
            } else {
              const std::string page = json["page"];
              const std::string event = json["event"];
              const std::string component = json["component"];
              const std::string key = json["key"];
              const std::string value = json["value"];

              esphome::api::CustomAPIDevice ha_event;
              // Send event to Home Assistant
              if (event == "short_click" or event == "long_click") {
                if (api_server->is_connected() and page == "home" and component == "weather") {
                  goto_page->execute("weather01");
                } else if (id(is_climate) and page == "home" and (component == "indr_temp" or component == "indr_temp_icon")) {
                  detailed_entity->publish_state((id(is_embedded_thermostat)) ? "embedded_climate" : "");
                  disp1->set_component_value("climate.embedded", id(is_embedded_thermostat) ? 1 : 0);
                  goto_page->execute("climate");
                } else {
                  ha_button->execute(page.c_str(), component.c_str(), event.c_str());
                }
              } else if (page == "light" or page == "climate") {  // Generic event
                ha_event.fire_homeassistant_event("esphome.nspanel_ha_blueprint", {
                  {"device_name", device_name->state.c_str()},
                  {"esphome_version", "${version}"},
                  {"type", "generic"},
                  {"page", page.c_str()},
                  {"component", component.c_str()},
                  {"event", event.c_str()},
                  {"value", value.c_str()},
                  {"entity", detailed_entity->state.c_str()}
                });
              }

              // page based actions
              if (page == "alarm") {
                const std::string code_format = json["code_format"];
                const std::string code_arm_req = json["code_arm_req"];
                const std::string title = json["mui"];
                if (code_format == "number" and (key == "disarm" or code_arm_req == "1")) {
                  goto_page->execute("keyb_num");
                  disp1->set_component_value("keyb_num.page_id", get_page_id("alarm")); //Calling from Alarm page
                  disp1->set_component_text("keyb_num.domain", page.c_str());
                  disp1->set_component_text("keyb_num.key", key.c_str());
                  disp1->set_component_text("keyb_num.value", value.c_str());
                  disp1->set_component_text("keyb_num.entity", detailed_entity->state.c_str());
                  disp1->set_component_text("keyb_num.title", title.c_str());
                  } else service_call_alarm_control_panel->execute(detailed_entity->state.c_str(), key.c_str(), code_format.c_str(), "");
              } else if (page == "climate") {
                const uint8_t embedded = json["embedded"];
                change_climate_state->execute(embedded == 1, key.c_str(), value.c_str());
              } else if (page == "cover") {
                if (key == "position") ha_call_action->execute("cover.set_cover_position", key.c_str(), value.c_str(), detailed_entity->state.c_str());
                else ha_call_action->execute(("cover." + key).c_str(), "", "", detailed_entity->state.c_str());
              } else if (page == "fan") {
                if (key == "stop" or value == "0") ha_call_action->execute("fan.turn_off", "", "", detailed_entity->state.c_str());
                else ha_call_action->execute("fan.turn_on", key.c_str(), value.c_str(), detailed_entity->state.c_str());
              } else if (page == "keyb_num") {
                const std::string base_domain = json["base_domain"];
                if (base_domain == "alarm") {
                  const std::string code_format = json["code_format"];
                  const std::string pin = json["pin"];
                  service_call_alarm_control_panel->execute(detailed_entity->state.c_str(), key.c_str(), code_format.c_str(), pin.c_str());
                }
                goto_page->execute(base_domain.empty() ? "home" : base_domain.c_str());
              } else if (page == "light") {
                if (key == "brightness_pct" or key == "color_temp") {
                  ha_call_action->execute("light.turn_on", key.c_str(), value.c_str(), detailed_entity->state.c_str());
                } else if (component == "rgb_color") {
                  JsonArray rgb_color = json["value"];
                  if (rgb_color.size() == 3) {
                    ha_event.fire_homeassistant_event("esphome.nspanel_ha_blueprint",
                      {
                        {"device_name", device_name->state.c_str()},
                        {"esphome_version", "${version}"},
                        {"type", "service_call"},
                        {"service", "light.turn_on"},
                        {"key", "rgb_color"},
                        {"red",to_string(rgb_color[0].as<int>())},
                        {"green",to_string(rgb_color[1].as<int>())},
                        {"blue",to_string(rgb_color[2].as<int>())},
                        {"entity", detailed_entity->state.c_str()}
                      });
                  }
                }
              } else if (page == "media_player") {
                if (key == "volume_mute") {
                  ha_call_action->execute("media_player.volume_mute", "is_volume_muted", value.c_str(), detailed_entity->state.c_str());
                } else if (key == "volume_set") {
                  const float value_float = json["value"].as<float>();
                  ha_call_action->execute("media_player.volume_set", "volume_level", to_string(value_float / 100.0f), detailed_entity->state.c_str());
                } else if (!key.empty()) {
                  ha_call_action->execute((std::string("media_player.") + key.c_str()), "", "", detailed_entity->state.c_str());
                }
              }
            }

  ##### Versioning #####
  - id: version_blueprint
    name: Version Blueprint
    platform: template
    entity_category: diagnostic
    icon: mdi:tag-text-outline
    internal: false
    update_interval: never
    on_value:
      then:
        - script.execute: check_versions

  - id: version_esphome
    name: Version ESPHome
    platform: template
    entity_category: diagnostic
    icon: mdi:tag-text-outline
    internal: false
    update_interval: never
    lambda: |-
      return {"${version}"};

  - id: version_tft
    name: Version TFT
    platform: nextion
    component_name: boot.version
    entity_category: diagnostic
    icon: mdi:tag-text-outline
    internal: false
    update_interval: never
    on_value:
      then:
        - script.execute: check_versions

### Scripts ######
script:
  - id: change_climate_state
    mode: restart
    parameters:
      embedded: bool
      key: string
      value: string
    then:
      - lambda: |-
          if (!id(is_uploading_tft)) {
            if (not embedded) {
              if (key == "temperature" or key == "target_temp_high" or key == "target_temp_low")
                ha_call_action->execute("climate.set_temperature", key.c_str(), to_string(stof(value) / 10), detailed_entity->state.c_str());
              else if (key == "hvac_mode")
                ha_call_action->execute("climate.set_hvac_mode", key.c_str(), value.c_str(), detailed_entity->state.c_str());
            }
          }

  - id: check_version_tft
    mode: single
    then:
      - delay: 5s
      - lambda: |-
          version_tft->update();

  - id: check_versions
    mode: single
    then:
      - if:
          condition:
            - lambda: return !id(is_uploading_tft);
          then:
            - delay: 5s
            - lambda: |-
                for (uint8_t i = 0; i < 60; i++) {
                  if (compare_versions("${version}", version_tft->state.c_str()) and compare_versions("${version}", version_blueprint->state.c_str()))
                    break;
                  delay(1000);
                  App.feed_wdt();
                }
            - if:
                condition:
                  - lambda: return id(is_uploading_tft);
                then:
                  - logger.log: Version check stopped as a TFT upload was requested
                else:
                  - lambda: |-
                      ESP_LOGD("${TAG_CORE}", "Versions:");
                      ESP_LOGD("${TAG_CORE}", "  TFT:       %s", version_tft->state.c_str());
                      ESP_LOGD("${TAG_CORE}", "  ESPHome:   ${version}");
                      if (not compare_versions("${version}", version_tft->state.c_str()))
                        ESP_LOGE("${TAG_CORE}", "TFT version mismatch!");
                      ESP_LOGD("${TAG_CORE}", "  Blueprint: %s", version_blueprint->state.c_str());
                      if (not compare_versions("${version}", version_blueprint->state.c_str()))
                        ESP_LOGE("${TAG_CORE}", "Blueprint version mismatch!");
                  - delay: 1s
                  - homeassistant.event:
                      event: esphome.nspanel_ha_blueprint
                      data:
                        device_name: !lambda return device_name->state.c_str();
                        esphome_version: ${version}
                        type: version
                        tft: !lambda return version_tft->state.c_str();
                        esphome: ${version}
                        blueprint: !lambda return version_blueprint->state.c_str();
                  - logger.log: Check version completed

  - id: display_embedded_temp
    mode: single
    then:
      - if:
          condition:
            - or:
                - lambda: return id(embedded_indoor_temp);
                - lambda: return !is_boot_flag_set(nspanel_ha_blueprint::boot_flags, BootFlag::API);
                - lambda: return !is_boot_flag_set(nspanel_ha_blueprint::boot_flags, BootFlag::WIFI);
          then:
            - lambda: |-
                static const std::string temp_units = "${temp_units}";
                static const bool temp_unit_fahrenheit =
                                  (temp_units == "°F" || temp_units == "F" || temp_units == "°f" || temp_units == "f");
                static char buffer[15]; // Buffer for formatted temperature string
                if (temp_unit_fahrenheit) {
                  snprintf(buffer, sizeof(buffer), "%.0f${temp_units}",
                                    (temp_nspanel->state * 9.0 / 5.0) + 32); // Fahrenheit with no decimal
                } else {
                  snprintf(buffer, sizeof(buffer), "%.1f${temp_units}",
                                    temp_nspanel->state); // Celsius with one decimal
                }
                disp1->set_component_text("home.indr_temp",
                                            adjustDecimalSeparator(buffer, id(mui_decimal_separator)).c_str());

  - id: display_wrapped_text
    mode: parallel
    max_runs: 3
    parameters:
      component: string
      text_to_display: string
      line_length_limit: uint
    then:
      - if:
          condition:
            - lambda: return (text_to_display.length() > 1000);  // Safety check for overly long text
          then:
            - lambda: |-
                ESP_LOGW("display_wrapped_text", "Text too long");
                disp1->set_component_text(component.c_str(), "ERROR: Text too long");
          else:
            - if:
                condition:
                  - lambda: |-
                      return (text_to_display.find("\\r") != std::string::npos);  // Early exit for already formatted text
                then:
                  - lambda: |-
                      disp1->set_component_text(component.c_str(), text_to_display.c_str());
                else:
                  - lambda: |-
                      const uint16_t max_line_length = line_length_limit * id(mui_bytes_per_char);
                      const uint16_t text_len = text_to_display.length();

                      // If text is short enough, no wrapping needed
                      if (text_len <= max_line_length) {
                        disp1->set_component_text(component.c_str(), text_to_display.c_str());
                        return;
                      }

                      // Pre-allocate string to avoid reallocations
                      std::string wrapped_text;
                      wrapped_text.reserve(text_len + 20);  // Reserve space for line breaks

                      uint16_t start = 0;

                      while (start < text_len) {
                        // Skip leading spaces
                        while (start < text_len && text_to_display[start] == ' ') {
                          start++;
                        }

                        if (start >= text_len) break;

                        // Find end position
                        uint16_t end = start + max_line_length;
                        if (end >= text_len) {
                          end = text_len;
                        } else {
                          // Find word boundary by looking backwards for space
                          uint16_t word_end = end;
                          while (word_end > start && text_to_display[word_end] != ' ') {
                            word_end--;
                          }

                          // If we found a space within reasonable distance, use it
                          if (word_end > start) {
                            end = word_end;
                          }
                          // Otherwise force break at max_line_length (handles long words)
                        }

                        // Add text segment
                        wrapped_text.append(text_to_display, start, end - start);

                        // Add line break if not at end of text
                        if (end < text_len) {
                          wrapped_text += "\\r";

                          // Skip spaces at the break point to avoid leading spaces on next line
                          while (end < text_len && text_to_display[end] == ' ') {
                            end++;
                          }
                        }

                        start = end;
                      }

                      disp1->set_component_text(component.c_str(), wrapped_text.c_str());

  - id: !extend dump_config
    then:
      # Report Wi-Fi status
      - lambda: |-
          if (is_boot_flag_set(nspanel_ha_blueprint::boot_flags, BootFlag::WIFI)) {
            float rssi = wifi_rssi->state;
            const char *rssi_status = "Unknown"; // Use const char* to avoid dynamic memory allocation
            if (rssi > -50) rssi_status = "Excellent";
            else if (rssi > -60) rssi_status = "Good";
            else if (rssi > -70) rssi_status = "Fair";
            else if (rssi > -80) rssi_status = "Weak";
            else rssi_status = "Poor";
            if (rssi > -70) ESP_LOGCONFIG("nspanel_ha_blueprint", "Wi-Fi:         %s (%.0f dBm)", rssi_status, rssi);
            else if (rssi > -80) ESP_LOGW("nspanel_ha_blueprint", "Wi-Fi:         %s (%.0f dBm)", rssi_status, rssi);
            else ESP_LOGE("nspanel_ha_blueprint", "Wi-Fi:         %s (%.0f dBm)", rssi_status, rssi);
          }
          else {
            ESP_LOGW("nspanel_ha_blueprint", "Wi-Fi:         DISCONNECTED");
          }

      # Report API status
      - lambda: |-
          if (!are_all_boot_flags_set(nspanel_ha_blueprint::boot_flags, {BootFlag::WIFI, BootFlag::API}))
            blueprint_status->publish_state(0);

          // Report blueprint version
          ESP_LOGCONFIG("nspanel_ha_blueprint", "Blueprint:");
          if (is_boot_flag_set(nspanel_ha_blueprint::boot_flags, BootFlag::BLUEPRINT)) {
            ESP_LOGCONFIG("nspanel_ha_blueprint", "  Version:     %s", version_blueprint->state.c_str());
            ESP_LOGCONFIG("nspanel_ha_blueprint", "  Init steps:  %i (%0.1f%%)", int(blueprint_status->raw_state), blueprint_status->state);
          } else {
            ESP_LOGW("nspanel_ha_blueprint", "  Init steps:  %i (%0.1f%%)", int(blueprint_status->raw_state), blueprint_status->state);
            ESP_LOGW("nspanel_ha_blueprint", "  State:       %s", (are_all_boot_flags_set(nspanel_ha_blueprint::boot_flags, {BootFlag::WIFI, BootFlag::API}))
                                                                  ? "Pending" : "DISCONNECTED");
            ESP_LOGCONFIG("nspanel_ha_blueprint", "Requesting blueprint settings");
            boot_event->execute(false);
          }

      # Report ESPHome
      - lambda: |-
          ESP_LOGCONFIG("nspanel_ha_blueprint", "ESPHome:");
          ESP_LOGCONFIG("nspanel_ha_blueprint", "  Version:  ${version}");
          ESP_LOGCONFIG("nspanel_ha_blueprint", "  Compiler: %s", ESPHOME_VERSION);
          ESP_LOGCONFIG("nspanel_ha_blueprint", "  Compilation time: %s", App.get_compilation_time().c_str());

      # Report framework
      - lambda: |-
          ESP_LOGCONFIG("nspanel_ha_blueprint", "  Framework:   "
          #ifdef ARDUINO
          "Arduino"
          #elif defined(USE_ESP_IDF)
          "ESP-IDF"
          #else
          "Unknown"
          #endif
          );

      # Report memory
      - lambda: |-
          #include <esp_heap_caps.h>
          const size_t internal_heap_size = heap_caps_get_total_size(MALLOC_CAP_INTERNAL);
          const size_t internal_heap_size_free = heap_caps_get_free_size(MALLOC_CAP_INTERNAL);
          ESP_LOGCONFIG("nspanel_ha_blueprint", "  Free heap:");

          if (internal_heap_size != 0) {
            ESP_LOGCONFIG("nspanel_ha_blueprint", "    Internal:  %7d bytes (%0.1f%%)", internal_heap_size_free,
                    ((float)internal_heap_size_free / internal_heap_size) * 100.0f);
          } else {
            ESP_LOGCONFIG("nspanel_ha_blueprint", "    Internal:  %7d bytes", internal_heap_size_free);
          }

          #ifdef USE_PSRAM
          const size_t psram_heap_size = heap_caps_get_total_size(MALLOC_CAP_SPIRAM);
          const size_t psram_heap_size_free = heap_caps_get_free_size(MALLOC_CAP_SPIRAM);
          if (psram_heap_size != 0) {
            ESP_LOGCONFIG("nspanel_ha_blueprint", "    PSRAM:     %7d bytes (%0.1f%%)", psram_heap_size_free,
                    ((float)psram_heap_size_free / psram_heap_size) * 100.0f);
          } else {
            ESP_LOGCONFIG("nspanel_ha_blueprint", "    PSRAM:     %7d bytes", psram_heap_size_free);
          }
          #endif

      # Report UART
      - lambda: |-
          ESP_LOGCONFIG("nspanel_ha_blueprint", "UART:");
          ESP_LOGCONFIG("nspanel_ha_blueprint", "  Baud rate:   %" PRIu32 " bps", tf_uart->get_baud_rate());
          ESP_LOGCONFIG("nspanel_ha_blueprint", "  Queue size:  %d", tf_uart->available());

      # Report Nextion status
      - binary_sensor.template.publish:
          id: nextion_init
          state: !lambda return (!id(is_uploading_tft) and nextion_init->state and disp1->is_setup());
      - lambda: |-
          ESP_LOGCONFIG("nspanel_ha_blueprint", "Nextion:");
          ESP_LOGCONFIG("nspanel_ha_blueprint", "  Queue size:  %d", disp1->queue_size());
          if (disp1->is_setup())
            ESP_LOGCONFIG("nspanel_ha_blueprint", "  Is setup:    True");
          else {
            ESP_LOGW("nspanel_ha_blueprint", "  Is setup:    False");
            ESP_LOGW("nspanel_ha_blueprint", "  Is detected: %s", YESNO(disp1->is_detected()));
            //exit_reparse->execute();
          }
          if (nextion_init->state) {
            ESP_LOGCONFIG("nspanel_ha_blueprint", "  Init:        True");
          } else
            ESP_LOGW("nspanel_ha_blueprint", "  Init:        False");
          if (version_tft->state.empty())
            ESP_LOGW("nspanel_ha_blueprint", "  TFT:         UNKNOWN");
          else
            ESP_LOGCONFIG("nspanel_ha_blueprint", "  TFT:         %s", version_tft->state.c_str());

      # Report Packages
      - lambda: |-
          ESP_LOGCONFIG("nspanel_ha_blueprint", "Packages:");
          #ifdef NSPANEL_HA_BLUEPRINT_CORE
          ESP_LOGCONFIG("nspanel_ha_blueprint", "  - Core");
          #endif
          #ifdef NSPANEL_HA_BLUEPRINT_ADVANCED
          ESP_LOGCONFIG("nspanel_ha_blueprint", "  - Advanced");
          #endif
          #ifdef NSPANEL_HA_BLUEPRINT_ADDON_BLUETOOTH_PROXY
          ESP_LOGCONFIG("nspanel_ha_blueprint", "  - Bluetooth Proxy");
          #endif
          #ifdef NSPANEL_HA_BLUEPRINT_ADDON_UPLOAD_TFT
          ESP_LOGCONFIG("nspanel_ha_blueprint", "  - Upload TFT");
          #endif
          #ifdef NSPANEL_HA_BLUEPRINT_ADDON_CLIMATE_BASE
          ESP_LOGCONFIG("nspanel_ha_blueprint", "  - Climate - Base");
          #endif
          #ifdef NSPANEL_HA_BLUEPRINT_ADDON_CLIMATE_COOL
          ESP_LOGCONFIG("nspanel_ha_blueprint", "  - Climate - Cool");
          #endif
          #ifdef NSPANEL_HA_BLUEPRINT_ADDON_CLIMATE_DUAL
          ESP_LOGCONFIG("nspanel_ha_blueprint", "  - Climate - Dual");
          #endif
          #ifdef NSPANEL_HA_BLUEPRINT_ADDON_CLIMATE_HEAT
          ESP_LOGCONFIG("nspanel_ha_blueprint", "  - Climate - Heat");
          #endif
          #ifdef NSPANEL_HA_BLUEPRINT_PREBUILT
          ESP_LOGCONFIG("nspanel_ha_blueprint", "  - Pre-built");
          #endif
          #ifdef NSPANEL_HA_BLUEPRINT_PREBUILT_WALL_DISPLAY
          ESP_LOGCONFIG("nspanel_ha_blueprint", "  - Pre-built (Wall Display)");
          #endif
          #if defined(USE_BLUETOOTH_PROXY) || defined(USE_WEBSERVER) || defined(USE_CAPTIVE_PORTAL)
          ESP_LOGCONFIG("nspanel_ha_blueprint", "Components:");
          #ifdef USE_ESP32_BLE_SERVER
          ESP_LOGCONFIG("nspanel_ha_blueprint", "  - BLE server");
          #endif
          #ifdef USE_ESP32_BLE_CLIENT
          ESP_LOGCONFIG("nspanel_ha_blueprint", "  - BLE tracker");
          #endif
          #ifdef USE_BLUETOOTH_PROXY
          ESP_LOGCONFIG("nspanel_ha_blueprint", "  - Bluetooth proxy");
          #endif
          #ifdef USE_CAPTIVE_PORTAL
          ESP_LOGCONFIG("nspanel_ha_blueprint", "  - Captive portal");
          #endif
          #ifdef USE_IMPROV
          ESP_LOGCONFIG("nspanel_ha_blueprint", "  - Improv (BLE)");
          #endif
          #ifdef USE_WEBSERVER
          ESP_LOGCONFIG("nspanel_ha_blueprint", "  - Web server");
          #endif
          #endif

  - id: global_settings
    mode: single
    parameters:
      blueprint_version: string
      ent_value_xcen: int
      mui_please_confirm: string
      mui_unavailable: string
      screensaver_time: bool
      screensaver_time_font: int
      screensaver_time_color: int32_t[]
      decimal_separator: string
    then:
      - lambda: |-
          ESP_LOGD("script.global_settings", "Processing global settings from blueprint");
      - delay: ${DELAY_DEFAULT}ms
      # Blueprint version
      - script.execute:
          id: boot_log
          category: Blueprint
          log_message: "Global settings"
      - lambda: |-
          ESP_LOGD("script.global_settings", "Blueprint version: %s", blueprint_version.c_str());
      - delay: ${DELAY_DEFAULT}ms
      - text_sensor.template.publish:
          id: version_blueprint
          state: !lambda return blueprint_version;
      - lambda: |-
          disp1->set_component_text_printf("ver_blueprint", "Blueprint: %s", blueprint_version.c_str());
      - lambda: |-
          ESP_LOGD("script.global_settings", "Checking versions");
      #- delay: ${DELAY_DEFAULT}ms
      #- script.execute: check_versions

      # MUI strings
      - lambda: |-
          ESP_LOGD("script.global_settings", "Processing localization");
      - delay: ${DELAY_DEFAULT}ms
      - globals.set:
          id: mui_please_confirm_global
          value: !lambda return mui_please_confirm;
      - globals.set:
          id: mui_unavailable_global
          value: !lambda return mui_unavailable;

      # Screen saver page (sleep)
      - lambda: |-
          ESP_LOGD("script.global_settings", "Setup page screensaver");
      - delay: ${DELAY_DEFAULT}ms
      - globals.set:
          id: screensaver_display_time
          value: !lambda return screensaver_time;
      - globals.set:
          id: screensaver_display_time_font
          value: !lambda return screensaver_time_font;
      - globals.set:
          id: screensaver_display_time_color
          value: !lambda return rgbTo565(screensaver_time_color);
      - lambda: |-
          ESP_LOGD("script.global_settings", "Update page screensaver");
      - delay: ${DELAY_DEFAULT}ms
      - script.execute: page_screensaver

      # Entities pages alignment
      - lambda: |-
          ESP_LOGD("script.global_settings", "Set value alignment on entities pages");
      - delay: ${DELAY_DEFAULT}ms
      - globals.set:
          id: page_entity_value_horizontal_alignment
          value: !lambda return ent_value_xcen;

      # Decimal separator
      - lambda: |-
          ESP_LOGD("script.global_settings", "Decimal separator: %s", decimal_separator.c_str());
      - delay: ${DELAY_DEFAULT}ms
      - if:
          condition:
            - lambda: return !decimal_separator.empty();
          then:
            - globals.set:
                id: mui_decimal_separator
                value: !lambda return decimal_separator[0];

      # Update current page
      - lambda: |-
          ESP_LOGD("script.global_settings", "Update current page: %s", current_page->state.c_str());
      - delay: ${DELAY_DEFAULT}ms
      - if:
          condition:
            - text_sensor.state:
                id: current_page
                state: boot
          then:
            - script.execute: page_changed

  - id: goto_page
    mode: restart
    parameters:
      page: string
    then:
      - lambda: if (current_page->state != page) disp1->goto_page(page.c_str());

  - id: init_hardware_climate
    mode: single
    parameters:
      embedded_climate: bool                  # Indicates if climate control is integrated.
      embedded_climate_friendly_name: string  # Friendly name for the climate control feature.
      embedded_indoor_temperature: bool       # Enables indoor temperature display.
    then:
      - lambda: |-
          // Embedded thermostat
          id(is_embedded_thermostat) = embedded_climate;

          // Indoor temperature
          id(embedded_indoor_temp) = embedded_indoor_temperature;
          display_embedded_temp->execute();

  - id: page_alarm
    mode: single
    then:  # There's nothing here so far

  - id: page_blank
    mode: single
    then:
      - lambda: |-
          ESP_LOGW("script.page_blank", "Construct blank page");
          disp1->set_component_text("esp_version", "FW: ${version}");  // ESPHome version
          #ifdef ARDUINO
          disp1->set_component_text("framework", "Arduino");
          #elif defined(USE_ESP_IDF)
          disp1->set_component_text("framework", "ESP-IDF");
          #endif
          disp1->send_command("tm_esphome.en=0");

  - id: page_boot
    mode: single
    then:
      - logger.log: Page boot called
      - script.execute:
          id: boot_log
          category: Boot
          log_message: "Starting sequence"
      - delay: ${DELAY_DEFAULT}ms
      - script.execute:
          id: boot_progress
          step: 0
      - delay: ${DELAY_DEFAULT}ms
      - script.execute:
          id: set_brightness
          brightness: 100
      - delay: ${DELAY_DEFAULT}ms
      - script.execute: update_tft_info
      - delay: ${DELAY_DEFAULT}ms
      - script.execute:
          id: boot_log
          category: Boot
          log_message: "ESPHome FW v${version}"
      - delay: ${DELAY_DEFAULT}ms
      - lambda: |-
          disp1->set_component_text("ver_firmware", "Firmware: ${version}");  // ESPHome version
      - delay: ${DELAY_DEFAULT}ms
      - script.execute:
          id: boot_progress
          step: 1
      - delay: ${DELAY_DEFAULT}ms
      - script.execute:
          id: boot_log
          category: Boot
          log_message: !lambda |-
                          #ifdef ARDUINO
                          return "Framework is Arduino";
                          #elif defined(USE_ESP_IDF)
                          return "Framework is ESP-IDF";
                          #endif
                          return "Framework is unknown";
      - delay: ${DELAY_DEFAULT}ms
      - lambda: |-
          #ifdef ARDUINO
          disp1->set_component_text("sys_framework", "Framework: Arduino");
          #elif defined(USE_ESP_IDF)
          disp1->set_component_text("sys_framework", "Framework: ESP-IDF");
          #else
          disp1->set_component_text("sys_framework", "Framework: Unknown");
          #endif
      - delay: ${DELAY_DEFAULT}ms
      - script.execute:
          id: boot_progress
          step: 2
      - delay: ${DELAY_DEFAULT}ms
      - script.execute:
          id: boot_log
          category: Boot
          log_message: "Waiting for Wi-Fi"
      - delay: ${DELAY_DEFAULT}ms
      - lambda: |-
          for (uint8_t i = 0; i < 10; i++) {
            if (is_boot_flag_set(nspanel_ha_blueprint::boot_flags, BootFlag::WIFI))
              break;
            delay(1000);
            App.feed_wdt();
          }
      - if:
          condition:
            - lambda: |-
                return !is_boot_flag_set(nspanel_ha_blueprint::boot_flags, BootFlag::WIFI);
          then:
            - script.execute:
                id: boot_log
                category: Boot
                log_message: "Wi-Fi not available"
          else:  # Wi-Fi connected
            - script.execute:
                id: boot_log
                category: Boot
                log_message: "Wi-Fi connected"
            - delay: ${DELAY_DEFAULT}ms
            - script.execute:
                id: boot_progress
                step: 3
            - if:
                condition:
                  - text_sensor.state:
                      id: current_page
                      state: boot
                then:
                  - delay: ${DELAY_DEFAULT}ms
                  - lambda: |-
                      disp1->set_component_text_printf("sys_ip", "IP: %s", network::get_ip_addresses()[0].str().c_str());
                  - delay: ${DELAY_DEFAULT}ms
                  - script.execute:
                      id: set_brightness
                      brightness: 100
            - script.execute:
                id: boot_log
                category: Boot
                log_message: "Waiting for API"
            - lambda: |-
                for (uint8_t i = 0; i < 10; i++) {
                  if (is_boot_flag_set(nspanel_ha_blueprint::boot_flags, BootFlag::API))
                    break;
                  delay(1000);
                  App.feed_wdt();
                }
            - if:
                condition:
                  - lambda: |-
                      return !is_boot_flag_set(nspanel_ha_blueprint::boot_flags, BootFlag::API);
                then:
                  - delay: ${DELAY_DEFAULT}ms
                  - script.execute:
                      id: boot_log
                      category: Boot
                      log_message: "API not available"
                else:  # API connected
                  - delay: ${DELAY_DEFAULT}ms
                  - script.execute:
                      id: boot_log
                      category: Boot
                      log_message: "API connected"
                  - script.execute:
                      id: boot_progress
                      step: 4

      # Display settings
      - delay: ${DELAY_DEFAULT}ms
      - script.execute:
          id: boot_log
          category: Boot
          log_message: "Sending display settings"
      - delay: ${DELAY_DEFAULT}ms
      - lambda: |-
          disp1->send_command_printf("brightness=%i", int(display_brightness->state));
          disp1->set_component_value("settings.brightslider", int(display_brightness->state));
          disp1->send_command_printf("brightness_dim=%i", int(display_dim_brightness->state));
          disp1->set_component_value("settings.dimslider", int(display_dim_brightness->state));
          disp1->send_command_printf("brightness_sleep=%i", int(display_sleep_brightness->state));
          disp1->send_command_printf("wakeup_page_id=%" PRIu8, get_page_id(wakeup_page_name->state.c_str()));
      - delay: ${DELAY_DEFAULT}ms
      - script.execute:
          id: boot_progress
          step: 5

      # Publish Nextion state
      - delay: ${DELAY_DEFAULT}ms
      - script.execute:
          id: boot_log
          category: Boot
          log_message: "Publish Nextion state"
      - delay: ${DELAY_DEFAULT}ms
      - binary_sensor.template.publish:
          id: nextion_init
          state: !lambda return disp1->is_setup();

      # Inform Home Assistant when Nextion is initialized
      - delay: ${DELAY_DEFAULT}ms
      - if:
          condition:
            - lambda: |-
                return is_boot_flag_set(nspanel_ha_blueprint::boot_flags, BootFlag::API);
            - lambda: return disp1->is_setup();
          then:
            - delay: ${DELAY_DEFAULT}ms
            - script.execute:
                id: boot_log
                category: Boot
                log_message: "Send `nextion_init` event to Home Assistant"
            - homeassistant.event:
                event: esphome.nspanel_ha_blueprint
                data:
                  device_name: !lambda return device_name->state.c_str();
                  esphome_version: ${version}
                  type: boot
                  step: nextion_init
      - script.execute:
          id: boot_progress
          step: 6

      # Wait for a response from the blueprint
      - if:
          condition:
            - lambda: return not is_boot_flag_set(nspanel_ha_blueprint::boot_flags, BootFlag::BLUEPRINT);
          then:
            - delay: ${DELAY_DEFAULT}ms
            - script.execute:
                id: boot_event
                init: true
            - script.execute: wait_for_blueprint
            - script.wait: wait_for_blueprint
            - if:
                condition:
                  - lambda: return is_boot_flag_set(nspanel_ha_blueprint::boot_flags, BootFlag::BLUEPRINT);
                then:
                  - delay: ${DELAY_DEFAULT}ms
                  - script.execute:
                      id: boot_progress
                      step: 7
                else:
                  - script.execute:
                      id: boot_log
                      category: Boot
                      log_message: "Blueprint not available"

      # Setup Home page
      - delay: ${DELAY_DEFAULT}ms
      - script.execute:
          id: boot_log
          category: Boot
          log_message: "Set Home page elements"

      # Chips icon size
      - delay: ${DELAY_DEFAULT}ms
      - lambda: |-
          for (uint8_t i = 1; i <= 7; ++i) {
            disp1->send_command_printf("home.chip%02d.font=%i", i, id(home_chip_font_id));
          }

      # Custom buttons icon size
      - delay: ${DELAY_DEFAULT}ms
      - lambda: |-
          for (uint8_t i = 1; i <= 7; ++i) {
            disp1->send_command_printf("home.button%02d.font=%i", i, id(home_custom_buttons_font_id));
          }

      # Other components icons size and color
      - delay: ${DELAY_DEFAULT}ms
      - lambda: |-
          disp1->set_component_font("home.bt_notific", id(home_custom_buttons_font_id));
          disp1->set_component_font("home.bt_qrcode", id(home_custom_buttons_font_id));
          disp1->set_component_font("home.bt_entities", id(home_custom_buttons_font_id));
          disp1->set_component_font("home.wifi_icon", id(home_chip_font_id));
          disp1->set_component_font_color("home.chip_relay1", id(home_relay1_icon_color));
          disp1->set_component_font_color("home.chip_relay2", id(home_relay2_icon_color));

      # Bluetooth icon
      - delay: ${DELAY_DEFAULT}ms
      - lambda: |-
          #if defined(USE_ESP32_BLE_SERVER) || defined(USE_ESP32_BLE_CLIENT) || defined(USE_BLUETOOTH_PROXY) || defined(USE_IMPROV)
          disp1->set_component_text("home.bt_icon", "\uE0AE");
          #else
          disp1->set_component_text("home.bt_icon", "");
          #endif

      # Wrap-up
      - delay: ${DELAY_DEFAULT}ms
      - script.execute:
          id: boot_progress
          step: 8
      - delay: ${DELAY_DEFAULT}ms
      - script.execute:
          id: boot_log
          category: Boot
          log_message: "Wait to finish"
      - lambda: |-
          for (uint8_t i = 0; i < 10; i++) {
            if (are_all_boot_flags_set(nspanel_ha_blueprint::boot_flags, {BootFlag::WIFI, BootFlag::API, BootFlag::BLUEPRINT}))
              break;
            delay(1000);
            App.feed_wdt();
          }
      - script.execute:
          id: boot_progress
          step: 9

      # Boot beep
      - delay: ${DELAY_DEFAULT}ms
      - if:
          condition:
            switch.is_on: notification_sound
          then:
            - script.execute:
                id: boot_log
                category: Boot
                log_message: "Play boot sound"
            - rtttl.play: "two short:d=4,o=5,b=100:16e6,16e6"

      - delay: ${DELAY_DEFAULT}ms
      - script.execute:
          id: boot_progress
          step: 10
      - delay: ${DELAY_DEFAULT}ms
      - script.execute:
          id: set_brightness
          brightness: !lambda return display_brightness->state;
      - delay: ${DELAY_DEFAULT}ms
      - script.execute:
          id: boot_log
          category: Boot
          log_message: "Jump to wake-up page"

      - delay: ${DELAY_DEFAULT}ms
      - lambda: |-
          ESP_LOGD("script.page_boot", "Jump to wake-up page: %s", wakeup_page_name->state.c_str());
      - delay: ${DELAY_DEFAULT}ms
      - script.execute:
          id: goto_page
          page: !lambda return wakeup_page_name->state.c_str();

  - id: page_buttonpage
    mode: restart
    parameters:
      page_number: uint
    then:  # There's nothing here so far
  - id: page_buttonpage01
    mode: single
    then:
      - script.execute:
          id: page_buttonpage
          page_number: 1
  - id: page_buttonpage02
    mode: single
    then:
      - script.execute:
          id: page_buttonpage
          page_number: 2
  - id: page_buttonpage03
    mode: single
    then:
      - script.execute:
          id: page_buttonpage
          page_number: 3
  - id: page_buttonpage04
    mode: single
    then:
      - script.execute:
          id: page_buttonpage
          page_number: 4

  - id: page_changed
    mode: restart
    then:
      # Report new page to logs
      - lambda: |-
          ESP_LOGD("script.page_changed", "New page: %s", current_page->state.c_str());

      # Stop if page is empty
      - if:
          condition:
            - lambda: return (current_page->state.empty());
          then:
            - script.execute:
                id: goto_page
                page: boot
            - script.stop: page_changed

      # Reset globals
      - lambda: |-
          if (current_page->state != "alarm" &&
              current_page->state != "climate" &&
              current_page->state != "cover" &&
              current_page->state != "fan" &&
              current_page->state != "light" &&
              current_page->state != "media_player" &&
              current_page->state != "confirm" &&
              current_page->state != "keyb_num") {
              detailed_entity->publish_state("");
              disp1->send_command("back_page_id=1");
          }
          if (current_page->state != "media_player") {
            id(last_volume_level) = 0;
            id(last_media_duration) = 0;
            id(last_media_position) = 0;
          }

      # Report detailed entity
      - if:
          condition:
            - lambda: return !detailed_entity->state.empty();
          then:
            - lambda: |-
                ESP_LOGD("script.page_changed", "Entity shown: %s", detailed_entity->state.c_str());

      # Update buttons bars on screen
      - script.execute:
          id: refresh_hardware_buttons_bars
          button_mask: 3

      # Reset timers
      - if:
          condition:
            not:
              text_sensor.state:
                id: current_page
                state: screensaver
          then:
            - script.execute: timer_reset_all

      # Report new page to Home Assistant
      - homeassistant.event:
          event: esphome.nspanel_ha_blueprint
          data:
            device_name: !lambda return device_name->state.c_str();
            esphome_version: ${version}
            type: page_changed
            page: !lambda return current_page->state.c_str();
            entity: !lambda return detailed_entity->state.c_str();

      # Call page constructor
      - lambda: |-
          if (current_page->state == "alarm") page_alarm->execute();
          else if (current_page->state == "blank") page_blank->execute();
          else if (current_page->state == "boot") page_boot->execute();
          else if (current_page->state == "buttonpage01") page_buttonpage01->execute();
          else if (current_page->state == "buttonpage02") page_buttonpage02->execute();
          else if (current_page->state == "buttonpage03") page_buttonpage03->execute();
          else if (current_page->state == "buttonpage04") page_buttonpage04->execute();
          else if (current_page->state == "climate") page_climate->execute();
          else if (current_page->state == "confirm") page_confirm->execute();
          else if (current_page->state == "cover") page_cover->execute();
          else if (current_page->state == "entitypage01") page_entitypage01->execute();
          else if (current_page->state == "entitypage02") page_entitypage02->execute();
          else if (current_page->state == "entitypage03") page_entitypage03->execute();
          else if (current_page->state == "entitypage04") page_entitypage04->execute();
          else if (current_page->state == "fan") page_fan->execute();
          else if (current_page->state == "home") page_home->execute();
          else if (current_page->state == "keyb_num") page_keyb_num->execute();
          else if (current_page->state == "light") page_light->execute();
          else if (current_page->state == "media_player") page_media_player->execute();
          else if (current_page->state == "notification") page_notification->execute();
          else if (current_page->state == "qrcode") page_qrcode->execute();
          else if (current_page->state == "screensaver") page_screensaver->execute();
          else if (current_page->state == "settings") page_settings->execute();
          else if (current_page->state == "utilities") page_utilities->execute();
          else if (current_page->state == "weather01") page_weather01->execute();
          else if (current_page->state == "weather02") page_weather02->execute();
          else if (current_page->state == "weather03") page_weather03->execute();
          else if (current_page->state == "weather04") page_weather04->execute();
          else if (current_page->state == "weather05") page_weather05->execute();

      # Update buttons bars on screen
      - delay: 1s
      - script.execute:
          id: refresh_hardware_buttons_bars
          button_mask: 3

  - id: page_climate
    mode: single
    then:  # There's nothing here so far

  - id: page_confirm
    mode: single
    then:
      - lambda: |-
          if (!id(is_uploading_tft))
            display_wrapped_text->execute("confirm.title", id(mui_please_confirm_global).c_str(), 15);

  - id: page_cover
    mode: single
    then:  # There's nothing here so far

  - id: page_entitypage
    mode: single
    parameters:
      page_number: uint
    then:
      - lambda: |-
          // Set value alignment
          if (current_page->state.find("entitypage") == 0 and id(page_entity_value_horizontal_alignment) != 1) {
            for (uint8_t i = 1; i <= 8; ++i) {
              disp1->send_command_printf("value%02d.xcen=%" PRIu8, i, id(page_entity_value_horizontal_alignment));
            }
          }

  - id: page_entitypage01
    mode: single
    then:
      - script.execute:
          id: page_entitypage
          page_number: 1
  - id: page_entitypage02
    mode: single
    then:
      - script.execute:
          id: page_entitypage
          page_number: 2
  - id: page_entitypage03
    mode: single
    then:
      - script.execute:
          id: page_entitypage
          page_number: 3
  - id: page_entitypage04
    mode: single
    then:
      - script.execute:
          id: page_entitypage
          page_number: 4

  - id: page_fan
    mode: single
    then:  # There's nothing here so far

  - id: page_home
    mode: single
    then:
      - script.execute:
          id: refresh_relays
          relay_mask: 3
      - script.execute: refresh_wifi_icon

  - id: page_keyb_num
    mode: single
    then:  # There's nothing here so far

  - id: page_light
    mode: single
    then:  # There's nothing here so far

  - id: page_media_player
    mode: single
    then:  # There's nothing here so far

  - id: page_notification
    mode: single
    then:
      - lambda: |-
          disp1->set_component_text("notification.notifi_label", notification_label->state.c_str());
          display_wrapped_text->execute("notification.notifi_text01", notification_text->state.c_str(), display_mode->state == 2 ? 23 : 32);

  - id: page_qrcode
    mode: single
    then:  # There's nothing here so far

  - id: page_screensaver
    mode: single
    then:
      - lambda: |-
          if (current_page->state == "screensaver" and !id(is_uploading_tft)) {
            disp1->send_command_printf("wakeup_page_id=%" PRIu8, get_page_id(wakeup_page_name->state.c_str()));
            if (id(screensaver_display_time)) {
              disp1->set_component_font("screensaver.text", id(screensaver_display_time_font));
              disp1->set_component_font_color("screensaver.text", id(screensaver_display_time_color));
              set_component_visibility->execute("screensaver.text", true);
              refresh_datetime->execute();
            }
            set_brightness->execute(display_sleep_brightness->state);
          }

  - id: page_settings
    mode: single
    then:
      - lambda: |-
          set_component_visibility->execute("page_settings.lbl_sleep", false);
          set_component_visibility->execute("page_settings.bt_sleep", false);

  - id: page_utilities
    mode: single
    then:
      - lambda: if (UtilitiesGroups == nullptr) resetUtilitiesGroups();

  - id: page_weather
    mode: single
    parameters:
      page_number: uint
    then:  # There's nothing here so far
  - id: page_weather01
    mode: single
    then:
      - script.execute:
          id: page_weather
          page_number: 1
  - id: page_weather02
    mode: single
    then:
      - script.execute:
          id: page_weather
          page_number: 2
  - id: page_weather03
    mode: single
    then:
      - script.execute:
          id: page_weather
          page_number: 3
  - id: page_weather04
    mode: single
    then:
      - script.execute:
          id: page_weather
          page_number: 4
  - id: page_weather05
    mode: single
    then:
      - script.execute:
          id: page_weather
          page_number: 5

  - id: refresh_relays
    mode: single
    parameters:
      relay_mask: uint8_t
    then:
      - if:
          condition:
            - lambda: return !id(is_uploading_tft);
          then:
            # Chip - Relay 1
            - if:
                condition:
                  - lambda: return (relay_mask & 1);
                then:
                  - lambda: |-
                      disp1->set_component_text("home.chip_relay1", (relay_1->state) ? id(home_relay1_icon) : "\uFFFF");
            # Chip - Relay 2
            - if:
                condition:
                  - lambda: return (relay_mask & 2);
                then:
                  - lambda: |-
                      disp1->set_component_text("home.chip_relay2", (relay_2->state) ? id(home_relay2_icon) : "\uFFFF");

  - id: refresh_wifi_icon
    mode: single
    then:
      - if:
          condition:
            - lambda: return !id(is_uploading_tft);
          then:
            - lambda: |-
                disp1->send_command_printf("api=%i",
                          are_all_boot_flags_set(nspanel_ha_blueprint::boot_flags, {BootFlag::WIFI, BootFlag::API, BootFlag::BLUEPRINT})
                          ? 1 : 0);
                // Update Wi-Fi icon color
                disp1->set_component_font_color("home.wifi_icon", (is_boot_flag_set(nspanel_ha_blueprint::boot_flags, BootFlag::BLUEPRINT)) ?
                                                                  (wifi_rssi->state > -70 ? 33808 : 64992) : 63488);
                // Update Wi-Fi icon
                disp1->set_component_text("home.wifi_icon",
                                          is_boot_flag_set(nspanel_ha_blueprint::boot_flags, BootFlag::WIFI) ?
                                            (is_boot_flag_set(nspanel_ha_blueprint::boot_flags, BootFlag::API) ?
                                              ((is_boot_flag_set(nspanel_ha_blueprint::boot_flags, BootFlag::BLUEPRINT)) ?
                                                "\uE5A8" :  // mdi:wifi - All right!
                                              "\uE7CF") :   // mdi:home-assistant - Blueprint is out
                                            "\uF256") :     // mdi:api-off
                                          "\uE5A9");        // mdi:wifi-off

  - id: service_call_alarm_control_panel
    mode: single
    parameters:
      entity: string
      key: string
      code_format: string
      pin: string
    then:
      - lambda: |-
          // Log code only when needed
          #if ESPHOME_LOG_LEVEL >= ESPHOME_LOG_LEVEL_VERBOSE
          static const char *const TAG = "script.service_call_alarm_control_panel";
          std::string arm_key = "alarm_control_panel.alarm_arm_" + key;
          if (key == "disarm") {
            arm_key = "alarm_control_panel.alarm_disarm";
          } else if (key == "bypass") {
            arm_key = "alarm_control_panel.alarm_arm_custom_bypass";
          }
          ESP_LOGV(TAG, "Home Assistant Action call:");
          ESP_LOGV(TAG, "  entity: %s", entity.c_str());
          ESP_LOGV(TAG, "  key: %s", key.c_str());
          ESP_LOGV(TAG, "  code_format: %s", code_format.c_str());
          ESP_LOGV(TAG, "  pin: %s", YESNO(!pin.empty()));
          ESP_LOGV(TAG, "  action: %s", arm_key.c_str());
          #endif  // ESPHOME_LOG_LEVEL > ESPHOME_LOG_LEVEL_VERBOSE

      - if:
          condition:
            - lambda: return pin.empty();
          then:
            - homeassistant.action:
                action: &alarm_control_panel_action !lambda |-
                  if (key == "disarm") return std::string("alarm_control_panel.alarm_disarm");
                  if (key == "bypass") return std::string("alarm_control_panel.alarm_arm_custom_bypass");
                  return std::string("alarm_control_panel.alarm_arm_" + key);
                data:
                  entity_id: !lambda return entity;
          else:
            - homeassistant.action:
                action: *alarm_control_panel_action
                data:
                  entity_id: !lambda return entity;
                  code: !lambda return pin;

  - id: set_baud_rate
    mode: single
    parameters:
      target_baud_rate: uint32_t
      definitive: bool
    then:
      - if:
          condition:
            - lambda: return !isnan(target_baud_rate);
          then:
            - lambda: set_boot_flag(nspanel_ha_blueprint::boot_flags, BootFlag::BAUD_RATE);
      - if:
          condition:
            - lambda: return (tf_uart->get_baud_rate() != target_baud_rate);
          then:
            - lambda: |-
                ESP_LOGD("script.set_baud_rate", "Baud rate changing from %" PRIu32 " to %" PRIu32 " bps", tf_uart->get_baud_rate(), target_baud_rate);
                ESP_LOGD("script.set_baud_rate", "Flush UART");
            - lambda: |-
                for (uint8_t i = 0; i < 5; i++) {
                  if (tf_uart->available() < 1)
                    break;
                  delay(1000);
                  App.feed_wdt();
                }
            - lambda: |-
                ESP_LOGD("script.set_baud_rate", "Sending instruction '%s=%" PRIu32 "' to Nextion", definitive ? "bauds" : "baud", target_baud_rate);
                disp1->send_command_printf("%s=%" PRIu32, definitive ? "bauds" : "baud", target_baud_rate);
                ESP_LOGD("script.set_baud_rate", "Flush UART");
            - lambda: |-
                for (uint8_t i = 0; i < 5; i++) {
                  if (tf_uart->available() < 1)
                    break;
                  delay(1000);
                  App.feed_wdt();
                }
            - lambda: |-
                ESP_LOGD("script.set_baud_rate", "Set ESPHome new baud rate to %" PRIu32 " bps", target_baud_rate);
                tf_uart->set_baud_rate(target_baud_rate);
                tf_uart->load_settings();
                ESP_LOGD("script.set_baud_rate", "Current baud rate: %" PRIu32 " bps", tf_uart->get_baud_rate());

  - id: set_brightness
    mode: single
    parameters:
      brightness: float
    then:
      - lambda: |-
          if (id(is_uploading_tft))
            return;
          disp1->set_backlight_brightness(brightness / 100.0f);
          current_brightness->update();

  - id: set_climate
    mode: single
    parameters:
      current_temp: float
      supported_features: int
      target_temp: float
      target_temp_high: float
      target_temp_low: float
      temp_step: uint
      total_steps: uint
      temp_offset: int
      climate_icon: string
      embedded_climate: bool
    then:
      - lambda: |-
          if (!id(is_uploading_tft) and current_page->state == "climate") {
            bool useDecimal = (temp_step % 10 != 0);
            char buffer[15];
            disp1->send_command_printf("climateslider.maxval=%i", total_steps);
            disp1->send_command_printf("slider_high.maxval=%i", total_steps);
            disp1->send_command_printf("slider_low.maxval=%i", total_steps);
            disp1->set_component_value("temp_offset", temp_offset);
            disp1->set_component_value("temp_step", temp_step);
            char dec_separator_str[2] = {id(mui_decimal_separator), '\0'};
            disp1->set_component_text("dec_separator", dec_separator_str);
            set_component_visibility->execute("current_temp", true);
            if (current_temp > -999) {
              snprintf(buffer, sizeof(buffer), (useDecimal) ? "%.1f°" : "%.0f°", current_temp);
              disp1->set_component_text("current_temp", adjustDecimalSeparator(buffer, id(mui_decimal_separator)).c_str());
            }
            else
              disp1->set_component_text("current_temp", id(mui_unavailable_global).c_str());

            if (target_temp > -999) {  // Target temp enabled
              disp1->set_component_value("active_slider", 0);
              snprintf(buffer, sizeof(buffer), (useDecimal) ? "%.1f°" : "%.0f°", target_temp);
              disp1->set_component_text("target_high", adjustDecimalSeparator(buffer, id(mui_decimal_separator)).c_str());
              disp1->set_component_value("climateslider", round(((10*target_temp) - temp_offset) / temp_step));
              set_component_visibility->execute("slider_high", false);
              set_component_visibility->execute("slider_low", false);
              set_component_visibility->execute("target_low", false);
              set_component_visibility->execute("target_high", true);
              set_component_visibility->execute("climateslider", true);
            } else {
              set_component_visibility->execute("climate.slider_high", false);
              if (target_temp_low > -999) {  // Target temp low enabled
                disp1->set_component_value("active_slider", 2);
                snprintf(buffer, sizeof(buffer), (useDecimal) ? "%.1f°" : "%.0f°", target_temp_low);
                disp1->set_component_text("target_low", adjustDecimalSeparator(buffer, id(mui_decimal_separator)).c_str());
                disp1->set_component_value("slider_low", round(((10*target_temp_low) - temp_offset) / temp_step));
                set_component_visibility->execute("target_low", true);
                set_component_visibility->execute("slider_low", true);
              } else {
                set_component_visibility->execute("target_low", false);
                set_component_visibility->execute("slider_low", false);
              }
              if (target_temp_high > -999) {  // Target temp high enabled
                disp1->set_component_value("active_slider", 1);
                snprintf(buffer, sizeof(buffer), (useDecimal) ? "%.1f°" : "%.0f°", target_temp_high);
                disp1->set_component_text("target_high", adjustDecimalSeparator(buffer, id(mui_decimal_separator)).c_str());
                disp1->set_component_value("slider_high", round(((10*target_temp_high) - temp_offset) / temp_step));
                set_component_visibility->execute("target_high", true);
                set_component_visibility->execute("slider_high", true);
              } else {
                set_component_visibility->execute("target_high", false);
                set_component_visibility->execute("slider_high", false);
              }
            }
            if (target_temp > -999 or target_temp_high > -999 or target_temp_low > -999) {
              disp1->set_component_text("target_icon", climate_icon.c_str());
              set_component_visibility->execute("target_icon", true);
              set_component_visibility->execute("decrease_temp", true);
              set_component_visibility->execute("increase_temp", true);
            } else {
              set_component_visibility->execute("target_icon", false);
              set_component_visibility->execute("decrease_temp", false);
              set_component_visibility->execute("increase_temp", false);
            }
            disp1->set_component_value("embedded", (embedded_climate) ? 1 : 0);
          }

  - id: set_component_visibility
    mode: queued
    max_runs: 3
    parameters:
      component_id: string
      show: bool
    then:
      - lambda: |-
          NextionComponent component = extractNextionComponent(component_id, current_page->state);
          if (component.is_current_page) disp1->send_command_printf("vis %s,%i", component.component_id, show ? 1 : 0);

  - id: !extend stop_all
    mode: single
    then:
      - script.stop: check_versions
      - script.stop: wait_for_blueprint
      - lambda: |-
          cleanupUtilitiesGroups();
          change_climate_state->stop();
          display_embedded_temp->stop();
          display_wrapped_text->stop();
          global_settings->stop();
          init_hardware_climate->stop();
          page_alarm->stop();
          page_blank->stop();
          page_boot->stop();
          page_buttonpage01->stop();
          page_buttonpage02->stop();
          page_buttonpage03->stop();
          page_buttonpage04->stop();
          page_buttonpage->stop();
          page_climate->stop();
          page_changed->stop();
          page_confirm->stop();
          page_cover->stop();
          page_entitypage01->stop();
          page_entitypage02->stop();
          page_entitypage03->stop();
          page_entitypage04->stop();
          page_entitypage->stop();
          page_fan->stop();
          page_home->stop();
          page_keyb_num->stop();
          page_light->stop();
          page_media_player->stop();
          page_notification->stop();
          page_qrcode->stop();
          page_screensaver->stop();
          page_settings->stop();
          page_utilities->stop();
          page_weather01->stop();
          page_weather02->stop();
          page_weather03->stop();
          page_weather04->stop();
          page_weather05->stop();
          page_weather->stop();
          refresh_relays->stop();
          refresh_wifi_icon->stop();
          service_call_alarm_control_panel->stop();
          set_baud_rate->stop();
          set_brightness->stop();
          set_climate->stop();
          timer_dim->stop();
          timer_page->stop();
          timer_reset_all->stop();
          timer_sleep->stop();
          update_alarm_icon->stop();
          update_climate_icon->stop();
          update_tft_info->stop();

  ###### Timers ######
  - id: timer_reset_all  # Global timer reset - Triggered with a touch on the screen
    mode: single
    then:
      - lambda: ESP_LOGV("script.timer_reset_all", "Reset timers");
      - script.execute: timer_page
      - script.execute: timer_dim
      - script.execute: timer_sleep
  - id: timer_page       # Handles the fallback to home page after a timeout
    mode: restart
    then:
      - if:
          condition:
            - lambda: |-
                return (timeout_page->state >= 1 and
                        current_page->state != "boot" and
                        current_page->state != "confirm" and
                        current_page->state != "home" and
                        current_page->state != "notification" and
                        current_page->state != "screensaver");
          then:
            - delay: !lambda return (int(timeout_page->state) *1000);
            - lambda: |-
                ESP_LOGV("script.timer_page", "Timed out on page: %s", current_page->state.c_str());
                if (timeout_page->state >= 1 and
                    current_page->state != "boot" and
                    current_page->state != "confirm" and
                    current_page->state != "home" and
                    current_page->state != "notification" and
                    current_page->state != "screensaver")
                  {
                    ESP_LOGD("script.timer_page", "Fallback to page Home");
                    goto_page->execute("home");
                  }
  - id: timer_dim        # Handles the brightness dimming after a timeout
    mode: restart
    then:
      - if:
          condition:
            - lambda: return (current_brightness->state <= display_dim_brightness->state);
            - not:
                - text_sensor.state:
                    id: current_page
                    state: screensaver
            - not:
                - text_sensor.state:
                    id: current_page
                    state: boot
          then:
            - lambda: |-
                ESP_LOGD("script.timer_dim", "Waking up on page: %s", current_page->state.c_str());
            - script.execute:
                id: set_brightness
                brightness: !lambda return int(display_brightness->state);
      - if:
          condition:
            - lambda: return (timeout_dim->state >= 1);
          then:
            - delay: !lambda return (int(timeout_dim->state) *1000);
            - if:
                condition:
                  - lambda: return (timeout_dim->state >= 1);
                  - not:
                      - text_sensor.state:
                          id: current_page
                          state: screensaver
                  - not:
                      - text_sensor.state:
                          id: current_page
                          state: boot
                then:
                  - script.execute:
                      id: set_brightness
                      brightness: !lambda return int(display_dim_brightness->state);
  - id: timer_sleep  # Handles the sleep (go to screensaver page) after a timeout
    mode: restart
    then:
      - if:
          condition:
            - lambda: |-
                return (timeout_sleep->state >= 1 and current_page->state != "screensaver" and current_page->state != "boot");
          then:
            - delay: !lambda return (int(timeout_sleep->state) *1000);
            - lambda: |-
                if (current_page->state != "screensaver" and
                    current_page->state != "boot" and
                    timeout_sleep->state >= 1) {
                  ESP_LOGD("script.timer_sleep", "Going to sleep from page %s", current_page->state.c_str());
                  goto_page->execute("screensaver");
                  set_brightness->execute(display_sleep_brightness->state);
                }

  - id: update_alarm_icon  # To do: Move to blueprint
    mode: single
    parameters:
      component: string
      state: string
    then:
      - lambda: |-
          std::string alarm_icon = "\uEECC"; //mdi:shield-alert-outline
          int alarm_color = 65535;
          if (state == "disarmed")
            {
              alarm_icon = "\uE99B"; //mdi:shield-off-outline
              alarm_color = 65535;
            }
          else if (state == "armed_home")
            {
              alarm_icon = "\uECCA"; //mdi:shield-home-outline
              alarm_color = 19818;
            }
          else if (state == "armed_away")
            {
              alarm_icon = "\uECCB"; //mdi:shield-lock-outline
              alarm_color = 19818;
            }
          else if (state == "armed_night")
            {
              alarm_icon = "\uF828"; //mdi:shield-moon-outline
              alarm_color = 19818;
            }
          else if (state == "armed_vacation")
            {
              alarm_icon = "\uECC6"; //mdi:shield-airplane-outline
              alarm_color = 19818;
            }
          else if (state == "armed_custom_bypass")
            {
              alarm_icon = "\uE77F"; //mdi:shield-half-full
              alarm_color = 19818;
            }
          else if (state == "pending" or state == "arming")
            {
              alarm_icon = "\uE498"; //mdi:shield-outline
              alarm_color = 65024;
            }
          else if (state == "disarming")
            {
              alarm_icon = "\uE99B"; //mdi:shield-off-outline
              alarm_color = 65024;
            }
          else if (state == "triggered")
            {
              alarm_icon = "\uEECC"; //mdi:shield-alert-outline
              alarm_color = 63488;
            }
          disp1->set_component_text(component.c_str(), alarm_icon.c_str());
          disp1->set_component_font_color(component.c_str(), alarm_color);

  - id: update_climate_icon
    mode: single
    parameters:
      component: string
      action: uint
      mode: uint
    then:
      - lambda: |-
          switch (action) // CLIMATE_ACTION_OFF = 0, CLIMATE_ACTION_COOLING = 2, CLIMATE_ACTION_HEATING = 3, CLIMATE_ACTION_IDLE = 4, CLIMATE_ACTION_DRYING = 5, CLIMATE_ACTION_FAN = 6
            {
              case 0: //CLIMATE_ACTION_OFF
                switch (mode) // CLIMATE_MODE_OFF = 0, CLIMATE_MODE_HEAT_COOL = 1, CLIMATE_MODE_COOL = 2, CLIMATE_MODE_HEAT = 3, CLIMATE_MODE_FAN_ONLY = 4, CLIMATE_MODE_DRY = 5, CLIMATE_MODE_AUTO = 6
                  {
                    case 0: //CLIMATE_MODE_OFF
                      disp1->set_component_text(component.c_str(), "\uFFFF"); // (E424) Don't show icon when off
                      disp1->set_component_font_color(component.c_str(), 35921); // grey (off)
                      break;
                    case 1: //CLIMATE_MODE_HEAT_COOL
                      disp1->set_component_text(component.c_str(), "\uE069"); // mdi:autorenew
                      disp1->set_component_font_color(component.c_str(), 35921); // grey (off)
                      break;
                    case 2: //CLIMATE_MODE_COOL
                      disp1->set_component_text(component.c_str(), "\uE716"); // mdi:snowflake
                      disp1->set_component_font_color(component.c_str(), 35921); // grey (off)
                      break;
                    case 3: //CLIMATE_MODE_HEAT
                      disp1->set_component_text(component.c_str(), "\uE237"); // mdi:fire
                      disp1->set_component_font_color(component.c_str(), 35921); // grey (off)
                      break;
                    case 4: //CLIMATE_MODE_FAN_ONLY
                      disp1->set_component_text(component.c_str(), "\uE20F"); // mdi:fan
                      disp1->set_component_font_color(component.c_str(), 35921); // grey (off)
                      break;
                    case 5: //CLIMATE_MODE_DRY
                      disp1->set_component_text(component.c_str(), "\uE58D"); // mdi:water-percent
                      disp1->set_component_font_color(component.c_str(), 35921); // grey (off)
                      break;
                    case 6: //CLIMATE_MODE_AUTO
                      disp1->set_component_text(component.c_str(), "\uEE8D"); // mdi:calendar-sync
                      disp1->set_component_font_color(component.c_str(), 35921); // grey (off)
                      break;
                  }
                  break;
              case 2: //CLIMATE_ACTION_COOLING
                disp1->set_component_text(component.c_str(), "\uE716"); // mdi:snowflake
                disp1->set_component_font_color(component.c_str(), 1055); // blue
                break;
              case 3: //CLIMATE_ACTION_HEATING
                disp1->set_component_text(component.c_str(), "\uE237"); // mdi:fire
                disp1->set_component_font_color(component.c_str(), 64164); // deep-orange
                break;
              case 4: //CLIMATE_ACTION_IDLE
                disp1->set_component_text(component.c_str(), "\uE50E"); // mdi:thermometer
                disp1->set_component_font_color(component.c_str(), 35921); // grey (off)
                break;
              case 5: //CLIMATE_ACTION_DRYING
                disp1->set_component_text(component.c_str(), "\uE58D"); // mdi:water-percent
                disp1->set_component_font_color(component.c_str(), 64704); // orange
                break;
              case 6: //CLIMATE_ACTION_FAN
                disp1->set_component_text(component.c_str(), "\uE20F"); // mdi:fan
                disp1->set_component_font_color(component.c_str(), 1530); // cyan
                break;
            }

  - id: update_tft_info
    mode: single
    then:
      - if:
          condition:
            - lambda: return isnan(display_charset->state);
          then:
            - lambda: display_charset->update();
      - if:
          condition:
            - lambda: return isnan(display_mode->state);
          then:
            - lambda: display_mode->update();
      - if:
          condition:
            - lambda: return version_tft->state.empty();
          then:
            - lambda: version_tft->update();

  - id: wait_for_blueprint
    mode: single
    then:
      - repeat:
          count: 120  # 120 seconds total
          then:
            - if:
                condition:
                  - lambda: return is_boot_flag_set(nspanel_ha_blueprint::boot_flags, BootFlag::BLUEPRINT);
                then:
                  - script.stop: wait_for_blueprint
            - if:
                condition:
                  - lambda: return (iteration % 5 == 1);  // Log every 5 seconds (at iterations 1, 6, 11, etc.)
                then:
                  - script.execute:
                      id: boot_log
                      category: "Boot"
                      log_message: "Waiting for Blueprint..."
            - delay: 1s
...

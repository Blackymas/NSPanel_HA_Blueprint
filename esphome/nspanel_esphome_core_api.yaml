#####################################################################################################
##### NSPANEL ESPHOME created by Blackymas - https://github.com/Blackymas/NSPanel_HA_Blueprint  #####
##### ESPHOME CORE - API                                                                        #####
##### PLEASE only make changes if it is necessary and also the required knowledge is available. #####
##### For normal use with the Blueprint, no changes are necessary.                              #####
#####################################################################################################

---
substitutions:
  ##############################
  ## Change only in your      ##
  ## local yaml substitutions ##
  ##############################
  BOOT_STEP_API: '30'
  TAG_API: nspanel.api
  EVENT_NAME: esphome.nspanel_ha_blueprint

api:
  id: api_server
  homeassistant_services: true
  reboot_timeout: 60min

  on_client_connected:
    then:
      - lambda: set_system_flag(nspanel_ha_blueprint::system_flags, NSPanelFlag::API_READY);
      - if:
          condition:
            - text_sensor.state:
                id: current_page
                state: boot
          then:
            - script.execute:
                id: boot_log
                category: API
                log_message: "Client connected"
      - script.execute: refresh_wifi_icon
      - script.execute: dump_config
  on_client_disconnected:
    then:
      - if:
          condition:
            not:
              api.connected:
          then:
            - lambda: clear_system_flag(nspanel_ha_blueprint::system_flags, NSPanelFlag::API_READY);
      - script.execute: refresh_wifi_icon

  actions:
    # Dynamically configures button properties on a specified page,
    # enhancing UI interactivity by allowing updates to button appearance and behavior based on given parameters.
    - action: button
      variables:
        page: string       # Identifier of the page where the button is located.
        id: string         # Unique identifier for the button.
        state: bool        # Determines the button's state, influencing background and other visual aspects.
        icon: string       # Icon codepoint from HASwitchPlate Material Design Icons. Example: "\uE6E8" for mdi:lightbulb-on-outline.
        icon_color: int[]  # RGB color array for the icon.
        icon_font: int     # Nextion font identifier for the icon, default is 8.
        bri: string        # Brightness level or other dynamic info to be displayed close to the icon.
        label: string      # Main text label for the button.
      then:
        - script.execute:
            id: action_button
            page: !lambda return page;
            button_id: !lambda return id;
            state: !lambda return state;
            icon: !lambda return icon;
            icon_color: !lambda return rgbTo565(icon_color);
            icon_font: !lambda return icon_font;
            bri: !lambda return bri;
            label: !lambda return label;

    # Sends custom commands directly to the display for dynamic interactions and updates.
    - action: command
      variables:
        cmd: string  # Command string to be sent. Refer to the Nextion Instruction Set for supported commands: https://nextion.tech/instruction-set/
      then:
        - if:
            condition:
              - lambda: return not is_device_ready_for_tasks(nspanel_ha_blueprint::system_flags);
            then:
              - script.execute:
                  id: report_device_not_available
                  request: action.command
            else:
              - script.execute:
                  id: send_command_with_delay
                  cmd: !lambda return cmd;
                  delay: ${DELAY_DEFAULT}

    # Changes the foreground color of a specified component on the display.
    - action: component_color
      variables:
        id: string    # Identifier of the component to change color. Ensure this matches the component's ID in your display layout.
        color: int[]  # New color for the component, specified as an RGB array (e.g., [255, 0, 0] for red).
      then:
        - if:
            condition:
              - lambda: return not is_device_ready_for_tasks(nspanel_ha_blueprint::system_flags);
            then:
              - script.execute:
                  id: report_device_not_available
                  request: action.component_color
            else:
              - script.execute:
                  id: set_component_font_color_with_delay
                  component_id: !lambda return id;
                  color: !lambda return rgbTo565(color);
                  delay: ${DELAY_DEFAULT}

    # Updates the text of a specified component on the display.
    - action: component_text
      variables:
        id: string   # Identifier of the component. Ensure it matches the component's ID in your display layout.
        txt: string  # New text content to be displayed. Supports both static and dynamic content.
      then:
        - if:
            condition:
              - lambda: return not is_device_ready_for_tasks(nspanel_ha_blueprint::system_flags);
            then:
              - script.execute:
                  id: report_device_not_available
                  request: action.component_text
            else:
              - script.execute:
                  id: set_component_text_with_delay
                  component_id: !lambda return id;
                  txt: !lambda return txt;
                  delay: ${DELAY_DEFAULT}

    # Updates the value of a specified component on the display.
    - action: component_val
      variables:
        id: string  # Identifier of the component to update. Must match the component's ID in the display layout.
        val: int    # New integer value to set for the component. Adjust based on the data type you're displaying.
      then:
        - if:
            condition:
              - lambda: return not is_device_ready_for_tasks(nspanel_ha_blueprint::system_flags);
            then:
              - script.execute:
                  id: report_device_not_available
                  request: action.component_val
            else:
              - script.execute:
                  id: set_component_value_with_delay
                  component_id: !lambda return id;
                  val: !lambda return val;
                  delay: ${DELAY_DEFAULT}

    # Hides or shows a specified component on the display.
    - action: components_visibility
      variables:
        ids: string[]  # Identifier of the component to be hidden/shown. Ensure this matches the component's ID in your display layout.
        visible: bool  # Set to true to show the component, or false to hide it.
      then:
        - if:
            condition:
              - lambda: return not is_device_ready_for_tasks(nspanel_ha_blueprint::system_flags);
            then:
              - script.execute:
                  id: report_device_not_available
                  request: action.components_visibility
            else:
              - lambda: |-
                  for (const std::string& component_id : ids) {
                    if (not component_id.empty()) {
                      set_component_visibility_with_delay->execute(component_id.c_str(), visible, ${DELAY_DEFAULT});
                    }
                  }

    # Displays detailed information for a specific entity.
    - action: entity_details_show
      variables:
        entity: string     # The ID of the entity for which details are shown. Supports "embedded_climate" for built-in climate control.
        back_page: string  # Specifies the page to return to. Accepts "home" or "buttonpage01" to "buttonpage04".
      then:
        - if:
            condition:
              - lambda: return not is_device_ready_for_tasks(nspanel_ha_blueprint::system_flags);
            then:
              - script.execute:
                  id: report_device_not_available
                  request: action.entity_details_show
            else:
              - lambda: |-
                  HomeAssistantEntity entity_id = extractHomeAssistantEntity(entity);
                  if (entity == "embedded_climate") entity_id.domain = "climate";
                  else if (entity_id.domain == "alarm_control_panel") entity_id.domain = "alarm";
                  if (entity_id.domain != "invalid" or entity == "embedded_climate") {
                    detailed_entity->publish_state(entity);
                    delay(${DELAY_DEFAULT});
                    goto_page->execute(entity_id.domain.c_str());
                    delay(${DELAY_DEFAULT});
                    disp1->send_command_printf("back_page_id=%" PRIu8, get_page_id(back_page.c_str()));
                    if (entity_id.domain == "climate")
                      delay(${DELAY_DEFAULT});
                      disp1->set_component_value("climate.embedded", (entity == "embedded_climate") ? 1 : 0);
                  }

    # Hardware Button State Indication Service
    - action: hw_button_state
      variables:
        button_mask: int  # Bitwise value for buttons: 1 for "left button", 2 for "right button", 3 for both buttons
        state: bool       # State for the button(s) indication: true for active, false for inactive
      then:
        - if:
            condition:
              - lambda: return not is_device_ready_for_tasks(nspanel_ha_blueprint::system_flags);
            then:
              - script.execute:
                  id: report_device_not_available
                  request: action.hw_button_state
            else:  # Updates the visual state indication for hardware buttons
              # Use bitwise AND to check specific bits
              - lambda: |-
                  if (button_mask & 1) // Checks if the least significant bit is set (left button)
                    update_bitwise_setting(id(buttons_settings), state, ButtonSettings::ButtonLeft_State);
                  if (button_mask & 2) // Checks if the second least significant bit is set (right button)
                    update_bitwise_setting(id(buttons_settings), state, ButtonSettings::ButtonRight_State);

              # Refreshes the indication bars on the display
              - script.execute:
                  id: refresh_hardware_buttons_bars
                  button_mask: !lambda return button_mask;

    # Icon Service
    - action: icon
      variables:
        id: string         # Identifier of the component. See "Screen components" in the documentation.
        icon: string       # Icon codepoint, e.g., "/uE6E8" for `mdi:lightbulb-on-outline`.
        icon_color: int[]  # RGB color array for the icon, e.g., [0, 255, 0] for green.
        visible: bool      # Set to `true` for visible or `false` for hidden.
      then:
        - if:
            condition:
              - lambda: return not is_device_ready_for_tasks(nspanel_ha_blueprint::system_flags);
            then:
              - script.execute:
                  id: report_device_not_available
                  request: action.icon
            else:
              - script.execute:
                  id: set_component_text_with_delay
                  component_id: !lambda return id;
                  txt: !lambda |-
                          return visible ? icon.c_str() : "";
                  delay: ${DELAY_DEFAULT}
              - if:
                  condition:
                    - lambda: return (icon_color.size() == 3);
                  then:
                    - script.execute:
                        id: set_component_font_color_with_delay
                        component_id: !lambda return id;
                        color: !lambda return rgbTo565(icon_color);
                        delay: ${DELAY_DEFAULT}
              - script.execute:
                  id: set_component_visibility_with_delay
                  component_id: !lambda return id;
                  show: !lambda return visible;
                  delay: ${DELAY_DEFAULT}

    # Transfers global settings from the blueprint to ESPHome, configuring the necessary parameters for optimal operation.
    - action: init_global
      variables:
        blueprint_version: string      # Version of the blueprint in use.
        ent_value_xcen: int            # Alignment of values on entities pages (0 for right (default), 1 for center or 2 for left).
        mui_please_confirm: string     # Localized message for confirmation prompts.
        mui_unavailable: string        # Localized message indicating unavailability.
        screensaver_time: bool         # Toggles the screensaver time display.
        screensaver_time_font: int     # Specifies the font id for the screensaver time display.
        screensaver_time_color: int[]  # RGB color for the screensaver time display, e.g., [165, 42, 42] for reddish-brown.
        decimal_separator: string      # The char to be used as decimal separator.
      then:
        - lambda: boot_log->execute("Service", "init_global");
        - if:
            condition:
              - lambda: return not is_device_ready_for_tasks(nspanel_ha_blueprint::system_flags);
            then:
              - script.execute:
                  id: report_device_not_available
                  request: action.init_global
            else:
              - delay: ${DELAY_DEFAULT}ms
              - script.execute:
                  id: global_settings
                  blueprint_version: !lambda return blueprint_version;
                  ent_value_xcen: !lambda return ent_value_xcen;
                  mui_please_confirm: !lambda return mui_please_confirm;
                  mui_unavailable: !lambda return mui_unavailable;
                  screensaver_time: !lambda return screensaver_time;
                  screensaver_time_font: !lambda return screensaver_time_font;
                  screensaver_time_color: !lambda return screensaver_time_color;
                  decimal_separator: !lambda return decimal_separator;
              - delay: ${DELAY_DEFAULT}ms
              - script.wait: global_settings
              - delay: ${DELAY_DEFAULT}ms
              - sensor.template.publish:
                  id: blueprint_status
                  state: !lambda return (int(blueprint_status->raw_state) | (1 << 5));

    # Configures NSPanel hardware (buttons, relays, etc.) settings
    - action: init_hardware
      variables:
        relay1_local_control: bool              # Enable/disable local control for Relay 1.
        relay1_icon: string                     # Icon for Relay 1 (e.g., "\uE3A5" for mdi:numeric-1-box-outline).
        relay1_icon_color: int[]                # RGB color array for Relay 1's icon.
        relay1_fallback: bool                   # Fallback state for Relay 1 in case of communication loss.
        relay2_local_control: bool              # Enable/disable local control for Relay 2.
        relay2_icon: string                     # Icon for Relay 2 (e.g., "\uE3A8" for mdi:numeric-2-box-outline).
        relay2_icon_color: int[]                # RGB color array for Relay 2's icon.
        relay2_fallback: bool                   # Fallback state for Relay 2 in case of communication loss.
        button_left: bool                       # Enable/disable left button status visualization.
        button_right: bool                      # Enable/disable right button status visualization.
        button_bar_pages: int                   # As uint representing the list of pages where the buttons bars will be visible
        button_bar_color_on: int[]              # RGB color array for the hardware button bar when the status is `On`.
        button_bar_color_off: int[]             # RGB color array for the hardware button bar when the status is `Off`.
        embedded_climate: bool                  # Indicates if climate control is integrated.
        embedded_climate_friendly_name: string  # Friendly name for the climate control feature.
        embedded_indoor_temperature: bool       # Enables indoor temperature display.
      then:
        - lambda: boot_log->execute("Service", "init_hardware");
        - if:
            condition:
              - lambda: return not is_device_ready_for_tasks(nspanel_ha_blueprint::system_flags);
            then:
              - script.execute:
                  id: report_device_not_available
                  request: action.init_hardware
            else:
              - delay: ${DELAY_DEFAULT}ms
              - script.execute:
                  id: init_hardware_climate
                  embedded_climate: !lambda return embedded_climate;
                  embedded_climate_friendly_name: !lambda return embedded_climate_friendly_name;
                  embedded_indoor_temperature: !lambda return embedded_indoor_temperature;

              # Relay settings
              - delay: ${DELAY_DEFAULT}ms
              - lambda: |-
                  using namespace esphome::display;
                  update_bitwise_setting(id(relay_settings), relay1_local_control, RelaySettings::Relay1_Local);
                  update_bitwise_setting(id(relay_settings), relay1_fallback, RelaySettings::Relay1_Fallback);
                  update_bitwise_setting(id(relay_settings), relay2_local_control, RelaySettings::Relay2_Local);
                  update_bitwise_setting(id(relay_settings), relay2_fallback, RelaySettings::Relay2_Fallback);

              # Relay icons
              - delay: ${DELAY_DEFAULT}ms
              - lambda: |-
                  using namespace esphome::display;
                  if (not relay1_icon.empty()) copyStringToCharArray(id(home_relay1_icon), relay1_icon);
                  if (not relay2_icon.empty()) copyStringToCharArray(id(home_relay2_icon), relay2_icon);

                  // Relay icon's colors
                  if (relay1_icon_color.size() == 3) {
                    id(home_relay1_icon_color) = rgbTo565(relay1_icon_color);
                    disp1->set_component_font_color("home.chip_relay1", id(home_relay1_icon_color));
                  }
                  if (relay2_icon_color.size() == 3) {
                    id(home_relay2_icon_color) = rgbTo565(relay2_icon_color);
                    disp1->set_component_font_color("home.chip_relay2", id(home_relay2_icon_color));
                  }

              # Buttons bars settings
              - delay: ${DELAY_DEFAULT}ms
              - globals.set:
                  id: buttons_bars_pages
                  value: !lambda return button_bar_pages;
              - lambda: |-
                  using namespace esphome::display;
                  update_bitwise_setting(id(buttons_settings), button_left, ButtonSettings::ButtonLeft_Enabled);
                  update_bitwise_setting(id(buttons_settings), button_right, ButtonSettings::ButtonRight_Enabled);
              - if:
                  condition:
                    - lambda: return (button_bar_color_on.size() == 3);
                  then:
                    - globals.set:
                        id: buttons_color_on
                        value: !lambda return rgbTo565(button_bar_color_on);
              - if:
                  condition:
                    - lambda: return (button_bar_color_off.size() == 3);
                  then:
                    - globals.set:
                        id: buttons_color_on
                        value: !lambda return rgbTo565(button_bar_color_off);

              # Update relays icons
              - delay: ${DELAY_DEFAULT}ms
              - script.execute:
                  id: refresh_relays
                  relay_mask: 3
              # Update buttons bars
              - delay: ${DELAY_DEFAULT}ms
              - script.execute:
                  id: refresh_hardware_buttons_bars
                  button_mask: 3
              # Update blueprint status
              - delay: ${DELAY_DEFAULT}ms
              - sensor.template.publish:
                  id: blueprint_status
                  state: !lambda return (int(blueprint_status->raw_state) | (1 << 4));

    # Sets up the "Home" page in ESPHome with customized settings and UI elements as defined in the project blueprint.
    - action: init_page_home
      variables:
        date_color: int[]                      # RGB color array for the date display.
        time_format: string                    # Time display format string, utilizing standard formatting symbols.
        time_color: int[]                      # RGB color array for the time display.
        meridiem: string[]                     # Optional array for AM/PM labels if included in time format.
        chip_font: int                         # Font Id for chip icons displayed on the "Home" page.
        custom_buttons_font: int               # Font Id for icons on custom buttons.
        qrcode: bool                           # Enable/disable flag for QR code button display.
        qrcode_icon: string                    # Icon codepoint for QR code button, sourced from HASwitchPlate Material Design Icons.
        qrcode_icon_color: int[]               # RGB color array for QR code button icon.
        entities_pages_icon: string            # Icon codepoint for entities page button, sourced from HASwitchPlate Material Design Icons.
        entities_pages_icon_color: int[]       # RGB color array for entities page button icon.
        utilities: bool                        # Enable/disable flag for utilities page button display.
        utilities_icon: string                 # Icon codepoint for utilities page button, sourced from HASwitchPlate Material Design Icons.
        utilities_icon_color: int[]            # RGB color array for utilities page button icon.
        outdoor_temp_font: int                 # Font Id for outdoor temperature indication on the "Home" page.
      then:
        - lambda: boot_log->execute("Service", "init_page_home");
        - if:
            condition:
              - lambda: return not is_device_ready_for_tasks(nspanel_ha_blueprint::system_flags);
            then:
              - script.execute:
                  id: report_device_not_available
                  request: action.init_page_home
            else:
              # Localization
              - delay: ${DELAY_DEFAULT}ms
              - globals.set:
                  id: mui_time_format
                  value: !lambda return time_format;
              - if:
                  condition:
                    - lambda: return (meridiem.size() == 2);
                  then:
                    - lambda: |-
                        id(mui_meridiem)[0] = meridiem[0];
                        id(mui_meridiem)[1] = meridiem[1];

              # Date & Time colors
              - delay: ${DELAY_DEFAULT}ms
              - globals.set:
                  id: home_date_color
                  value: !lambda return rgbTo565(date_color);
              - globals.set:
                  id: home_time_color
                  value: !lambda return rgbTo565(time_color);
              - lambda: |-
                  disp1->set_component_font_color("home.date", id(home_date_color));
                  disp1->set_component_font_color("home.time", id(home_time_color));

              # Chips icon size
              - delay: ${DELAY_DEFAULT}ms
              - lambda: |-
                  disp1->set_component_font("home.chip_relay1", chip_font);
                  disp1->set_component_font("home.chip_relay2", chip_font);
                  disp1->set_component_font("home.chip_climate", chip_font);
                  for (int i = 1; i <= 7; ++i) {
                    delay(${DELAY_DEFAULT});
                    disp1->send_command_printf("home.chip%02d.font=%" PRIi32, i, chip_font);
                  }
                  disp1->set_component_font("home.wifi_icon", chip_font);
              - globals.set:
                  id: home_chip_font_id
                  value: !lambda return chip_font;

              # Custom buttons icon size
              - delay: ${DELAY_DEFAULT}ms
              - globals.set:
                  id: home_custom_buttons_font_id
                  value: !lambda return custom_buttons_font;
              - lambda: |-
                  for (int i = 1; i <= 7; ++i) {
                    disp1->send_command_printf("home.button%02d.font=%" PRIu8, i, id(home_custom_buttons_font_id));
                    delay(${DELAY_DEFAULT});
                  }
                  disp1->set_component_font("home.bt_notific", id(home_custom_buttons_font_id));
                  disp1->set_component_font("home.bt_qrcode", id(home_custom_buttons_font_id));
                  disp1->set_component_font("home.bt_entities", id(home_custom_buttons_font_id));

              # Outdoor temperature font size
              - delay: ${DELAY_DEFAULT}ms
              - lambda: |-
                  disp1->set_component_font("home.outdoor_temp", outdoor_temp_font);

              # QRCode button
              - delay: ${DELAY_DEFAULT}ms
              - script.execute:
                  id: set_component_visibility
                  component_id: "home.bt_qrcode"
                  show: !lambda return qrcode;
              - lambda: |-
                  disp1->set_component_text("home.bt_qrcode", qrcode_icon.c_str());
                  disp1->set_component_font_color("home.bt_qrcode", rgbTo565(qrcode_icon_color));

              # Entities pages button
              - delay: ${DELAY_DEFAULT}ms
              - lambda: |-
                  disp1->set_component_text("home.bt_entities", entities_pages_icon.c_str());
                  disp1->set_component_font_color("home.bt_entities", rgbTo565(entities_pages_icon_color));

              # Utilities button
              - delay: ${DELAY_DEFAULT}ms
              - lambda: |-
                  disp1->send_command_printf("is_utilities=%i", utilities ? 1 : 0);
                  disp1->set_component_text("home.bt_utilities", utilities_icon.c_str());
                  disp1->set_component_font_color("home.bt_utilities", rgbTo565(utilities_icon_color));

              # Update blueprint status
              - delay: ${DELAY_DEFAULT}ms
              - sensor.template.publish:
                  id: blueprint_status
                  state: !lambda return (int(blueprint_status->raw_state) | (1 << 1));

    # Populates the "Settings" page with user-configurable options, aligning with the project's blueprint for a cohesive and intuitive settings interface.
    - action: init_page_settings
      variables:
        reboot: string      # Label for the reboot button, directing users on restarting the device.
        brightness: string  # Caption for brightness adjustment controls.
        bright: string      # Text label for the high brightness level slider, signaling a brighter screen option.
        dim: string         # Text label for the dim brightness level slider, signaling a lower light option for energy saving.
      then:
        - lambda: boot_log->execute("Service", "init_page_settings");
        - if:
            condition:
              - lambda: return not is_device_ready_for_tasks(nspanel_ha_blueprint::system_flags);
            then:
              - script.execute:
                  id: report_device_not_available
                  request: action.init_page_settings
            else:
              - lambda: |-
                  if (not reboot.empty()) disp1->set_component_text_printf("settings.lbl_reboot", " %s", reboot.c_str());
                  disp1->set_component_text_printf("settings.lbl_brightness", " %s", brightness.c_str());
              - delay: ${DELAY_DEFAULT}ms
              - script.execute:
                  id: display_wrapped_text
                  component: "settings.lbl_bright"
                  text_to_display: !lambda return bright;
                  line_length_limit: !lambda |-
                    return display_mode->state == 2 ? 25 : 10;
              - delay: ${DELAY_DEFAULT}ms
              - script.execute:
                  id: display_wrapped_text
                  component: "settings.lbl_dim"
                  text_to_display: !lambda return dim;
                  line_length_limit: !lambda |-
                    return display_mode->state == 2 ? 25 : 10;
              - delay: ${DELAY_DEFAULT}ms
              # Update blueprint status
              - delay: ${DELAY_DEFAULT}ms
              - sensor.template.publish:
                  id: blueprint_status
                  state: !lambda return (int(blueprint_status->raw_state) | (1 << 3));

    # This service removes any displayed notifications from the screen, helping to keep the user interface clean and focused on its primary functions.
    - action: notification_clear
      then:
        - if:
            condition:
              - lambda: return not is_device_ready_for_tasks(nspanel_ha_blueprint::system_flags);
            then:
              - script.execute:
                  id: report_device_not_available
                  request: action.notification_clear
            else:
              - if:
                  condition:
                    - text_sensor.state:
                        id: current_page
                        state: notification
                  then:
                    - script.execute:
                        id: goto_page
                        page: home
        - delay: ${DELAY_DEFAULT}ms
        - text_sensor.template.publish:
            id: notification_label
            state: ""
        - delay: ${DELAY_DEFAULT}ms
        - text_sensor.template.publish:
            id: notification_text
            state: ""
        - delay: ${DELAY_DEFAULT}ms
        - switch.turn_off: notification_unread
        - delay: ${DELAY_DEFAULT}ms
        - script.execute:
            id: set_component_visibility
            component_id: "home.bt_notific"
            show: false

    # Displays a notification message on the screen, useful for alerts or informational updates.
    - action: notification_show
      variables:
        label: string    # Title or label for the notification, displayed in a prominent format.
        message: string  # Detailed message or content of the notification. Include `\r` to insert a line break, allowing for custom formatting.
      then:
        - if:
            condition:
              - lambda: return not is_device_ready_for_tasks(nspanel_ha_blueprint::system_flags);
            then:
              - script.execute:
                  id: report_device_not_available
                  request: action.notification_show
            else:
              - script.execute:
                  id: set_component_visibility
                  component_id: "home.bt_notific"
                  show: true
              - delay: ${DELAY_DEFAULT}ms
              - script.execute:
                  id: goto_page
                  page: notification
              - delay: ${DELAY_DEFAULT}ms
              - script.execute: timer_reset_all
              - delay: ${DELAY_DEFAULT}ms
              - lambda: |-
                    disp1->set_component_text("notification.notifi_label", label.c_str());
              - delay: ${DELAY_DEFAULT}ms
              - script.execute:
                  id: display_wrapped_text
                  component: "notification.notifi_text01"
                  text_to_display: !lambda return message;
                  line_length_limit: !lambda |-
                    return display_mode->state == 2 ? 23 : 32;
              - delay: ${DELAY_DEFAULT}ms
              - text_sensor.template.publish:
                  id: notification_label
                  state: !lambda return label;
              - delay: ${DELAY_DEFAULT}ms
              - text_sensor.template.publish:
                  id: notification_text
                  state: !lambda return message;
              - delay: ${DELAY_DEFAULT}ms
              - switch.turn_on: notification_unread
              - if:
                  condition:
                    - switch.is_on: notification_sound
                  then:
                    - delay: ${DELAY_DEFAULT}ms
                    - rtttl.play: "two short:d=4,o=5,b=100:16e6,16e6"

    # Updates the alarm settings page with current state and configuration, integrating with the panel's interface.
    - action: page_alarm
      variables:
        page_title: string       # Title for the alarm settings page, displayed prominently at the top.
        state: string            # Current state of the alarm system (e.g., "armed_home", "disarmed").
        supported_features: int  # Bitmask representing the alarm system's supported features, determining available controls on the page.
        code_format: string      # Format required for the alarm code (numeric, alphanumeric).
        code_arm_required: bool  # Indicates if a code is needed to arm the system.
        entity: string           # Entity ID for the alarm system, enabling state updates and control.
        mui_alarm: string[]      # Localized text for alarm control buttons (e.g., Arm, Disarm), allowing for a multilingual interface.
      then:
        # To do: This page constructor should be moved to Blueprint
        - if:
            condition:
              - lambda: return not is_device_ready_for_tasks(nspanel_ha_blueprint::system_flags);
            then:
              - script.execute:
                  id: report_device_not_available
                  request: action.page_alarm
            else:
              - if:
                  condition:
                    - text_sensor.state:
                        id: current_page
                        state: alarm
                  then:  # Update alarm page

                    # Set detailed entity sensor
                    - text_sensor.template.publish:
                        id: detailed_entity
                        state: !lambda return entity;

                    # Page header - Icon
                    - delay: ${DELAY_DEFAULT}ms
                    - script.execute:
                        id: update_alarm_icon
                        component: "icon_state"
                        state: !lambda return state;
                    # Page header - Title
                    - lambda: |-
                        if (page_title.find("\\r") != std::string::npos) {
                          page_title = page_title.replace(page_title.find("\\r"), 2, " ");
                        }
                        disp1->set_component_text("page_label", page_title.c_str());

                    # Page - Params
                    - delay: ${DELAY_DEFAULT}ms
                    - lambda: |-
                        disp1->set_component_text("code_format", code_format.c_str());
                        disp1->set_component_text("code_arm_req", code_arm_required ? "1" : "0");

                    # Buttons - Text
                    - delay: ${DELAY_DEFAULT}ms
                    - script.execute:
                        id: display_wrapped_text
                        component: bt_away_text
                        text_to_display: !lambda return mui_alarm[1].c_str();
                        line_length_limit: 10
                    - delay: ${DELAY_DEFAULT}ms
                    - script.execute:
                        id: display_wrapped_text
                        component: bt_night_text
                        text_to_display: !lambda return mui_alarm[2].c_str();
                        line_length_limit: 10
                    - delay: ${DELAY_DEFAULT}ms
                    - script.execute:
                        id: display_wrapped_text
                        component: bt_vacat_text
                        text_to_display: !lambda return mui_alarm[3].c_str();
                        line_length_limit: 10
                    - delay: ${DELAY_DEFAULT}ms
                    - script.execute:
                        id: display_wrapped_text
                        component: bt_bypass_text
                        text_to_display: !lambda return mui_alarm[4].c_str();
                        line_length_limit: 10
                    - delay: ${DELAY_DEFAULT}ms
                    - script.execute:
                        id: display_wrapped_text
                        component: bt_disarm_text
                        text_to_display: !lambda return mui_alarm[5].c_str();
                        line_length_limit: 10

                    # Button - Home
                    - if:
                        condition:
                          - or:
                              - lambda: return (supported_features & 1);
                              - lambda: return (state == "armed_home");
                        then:
                          - delay: ${DELAY_DEFAULT}ms
                          - lambda: |-
                              const bool is_current_state = (state == "armed_home");
                              disp1->set_component_pic("bt_home_pic", is_current_state ? 43 : 42);
                              disp1->set_component_background_color("bt_home_text", is_current_state ? 19818 : 52857);
                              disp1->set_component_background_color("bt_home_icon", is_current_state ? 19818 : 52857);
                              disp1->set_component_font_color("bt_home_text", is_current_state ? 65535 : 0);
                              disp1->set_component_font_color("bt_home_icon", is_current_state ? 65535 : 0);
                              delay(${DELAY_DEFAULT});
                              set_component_visibility->execute("bt_home", not is_current_state);

                    # Button - Away
                    - if:
                        condition:
                          - or:
                              - lambda: return (supported_features & 2);
                              - lambda: return (state == "armed_away");
                        then:
                          - delay: ${DELAY_DEFAULT}ms
                          - lambda: |-
                              const bool is_current_state = (state == "armed_away");
                              disp1->set_component_pic("bt_away_pic", is_current_state ? 43 : 42);
                              disp1->set_component_background_color("bt_away_text", is_current_state ? 19818 : 52857);
                              disp1->set_component_background_color("bt_away_icon", is_current_state ? 19818 : 52857);
                              disp1->set_component_font_color("bt_away_text", is_current_state ? 65535 : 0);
                              disp1->set_component_font_color("bt_away_icon", is_current_state ? 65535 : 0);
                              delay(${DELAY_DEFAULT});
                              set_component_visibility->execute("bt_away", not is_current_state);

                    # Button - Night
                    - if:
                        condition:
                          - or:
                              - lambda: return (supported_features & 4);
                              - lambda: return (state == "armed_night");
                        then:
                          - delay: ${DELAY_DEFAULT}ms
                          - lambda: |-
                              const bool is_current_state = (state == "armed_night");
                              disp1->set_component_pic("bt_night_pic", is_current_state ? 43 : 42);
                              disp1->set_component_background_color("bt_night_text", is_current_state ? 19818 : 52857);
                              disp1->set_component_background_color("bt_night_icon", is_current_state ? 19818 : 52857);
                              disp1->set_component_font_color("bt_night_text", is_current_state ? 65535 : 0);
                              disp1->set_component_font_color("bt_night_icon", is_current_state ? 65535 : 0);
                              delay(${DELAY_DEFAULT});
                              set_component_visibility->execute("bt_night", not is_current_state);

                    # Button - Vacation
                    - if:
                        condition:
                          - or:
                              - lambda: return (supported_features & 32);
                              - lambda: return (state == "armed_vacation");
                        then:
                          - delay: ${DELAY_DEFAULT}ms
                          - lambda: |-
                              const bool is_current_state = (state == "armed_vacation");
                              disp1->set_component_pic("bt_vacat_pic", is_current_state ? 43 : 42);
                              disp1->set_component_background_color("bt_vacat_text", is_current_state ? 19818 : 52857);
                              disp1->set_component_background_color("bt_vacat_icon", is_current_state ? 19818 : 52857);
                              disp1->set_component_font_color("bt_vacat_text", is_current_state ? 65535 : 0);
                              disp1->set_component_font_color("bt_vacat_icon", is_current_state ? 65535 : 0);
                              delay(${DELAY_DEFAULT});
                              set_component_visibility->execute("bt_vacat", not is_current_state);

                    # Button - Custom bypass
                    - if:
                        condition:
                          - or:
                              - lambda: return (supported_features & 16);
                              - lambda: return (state == "armed_bypass");
                        then:
                          - delay: ${DELAY_DEFAULT}ms
                          - lambda: |-
                              const bool is_current_state = (state == "armed_bypass");
                              disp1->set_component_pic("bt_bypass_pic", is_current_state ? 43 : 42);
                              disp1->set_component_background_color("bt_bypass_text", is_current_state ? 19818 : 52857);
                              disp1->set_component_background_color("bt_bypass_icon", is_current_state ? 19818 : 52857);
                              disp1->set_component_font_color("bt_bypass_text", is_current_state ? 65535 : 0);
                              disp1->set_component_font_color("bt_bypass_icon", is_current_state ? 65535 : 0);
                              delay(${DELAY_DEFAULT});
                              set_component_visibility->execute("bt_bypass", not is_current_state);

                    # Button - Disarm
                    - delay: ${DELAY_DEFAULT}ms
                    - lambda: |-
                        const bool is_current_state = (state == "disarmed");
                        disp1->set_component_pic("bt_disarm_pic", is_current_state ? 43 : 42);
                        disp1->set_component_background_color("bt_disarm_text", is_current_state ? 19818 : 52857);
                        disp1->set_component_background_color("bt_disarm_icon", is_current_state ? 19818 : 52857);
                        disp1->set_component_font_color("bt_disarm_text", is_current_state ? 65535 : 0);
                        disp1->set_component_font_color("bt_disarm_icon", is_current_state ? 65535 : 0);
                        delay(${DELAY_DEFAULT});
                        set_component_visibility->execute("bt_disarm", not is_current_state);

    # Dynamically updates the climate page with the latest climate control settings and status.
    - action: page_climate
      variables:
        current_temp: float      # Current temperature reading.
        supported_features: int  # Bitmask indicating the supported features of the climate device, such as temperature control (1) and fan mode (4).
        target_temp: float       # Desired target temperature setting.
        target_temp_high: float  # Upper limit of the target temperature range for devices supporting ranges.
        target_temp_low: float   # Lower limit of the target temperature range.
        temp_step: int           # Temperature adjustment step size, indicating the granularity of changes (multiplied by 10 for precision).
        total_steps: int         # Total adjustment steps available, derived from the device's temperature range and step size.
        temp_offset: int         # Calibration offset applied to the temperature reading (multiplied by 10 for precision).
        climate_icon: string     # Icon codepoint representing the current climate status, chosen from HASwitchPlate Material Design Icons.
        embedded_climate: bool   # Indicates if climate control is integrated into the interface.
        entity: string           # Entity ID of the climate device, allowing for direct control and status updates.
      then:
        - if:
            condition:
              - lambda: return not is_device_ready_for_tasks(nspanel_ha_blueprint::system_flags);
            then:
              - script.execute:
                  id: report_device_not_available
                  request: action.page_climate
            else:
              - if:
                  condition:
                    - text_sensor.state:
                        id: current_page
                        state: climate
                  then:  # Update climate page
                    # Set detailed entity sensor
                    - text_sensor.template.publish:
                        id: detailed_entity
                        state: !lambda return entity;
              - script.execute:
                  id: set_climate
                  current_temp: !lambda return current_temp;
                  supported_features: !lambda return supported_features;
                  target_temp: !lambda return target_temp;
                  target_temp_high: !lambda return target_temp_high;
                  target_temp_low: !lambda return target_temp_low;
                  temp_step: !lambda return temp_step;
                  total_steps: !lambda return total_steps;
                  temp_offset: !lambda return temp_offset;
                  climate_icon: !lambda return climate_icon;
                  embedded_climate: !lambda return embedded_climate;

    # Dynamically updates the media player page with current state and media information.
    - action: page_media_player
      variables:
        entity: string               # Entity ID of the media player, used for state updates and control.
        state: string                # Current playback state of the media player (e.g., "playing", "paused", "stopped").
        is_volume_muted: bool        # Indicates if the media volume is currently muted.
        friendly_name: string        # Display name of the media player, shown as the page title.
        volume_level: int            # Current volume level, typically expressed as a percentage.
        media_title: string          # Title of the currently playing media.
        media_artist: string         # Artist of the currently playing media.
        media_duration: float        # Total duration of the current media in seconds.
        media_position: float        # Current playback position in the media in seconds.
        media_position_delta: float  # Time elapsed since the last media position update in seconds.
        supported_features: int      # Bitmask indicating the media player's supported features (e.g., play, pause, volume control).
      then:
        - if:
            condition:
              - lambda: return not is_device_ready_for_tasks(nspanel_ha_blueprint::system_flags);
            then:
              - script.execute:
                  id: report_device_not_available
                  request: action.page_media_player
            else:
              - if:
                  condition:
                    - text_sensor.state:
                        id: current_page
                        state: media_player
                  then:  # Update media_player page
                    # Set detailed entity sensor
                    - text_sensor.template.publish:
                        id: detailed_entity
                        state: !lambda return entity;

                    # Page header
                    - delay: ${DELAY_DEFAULT}ms
                    - lambda: |-
                        disp1->set_component_text("page_label", friendly_name.c_str());

                    # Media title
                    - delay: ${DELAY_DEFAULT}ms
                    - script.execute:
                        id: display_wrapped_text
                        component: track
                        text_to_display: !lambda return media_title;
                        line_length_limit: !lambda |-
                                              return display_mode->state == 2 ? 16 : 27;

                    # Media artist
                    - delay: ${DELAY_DEFAULT}ms
                    - script.execute:
                        id: display_wrapped_text
                        component: artist
                        text_to_display: !lambda return media_artist;
                        line_length_limit: !lambda |-
                                              return display_mode->state == 2 ? 26 : 40;

                    # Button - ON/OFF
                    - delay: ${DELAY_DEFAULT}ms
                    - lambda: |-
                        if (supported_features & 128 and state == "off") {  //TURN_ON
                          disp1->set_component_foreground_color("bt_on_off", 65535);
                          set_component_visibility->execute("bt_on_off", true);
                        } else if (supported_features & 256 and state != "off") {  //TURN_OFF
                          disp1->set_component_foreground_color("bt_on_off", 10597);
                          set_component_visibility->execute("bt_on_off", true);
                        } else
                          set_component_visibility->execute("bt_on_off", false);

                    # Button - Play/Pause
                    - delay: ${DELAY_DEFAULT}ms
                    - lambda: |-
                        if ((supported_features & 512 or supported_features & 16384) and state != "playing" and state != "off") {  //PLAY_MEDIA+PLAY
                          disp1->set_component_text("bt_play_pause", "\uE409"); // mdi:play
                          set_component_visibility->execute("bt_play_pause", true);
                        } else if (supported_features & 1 and state == "playing" ) {  //PAUSE
                          disp1->set_component_text("bt_play_pause", "\uE3E3"); // mdi:pause
                          set_component_visibility->execute("bt_play_pause", true);
                        } else
                          set_component_visibility->execute("bt_play_pause", false);

                    # Button - Previous track
                    - delay: ${DELAY_DEFAULT}ms
                    - script.execute:
                        id: set_component_visibility
                        component_id: bt_prev
                        show: !lambda return (supported_features & 16 and state != "off");

                    # Button - Next track
                    - delay: ${DELAY_DEFAULT}ms
                    - script.execute:
                        id: set_component_visibility
                        component_id: bt_next
                        show: !lambda return (supported_features & 32 and state != "off");

                    # Button - Stop
                    - delay: ${DELAY_DEFAULT}ms
                    - script.execute:
                        id: set_component_visibility
                        component_id: bt_stop
                        show: !lambda return (supported_features & 4096 and (state == "playing" or state == "paused"));

                    # Button - Mute/Unmute
                    - delay: ${DELAY_DEFAULT}ms
                    - lambda: |-
                        disp1->set_component_value("is_muted", is_volume_muted ? 1 : 0);
                        if (supported_features & 8 and is_volume_muted) {  // unmute
                          disp1->set_component_text("bt_mute", "\uEE07"); // mdi:volume-variant-off
                          set_component_visibility->execute("bt_mute", true);
                        } else if (supported_features & 8) {  // mute
                          disp1->set_component_text("bt_mute", "\uE57E"); // mdi:volume-low
                          set_component_visibility->execute("bt_mute", true);
                        } else
                          set_component_visibility->execute("bt_mute", false);

                    # Volume set
                    - delay: ${DELAY_DEFAULT}ms
                    - if:
                        condition:
                          - lambda: return (supported_features & 4);
                        then:
                          - if:
                              condition:
                                - lambda: return (volume_level != id(last_volume_level));
                              then:
                                - globals.set:
                                    id: last_volume_level
                                    value: !lambda return volume_level;
                                - lambda: |-
                                    disp1->set_component_text_printf("vol_text", "%" PRIu32 "%%", volume_level);
                                    disp1->set_component_value("vol_slider", volume_level);
                          - delay: ${DELAY_DEFAULT}ms
                          - script.execute:
                              id: set_component_visibility
                              component_id: vol_slider
                              show: true
                          - delay: ${DELAY_DEFAULT}ms
                          - script.execute:
                              id: set_component_visibility
                              component_id: bt_vol_down
                              show: true
                          - delay: ${DELAY_DEFAULT}ms
                          - script.execute:
                              id: set_component_visibility
                              component_id: bt_vol_up
                              show: true
                          - delay: ${DELAY_DEFAULT}ms
                          - script.execute:
                              id: set_component_visibility
                              component_id: vol_text
                              show: true
                        else:
                          - delay: ${DELAY_DEFAULT}ms
                          - script.execute:
                              id: set_component_visibility
                              component_id: vol_slider
                              show: false
                          - delay: ${DELAY_DEFAULT}ms
                          - script.execute:
                              id: set_component_visibility
                              component_id: bt_vol_down
                              show: false
                          - delay: ${DELAY_DEFAULT}ms
                          - script.execute:
                              id: set_component_visibility
                              component_id: bt_vol_up
                              show: false
                          - delay: ${DELAY_DEFAULT}ms
                          - script.execute:
                              id: set_component_visibility
                              component_id: vol_text
                              show: false

                    # Media progress bar
                    - if:
                        condition:
                          - lambda: return (media_duration > 0);
                        then:
                          - delay: ${DELAY_DEFAULT}ms
                          - if:
                              condition:
                                - or:
                                    - lambda: return (media_duration != id(last_media_duration));
                                    - lambda: return (media_position != id(last_media_position));
                              then:
                                - globals.set:
                                    id: last_media_duration
                                    value: !lambda return media_duration;
                                - globals.set:
                                    id: last_media_position
                                    value: !lambda return media_position;
                                - lambda: |-
                                    disp1->set_component_value("prg_current", int(round(min(media_position + media_position_delta, media_duration))));
                          - delay: ${DELAY_DEFAULT}ms
                          - lambda: |-
                              disp1->set_component_value("prg_total", int(round(media_duration)));
                              disp1->send_command_printf("prg_timer.en=%i", (state == "playing") ? 1 : 0);
                          - delay: ${DELAY_DEFAULT}ms
                          - script.execute:
                              id: set_component_visibility
                              component_id: time_current
                              show: true
                          - delay: ${DELAY_DEFAULT}ms
                          - script.execute:
                              id: set_component_visibility
                              component_id: time_total
                              show: true
                          - delay: ${DELAY_DEFAULT}ms
                          - script.execute:
                              id: set_component_visibility
                              component_id: time_progress
                              show: true
                        else:
                          - delay: ${DELAY_DEFAULT}ms
                          - lambda: |-
                              disp1->send_command("prg_timer.en=0");
                          - delay: ${DELAY_DEFAULT}ms
                          - script.execute:
                              id: set_component_visibility
                              component_id: time_current
                              show: false
                          - delay: ${DELAY_DEFAULT}ms
                          - script.execute:
                              id: set_component_visibility
                              component_id: time_total
                              show: false
                          - delay: ${DELAY_DEFAULT}ms
                          - script.execute:
                              id: set_component_visibility
                              component_id: time_progress
                              show: false

    # Dynamically displays QR codes on the ESPHome UI for sharing information such as WiFi passwords or website links.
    - action: qrcode
      variables:
        title: string   # Heading or title for the QR code, offering context or instructions.
        qrcode: string  # Data or URL to be encoded into the QR code.
        show: bool      # Flag to immediately display the QR code page upon service invocation.
      then:
        - if:
            condition:
              - lambda: return not is_device_ready_for_tasks(nspanel_ha_blueprint::system_flags);
            then:
              - script.execute:
                  id: report_device_not_available
                  request: action.qrcode
            else:
              - script.execute:
                  id: set_component_visibility
                  component_id: "home.bt_qrcode"
                  show: !lambda return !(qrcode.empty());
              - lambda: |-
                  disp1->set_component_text("qrcode.qrcode_label", title.c_str());
                  disp1->set_component_text("qrcode.qrcode_value", qrcode.c_str());
              - if:
                  condition:
                    - lambda: return show;
                  then:
                    - script.execute:
                        id: goto_page
                        page: qrcode

              # Update blueprint status
              - delay: ${DELAY_DEFAULT}ms
              - sensor.template.publish:
                  id: blueprint_status
                  state: !lambda return (int(blueprint_status->raw_state) | (1 << 2));

    # Plays melodies encoded in RTTTL format, suitable for audio feedback, notifications, or simple tunes.
    - action: rtttl_play
      variables:
        tone: string  # The RTTTL string for the melody to be played. It should follow the RTTTL format, including the melody's name, default settings, and a sequence of notes.
      then:
        - if:
            condition:
              - lambda: return not is_device_ready_for_tasks(nspanel_ha_blueprint::system_flags);
            then:
              - script.execute:
                  id: report_device_not_available
                  request: action.rtttl_play
            else:
              - rtttl.play: !lambda return tone;

    - action: set_bool
      variables:
        component: string
        val: bool
      then:
        - if:
            condition:
              - lambda: return (component == "is_climate");
            then:
              - globals.set:
                  id: is_climate
                  value: !lambda return val;

    - action: set_int
      variables:
        component: string
        val: int
      then:
        - if:
            condition:
              - lambda: return (component == "bytes_per_char");
            then:
              - globals.set:
                  id: mui_bytes_per_char
                  value: !lambda return val;

    - action: set_string
      variables:
        component: string
        val: string
      then:
        - if:
            condition:
              - lambda: return (component == "timezone");
            then:
              - script.execute:
                  id: set_timezone
                  timezone: !lambda return val;

    - action: set_timezone  # To do: Merge this on another init service for v4.4.0
      variables:
        timezone: string
      then:
        - script.execute:
            id: set_timezone
            timezone: !lambda return timezone;

    # Utilities group refresh
    - action: utilities_group_refresh
      variables:
        group_id: string
        value1: string
        value2: string
        direction: int
        constructor: bool
      then:
        - if:
            condition:
              - lambda: return not is_device_ready_for_tasks(nspanel_ha_blueprint::system_flags);
            then:
              - script.execute:
                  id: report_device_not_available
                  request: action.utilities_group_refresh
            else:
              - if:
                  condition:
                    - lambda: return group_id.empty();
                  then:
                    - lambda: ESP_LOGW("${TAG_API}", "`group_id` is empty");
                  else:
                    - lambda: |-
                        uint8_t id = findUtilitiesGroupIndex(group_id.c_str());
                        if (id != UINT8_MAX) {
                          // Update Value 1
                          if (!value1.empty() and
                              (constructor or strcmp(value1.c_str(), UtilitiesGroups[id].value1) != 0)) {
                            copyStringToCharArray(UtilitiesGroups[id].value1, value1);
                            disp1->set_component_text(group_id.c_str(), value1.c_str());
                            delay(${DELAY_DEFAULT});
                          }

                          // Update Value 2
                          if (!value2.empty() and
                              (constructor or strcmp(value2.c_str(), UtilitiesGroups[id].value2) != 0)) {
                            copyStringToCharArray(UtilitiesGroups[id].value2, value2);
                            disp1->set_component_text((group_id + "b").c_str(), value2.c_str());
                            delay(${DELAY_DEFAULT});
                          }

                          // Update direction
                          if (group_id != "grid" and !isnan(direction) and
                              (constructor or direction != UtilitiesGroups[id].direction)) {
                            UtilitiesGroups[id].direction = direction;
                            disp1->set_component_value((group_id + "_line_d").c_str(), direction);
                            delay(${DELAY_DEFAULT});
                          }
                        }

    # Updates an entity to display specific values with dynamic icons, names, and color codes.
    - action: value
      variables:
        id: string          # Identifier of the entity. See "Screen components" for entity IDs.
        icon: string        # Icon codepoint (e.g., "/uE6E8" for mdi:thermometer) from HASwitchPlate Material Design Icons.
        icon_color: int[]   # RGB color array for the icon (e.g., [255, 0, 0] for red).
        name: string        # Display name for the entity (e.g., "Temperature").
        value: string       # Actual value to display (e.g., "75F").
        value_color: int[]  # RGB color array for the value text (e.g., [255, 255, 0] for yellow).
      then:
        - if:
            condition:
              - lambda: return not is_device_ready_for_tasks(nspanel_ha_blueprint::system_flags);
            then:
              - script.execute:
                  id: report_device_not_available
                  request: action.value
            else:
              - if:
                  condition:
                    - lambda: return id.empty();
                  then:
                    - lambda: ESP_LOGW("${TAG_API}", "`id` is empty");
                  else:
                    # Icon
                    - if:
                        condition:
                          - lambda: return !(icon.empty());
                        then:
                          - script.execute:
                              id: set_component_text_with_delay
                              component_id: !lambda return (id + "_icon").c_str();
                              txt: !lambda return icon;
                              delay: ${DELAY_DEFAULT}

                    # Icon color
                    - if:
                        condition:
                          - lambda: return (icon_color.size() == 3);
                        then:
                          - script.execute:
                              id: set_component_font_color_with_delay
                              component_id: !lambda return (id + "_icon").c_str();
                              color: !lambda return rgbTo565(icon_color);
                              delay: ${DELAY_DEFAULT}

                    # Label
                    - if:
                        condition:
                          - lambda: return (!(name.empty()));
                        then:
                          - script.execute:
                              id: set_component_text_with_delay
                              component_id: !lambda return (id + "_label").c_str();
                              txt: !lambda return name;
                              delay: ${DELAY_DEFAULT}

                    # Value
                    - if:
                        condition:
                          - lambda: return (!(value.empty()));
                        then:
                          - script.execute:
                              id: set_component_text_with_delay
                              component_id: !lambda return id;
                              txt: !lambda return adjustDecimalSeparator(value, id(mui_decimal_separator));
                              delay: ${DELAY_DEFAULT}

                    # Value color
                    - if:
                        condition:
                          - lambda: return (value_color.size() == 3);
                        then:
                          - script.execute:
                              id: set_component_font_color_with_delay
                              component_id: !lambda return id;
                              color: !lambda return rgbTo565(value_color);
                              delay: ${DELAY_DEFAULT}

                    # Value font
                    - if:
                        condition:
                          - lambda: return !(value.empty());
                          - lambda: return (current_page->state.find("entitypage") == 0);
                        then:
                          - lambda: |-
                              // Adjusted length starts at 0
                              float adjusted_length = 0.0;

                              // Iterate over each character in the string
                              for (char const &c: value) {
                                // Check if character is a space or other specified exceptions
                                if (display_charset->state == 2 or std::string(" iljtIf'-,;:!.\"|()[]{}").find(c) != std::string::npos) {
                                  adjusted_length += 0.5; // Count these as half
                                } else {
                                  adjusted_length += 1.0; // Count all other characters as 1
                                }
                              }

                              // Decide which font to use based on adjusted length
                              if (adjusted_length > 8.0 and adjusted_length <= 12.0) {
                                set_component_font_with_delay->execute(id.c_str(), 1, ${DELAY_DEFAULT});
                              } else if (adjusted_length > 12.0) {
                                set_component_font_with_delay->execute(id.c_str(), 0, ${DELAY_DEFAULT});
                              }

    # Wake Up Service
    - action: wake_up
      variables:
        reset_timer: bool  # Determines whether to reset the sleep and dimming timers upon waking the display.
      then:
        - if:
            condition:
              - lambda: return not is_device_ready_for_tasks(nspanel_ha_blueprint::system_flags);
            then:
              - script.execute:
                  id: report_device_not_available
                  request: action.wake_up
            else:
              - if:
                  condition:
                    - text_sensor.state:
                        id: current_page
                        state: screensaver
                  then:
                    - script.execute:
                        id: goto_page
                        page: !lambda return wakeup_page_name->state;
              - if:
                  condition:
                    - lambda: return reset_timer;
                  then:
                    - script.execute: timer_reset_all
                  else:
                    - script.execute: timer_sleep
                    - script.execute: timer_dim

esphome:
  platformio_options:
    build_flags:
      - -D NSPANEL_HA_BLUEPRINT_CORE_API

script:
  - id: action_button
    mode: queued
    max_runs: 20
    parameters:
      page: string          # Identifier of the page where the button is located.
      button_id: string     # Unique identifier for the button.
      state: bool           # Determines the button's state, influencing background and other visual aspects.
      icon: string          # Icon codepoint from HASwitchPlate Material Design Icons. Example: "\uE6E8" for mdi:lightbulb-on-outline.
      icon_color: uint16_t  # RGB color for the icon.
      icon_font: int        # Nextion font identifier for the icon, default is 8.
      bri: string           # Brightness level or other dynamic info to be displayed close to the icon.
      label: string         # Main text label for the button.
    then:
      - lambda: |-
          ESP_LOGV("${TAG_API}", "Action `button` triggered:");
          ESP_LOGV("${TAG_API}", "  page: %s", page.c_str());
          ESP_LOGV("${TAG_API}", "  id: %s", button_id.c_str());
          ESP_LOGV("${TAG_API}", "  state: %s", ONOFF(state));
          ESP_LOGV("${TAG_API}", "  icon_color: %" PRIu16, icon_color);
          ESP_LOGV("${TAG_API}", "  icon_font: %i", icon_font);
          ESP_LOGV("${TAG_API}", "  bri: %s", bri.c_str());
          ESP_LOGV("${TAG_API}", "  label: %s", label.c_str());
      - if:
          condition:
            - lambda: return not is_device_ready_for_tasks(nspanel_ha_blueprint::system_flags);
          then:
            - script.execute:
                id: report_device_not_available
                request: action.button
            - script.stop: action_button
          else:
            - if:
                condition:
                  - lambda: return (page != current_page->state);
                then:
                  - lambda: |-
                      ESP_LOGD("${TAG_API}", "Page '%s' visible while '%s' was expected", current_page->state.c_str(), page.c_str());
                  - script.stop: action_button
                else:
                  - lambda: |-
                      disp1->set_component_picc((button_id + "pic").c_str(), state ? 47 : 46);
                      disp1->set_component_picc((button_id + "bri").c_str(), state ? 47 : 46);
                      disp1->set_component_picc((button_id + "text").c_str(), state ? 47 : 46);
                      disp1->set_component_picc((button_id + "icon").c_str(), state ? 47 : 46);
                      disp1->set_component_font((button_id + "icon").c_str(), icon_font);
                      disp1->set_component_foreground_color((button_id + "bri").c_str(), state ? 10597 : 65535);
                      disp1->set_component_foreground_color((button_id + "text").c_str(), state ? 10597 : 65535);
                      disp1->set_component_font_color((button_id + "icon").c_str(), icon_color);
                      disp1->set_component_text((button_id + "icon").c_str(), icon.c_str());
                  - delay: ${DELAY_DEFAULT}ms
                  - script.execute:
                      id: display_wrapped_text
                      component: !lambda return (button_id + "text");
                      text_to_display: !lambda return label;
                      line_length_limit: 10
                  - delay: ${DELAY_DEFAULT}ms
                  - lambda: |-
                      disp1->set_component_text((button_id + "bri").c_str(), (strcmp(bri.c_str(), "0") == 0) ? " " : bri.c_str());
                  - delay: ${DELAY_DEFAULT}ms
                  - script.execute:
                      id: set_component_visibility
                      component_id: !lambda return (button_id + "pic");
                      show: true
                  - script.execute:
                      id: set_component_visibility
                      component_id: !lambda return (button_id + "icon");
                      show: true
                  - script.execute:
                      id: set_component_visibility
                      component_id: !lambda return (button_id + "text");
                      show: true
                  - script.execute:
                      id: set_component_visibility
                      component_id: !lambda return (button_id + "bri");
                      show: true
                  - script.execute:
                      id: set_component_visibility
                      component_id: !lambda return button_id;
                      show: true

  - id: !extend dump_config
    then:
      - if:
          condition:
            - lambda: return !is_device_ready_for_tasks(nspanel_ha_blueprint::system_flags);
          then:
            # Report API status
            - if:
                condition:
                  - api.connected:
                then:
                  - lambda: |-
                      ESP_LOGCONFIG("${TAG_API}", "API: Connected");
                else:
                  - lambda: |-
                      ESP_LOGW("${TAG_API}", "API: DISCONNECTED");

  - id: ha_button
    mode: parallel
    parameters:
      page: string
      component: string
      command: string
    then:
      - script.execute: timer_reset_all
      - homeassistant.event:
          event: esphome.nspanel_ha_blueprint
          data:
            device_name: !lambda return device_name->state.c_str();
            esphome_version: ${version}
            type: button_click
            page: !lambda return page;
            component: !lambda return component;
            command: !lambda return command;

  - id: ha_call_action
    mode: restart
    parameters:
      service: string
      key: string
      value: string
      entity: string
    then:
      - if:
          condition:
            - lambda: return !is_device_ready_for_tasks(nspanel_ha_blueprint::system_flags);
            - lambda: return !service.empty();
          then:
            - homeassistant.event:
                event: esphome.nspanel_ha_blueprint
                data:
                  device_name: !lambda return device_name->state.c_str();
                  esphome_version: ${version}
                  type: service_call
                  service: !lambda return service;
                  key: !lambda return key;
                  value: !lambda return value;
                  entity: !lambda return entity;

  - id: !extend page_constructors_stop
    then:
      - script.stop: action_button

  - id: send_command_with_delay
    mode: queued
    max_runs: 16
    parameters:
      cmd: string
      delay: uint16_t
    then:
      - delay: !lambda return delay;
      - lambda: |-
          disp1->send_command(cmd.c_str());

  - id: set_component_font_with_delay
    mode: queued
    max_runs: 16
    parameters:
      component_id: string
      font_id: uint8_t
      delay: uint16_t
    then:
      - delay: !lambda return delay;
      - lambda: |-
          disp1->set_component_font(component_id.c_str(), font_id);

  - id: set_component_font_color_with_delay
    mode: queued
    max_runs: 16
    parameters:
      component_id: string
      color: uint16_t
      delay: uint16_t
    then:
      - delay: !lambda return delay;
      - lambda: |-
          disp1->set_component_font_color(component_id.c_str(), color);

  - id: set_component_text_with_delay
    mode: queued
    max_runs: 16
    parameters:
      component_id: string
      txt: string
      delay: uint16_t
    then:
      - delay: !lambda return delay;
      - lambda: |-
          disp1->set_component_text(component_id.c_str(), txt.c_str());

  - id: set_component_value_with_delay
    mode: queued
    max_runs: 16
    parameters:
      component_id: string
      val: int
      delay: uint16_t
    then:
      - delay: !lambda return delay;
      - lambda: |-
          disp1->set_component_value(component_id.c_str(), val);

  - id: !extend stop_all
    then:
      - script.stop: ha_button
      - script.stop: ha_call_action
      - script.stop: send_command_with_delay
      - script.stop: set_component_font_with_delay
      - script.stop: set_component_font_color_with_delay
      - script.stop: set_component_text_with_delay
      - script.stop: set_component_value_with_delay
...

#####################################################################################################
##### NSPANEL ESPHOME created by Blackymas - https://github.com/Blackymas/NSPanel_HA_Blueprint  #####
##### ESPHOME CORE - BOOT                                                                       #####
##### PLEASE only make changes if it is necessary and also the required knowledge is available. #####
##### For normal use with the Blueprint, no changes are necessary.                              #####
#####################################################################################################

---
substitutions:
  ##############################
  ## Change only in your      ##
  ## local yaml substitutions ##
  ##############################
  BOOT_STEP_BOOT: 1
  TAG_BOOT: nspanel.boot

display:
  - id: !extend disp1
    on_setup:
      then:
        - script.execute: watchdog_round

esphome:
  platformio_options:
    build_flags:
      - -D NSPANEL_HA_BLUEPRINT_BOOT

script:
  - id: boot
    mode: single
    then:  # Other packages will subscribe themselves to this to run after critical components and early routines
      - lambda: |-
          ESP_LOGI("TAG_BOOT", "Starting boot sequence");
          blueprint_status_flags = 0;
      - script.execute: wait_to_be_ready
      - script.execute: boot_preparation
      - script.execute: boot_critical_components
      - script.wait: boot_critical_components
      - script.execute: boot_early_routines
      - script.wait: boot_early_routines

      - delay: 1s
      # This should be moved somewhere else
      - script.execute:
          id: boot_log
          category: Boot
          log_message: "Starting sequence"
      - delay: ${DELAY_DEFAULT}ms
      - script.execute:
          id: boot_progress
          step: 0
      - delay: ${DELAY_DEFAULT}ms
      - script.execute:
          id: boot_progress
          step: 1
      - delay: ${DELAY_DEFAULT}ms
      - script.execute:
          id: boot_progress
          step: 2
      - delay: ${DELAY_DEFAULT}ms
      - script.execute:
          id: boot_log
          category: Boot
          log_message: "Waiting for Wi-Fi"
      - delay: ${DELAY_DEFAULT}ms
      - script.execute: wait_for_wifi
      - script.wait: wait_for_wifi
      - if:
          condition:
            - lambda: |-
                return !(system_flags & NSPanelFlag::WIFI_READY);
          then:
            - script.execute:
                id: boot_log
                category: Boot
                log_message: "Wi-Fi not available"
          else:  # Wi-Fi connected
            - script.execute:
                id: boot_log
                category: Boot
                log_message: "Wi-Fi connected"
            - delay: ${DELAY_DEFAULT}ms
            - script.execute:
                id: boot_progress
                step: 3
            - if:
                condition:
                  - lambda: return current_page_id == ${PAGE_BOOT_ID};
                then:
                  - delay: ${DELAY_DEFAULT}ms
                  - lambda: |-
                      disp1->set_component_text_printf("sys_ip", "IP: %s",
                                                        network::get_ip_addresses()[0].str().c_str());
            - script.execute: wait_for_api
            - script.wait: wait_for_api
            - if:
                condition:
                  - lambda: |-
                      return !(system_flags & NSPanelFlag::API_READY);
                then:
                  - delay: ${DELAY_DEFAULT}ms
                  - script.execute:
                      id: boot_log
                      category: Boot
                      log_message: "API not available"
                else:  # API connected
                  - delay: ${DELAY_DEFAULT}ms
                  - script.execute:
                      id: boot_log
                      category: Boot
                      log_message: "API connected"
                  - script.execute:
                      id: boot_progress
                      step: 4

      # Display settings
      - delay: ${DELAY_DEFAULT}ms
      - script.execute:
          id: boot_log
          category: Boot
          log_message: "Sending display settings"
      - delay: ${DELAY_DEFAULT}ms
      - lambda: |-
          disp1->send_command_printf("brightness=%i", int(display_brightness->state));
          disp1->set_component_value("settings.brightslider", int(display_brightness->state));
          disp1->send_command_printf("brightness_dim=%i", int(display_dim_brightness->state));
          disp1->set_component_value("settings.dimslider", int(display_dim_brightness->state));
          disp1->send_command_printf("brightness_sleep=%i", int(display_sleep_brightness->state));
          disp1->send_command_printf("wakeup_page_id=%" PRIu8, get_page_id(wakeup_page_name->state.c_str()));
      - delay: ${DELAY_DEFAULT}ms
      - script.execute:
          id: boot_progress
          step: 5

      # Publish Nextion state
      - delay: ${DELAY_DEFAULT}ms
      - script.execute:
          id: boot_log
          category: Boot
          log_message: "Publish Nextion state"
      - delay: ${DELAY_DEFAULT}ms
      - binary_sensor.template.publish:
          id: nextion_init
          state: !lambda return disp1->is_setup();

      # Inform Home Assistant when Nextion is initialized
      - delay: ${DELAY_DEFAULT}ms
      - if:
          condition:
            - lambda: |-
                return system_flags & NSPanelFlag::API_READY;
            - lambda: return disp1->is_setup();
          then:
            - delay: ${DELAY_DEFAULT}ms
            - script.execute:
                id: boot_log
                category: Boot
                log_message: "Send `nextion_init` event to Home Assistant"
            - homeassistant.event:
                event: ${EVENT_NAME}
                data:
                  device_name: !lambda return device_name->state.c_str();
                  esphome_version: ${version}
                  type: boot
                  step: nextion_init
      - script.execute:
          id: boot_progress
          step: 6

      # Wait for a response from the blueprint
      - if:
          condition:
            - lambda: return not (system_flags & NSPanelFlag::BLUEPRINT_READY);
          then:
            - delay: ${DELAY_DEFAULT}ms
            - lambda: |-
                ESP_LOGD("${TAG_BOOT}", "Asking Blueprint to start sending data");
            - homeassistant.event:
                event: ${EVENT_NAME}
                data:
                  device_name: !lambda return device_name->state.c_str();
                  esphome_version: ${version}
                  type: boot
                  step: start
            - script.execute: wait_for_blueprint
            - script.wait: wait_for_blueprint
            - if:
                condition:
                  - lambda: return system_flags & NSPanelFlag::BLUEPRINT_READY;
                then:
                  - delay: ${DELAY_DEFAULT}ms
                  - script.execute:
                      id: boot_progress
                      step: 7
                else:
                  - script.execute:
                      id: boot_log
                      category: Boot
                      log_message: "Blueprint not available"

      # Setup Home page
      - delay: ${DELAY_DEFAULT}ms
      - script.execute:
          id: boot_log
          category: Boot
          log_message: "Set Home page elements"

      # Chips icon size
      - delay: ${DELAY_DEFAULT}ms
      - lambda: |-
          for (uint8_t i = 1; i <= 7; ++i) {
            disp1->send_command_printf("home.chip%02d.font=%i", i, id(home_chip_font_id));
          }

      # Custom buttons icon size
      - delay: ${DELAY_DEFAULT}ms
      - lambda: |-
          for (uint8_t i = 1; i <= 7; ++i) {
            disp1->send_command_printf("home.button%02d.font=%i", i, id(home_custom_buttons_font_id));
          }

      # Other components icons size and color
      - delay: ${DELAY_DEFAULT}ms
      - lambda: |-
          disp1->set_component_font("home.bt_notific", id(home_custom_buttons_font_id));
          disp1->set_component_font("home.bt_qrcode", id(home_custom_buttons_font_id));
          disp1->set_component_font("home.bt_entities", id(home_custom_buttons_font_id));
          disp1->set_component_font("home.wifi_icon", id(home_chip_font_id));
          disp1->set_component_font_color("home.chip_relay1", id(home_relay1_icon_color));
          disp1->set_component_font_color("home.chip_relay2", id(home_relay2_icon_color));

      # Bluetooth icon
      - delay: ${DELAY_DEFAULT}ms
      - lambda: |-
          #if defined(USE_ESP32_BLE_SERVER) || defined(USE_ESP32_BLE_CLIENT) || defined(USE_BLUETOOTH_PROXY) || defined(USE_IMPROV)
          disp1->set_component_text("home.bt_icon", "\uE0AE");
          #else
          disp1->set_component_text("home.bt_icon", "");
          #endif

      # Wrap-up
      - delay: ${DELAY_DEFAULT}ms
      - script.execute:
          id: boot_progress
          step: 8
      - delay: ${DELAY_DEFAULT}ms
      - script.execute:
          id: boot_log
          category: Boot
          log_message: "Wait to finish"
      - script.execute: wait_for_wifi
      - script.execute: wait_for_api
      - script.execute: wait_for_blueprint
      - script.wait: wait_for_wifi
      - script.wait: wait_for_api
      - script.wait: wait_for_blueprint
      - script.execute:
          id: boot_progress
          step: 9

      - delay: ${DELAY_DEFAULT}ms
      - script.execute:
          id: boot_progress
          step: 10
      - delay: ${DELAY_DEFAULT}ms
      - script.execute:
          id: set_brightness
          brightness: !lambda return display_brightness->state;
      - delay: ${DELAY_DEFAULT}ms
      - script.execute:
          id: boot_log
          category: Boot
          log_message: "Jump to wake-up page"

      - script.execute:
          id: wakeup
          reset_timer: true

  - id: boot_critical_components
    mode: single
    then:  # Critical components should subscribe themselves to this
      - lambda: |-
          ESP_LOGI("TAG_BOOT", "Starting boot critical components sequence");

  - id: boot_early_routines
    mode: single
    then:  # Critical components should subscribe themselves to this
      - lambda: |-
          ESP_LOGI("TAG_BOOT", "Starting boot early routines sequence");

  - id: boot_log
    mode: queued
    max_runs: 3
    parameters:
      category: string
      log_message: string
    then:
      - lambda: |-
          ESP_LOGD("${TAG_BOOT}", "%s: %s", category.c_str(), log_message.c_str());
      # Extended by:
      # - page_boot

  - id: boot_preparation
    mode: single
    then:
      - lambda: |-
          ESP_LOGI("TAG_BOOT", "Starting boot preparation sequence");

  - id: boot_progress
    mode: restart
    parameters:
      step: uint
    then:
      - if:
          condition:
            - lambda: return (step == 10);
          then:
            - lambda: |-
                ESP_LOGD("script.boot_progress", "Progress: Completed");
                disp1->set_component_value("boot.progress", 100);
                system_flags |= (NSPanelFlag::BOOT_COMPLETED);  // Set the flag
          else:
            - lambda: |-
                ESP_LOGD("script.boot_progress", "Progress: %.1f%%", get_blueprint_status_percentage());
                disp1->set_component_value("boot.progress", step);

  - id: !extend stop_all
    then:
      - script.stop: boot
      - script.stop: boot_critical_components
      - script.stop: boot_early_routines
      - script.stop: boot_log
      - script.stop: boot_preparation
      - script.stop: boot_progress

  - id: wait_for_boot_completed
    mode: single
    then:
      - repeat:
          count: 300  # seconds
          then:
            - if:
                condition:
                  - lambda: return system_flags & NSPanelFlag::WIFI_READY;
                then:
                  - script.stop: wait_for_wifi
            - if:
                condition:
                  - lambda: return (iteration % 5 == 1);  // Log every 5 seconds (at iterations 1, 6, 11, etc.)
                then:
                  - script.execute:
                      id: boot_log
                      category: "Boot"
                      log_message: "Waiting for Wi-Fi..."
            - delay: 1s

  - id: !extend watchdog_round
    then:
      - if:
          condition:
            - lambda: return not (system_flags & NSPanelFlag::BLUEPRINT_READY);
          then:
            - lambda: |-
                ESP_LOGW("${TAG_BOOT}", "Request blueprint settings");
            - homeassistant.event:
                event: ${EVENT_NAME}
                data:
                  device_name: !lambda return device_name->state.c_str();
                  esphome_version: ${version}
                  type: boot
                  step: timeout
      - if:
          condition:
            - lambda: return !(system_flags & NSPanelFlag::BOOT_COMPLETED);
            - not:
                - script.is_running: boot
          then:
            - delay: 1s
            - script.execute: boot
            - script.wait: boot
...

#####################################################################################################
##### NSPANEL ESPHOME created by Blackymas - https://github.com/Blackymas/NSPanel_HA_Blueprint  #####
##### ESPHOME - Page alarm                                                                      #####
##### PLEASE only make changes if it is necessary and also the required knowledge is available. #####
##### For normal use with the Blueprint, no changes are necessary.                              #####
#####################################################################################################
---
substitutions:
  require_disarm_before_rearm: false

  PAGE_ALARM_DELAY_DEFAULT: ${DELAY_DEFAULT}
  PAGE_ALARM_DELAY_LONG: ${DELAY_LONG}
  PAGE_ALARM_DELAY_SHORT: ${DELAY_SHORT}

  BOOT_STEP_PAGE_ALARM: 10
  PAGE_ALARM_ID: 23
  TAG_PAGE_ALARM: nspanel.page.alarm

api:
  actions:
    # Updates the alarm settings page with current state and configuration, integrating with the panel's interface.
    - action: page_alarm
      variables:
        page_title: string       # Title for the alarm settings page, displayed prominently at the top.
        state: string            # Current state of the alarm system (e.g., "armed_home", "disarmed").
        supported_features: int  # Bitmask representing the alarm system's supported features, determining available controls on the page.
        code_format: string      # Format required for the alarm code (numeric, alphanumeric).
        code_arm_required: bool  # Indicates if a code is needed to arm the system.
        entity: string           # Entity ID for the alarm system, enabling state updates and control.
        mui_alarm: string[]      # Localized text for alarm control buttons (e.g., Arm, Disarm), allowing for a multilingual interface.
      then:
        # To do: This page constructor should be moved to Blueprint
        - lambda: |-
            if (current_page_id != ${PAGE_ALARM_ID}) return;

            // Set detailed entity sensor
            ESP_LOGV("${TAG_PAGE_ALARM}", "Set detailed entity sensor");
            detailed_entity->publish_state(entity.c_str());
            feed_wdt_delay(${PAGE_ALARM_DELAY_SHORT});

            // Page header - Icon
            ESP_LOGV("${TAG_PAGE_ALARM}", "Page header - Icon");
            update_alarm_icon->execute("icon_state", state.c_str());

            // Page header - Title
            ESP_LOGV("${TAG_PAGE_ALARM}", "Page header - Title");
            if (page_title.find("\\r") != std::string::npos) {
              page_title = page_title.replace(page_title.find("\\r"), 2, " ");
            }
            disp1->set_component_text("page_label", page_title.c_str());

            // Page - Params
            ESP_LOGV("${TAG_PAGE_ALARM}", "Page - Params");
            disp1->set_component_text("code_format", code_format.c_str());
            disp1->set_component_text("code_arm_req", code_arm_required ? "1" : "0");
            feed_wdt_delay(${PAGE_ALARM_DELAY_SHORT});

            //Buttons - Text
            ESP_LOGV("${TAG_PAGE_ALARM}", "Buttons - Text");
            disp1->set_component_text("bt_away_text", wrapText(mui_alarm[1].c_str(), 10, id(mui_bytes_per_char)).c_str());
            disp1->set_component_text("bt_night_text", wrapText(mui_alarm[2].c_str(), 10, id(mui_bytes_per_char)).c_str());
            disp1->set_component_text("bt_vacat_text", wrapText(mui_alarm[3].c_str(), 10, id(mui_bytes_per_char)).c_str());
            disp1->set_component_text("bt_bypass_text", wrapText(mui_alarm[4].c_str(), 10, id(mui_bytes_per_char)).c_str());
            disp1->set_component_text("bt_disarm_text", wrapText(mui_alarm[5].c_str(), 10, id(mui_bytes_per_char)).c_str());
            feed_wdt_delay(${PAGE_ALARM_DELAY_SHORT});

            // Determine if alarm is triggered
            #ifdef USE_REQUIRE_DISARM_BEFORE_REARM
            const bool is_armed = (state.find("armed_") == 0) || (state == "arming") || (state == "pending");
            ESP_LOGV("${TAG_PAGE_ALARM}", "Alarm is armed: %s", YESNO(is_armed));
            #endif
            const bool is_triggered = (state == "triggered");
            ESP_LOGV("${TAG_PAGE_ALARM}", "Alarm is triggered: %s", YESNO(is_triggered));

            // Button - Home
            if ((supported_features & 1) or (state == "armed_home")) {
              ESP_LOGV("${TAG_PAGE_ALARM}", "Button - Home");
              const bool is_armed_home = (state == "armed_home");
              disp1->set_component_pic("bt_home_pic", is_armed_home ? 43 : 42);
              disp1->set_component_background_color("bt_home_text", is_armed_home ? Colors::GREEN : Colors::GRAY_LIGHT);
              disp1->set_component_background_color("bt_home_icon", is_armed_home ? Colors::GREEN : Colors::GRAY_LIGHT);
              disp1->set_component_font_color("bt_home_text", is_armed_home ? Colors::WHITE : Colors::BLACK);
              disp1->set_component_font_color("bt_home_icon", is_armed_home ? Colors::WHITE : Colors::BLACK);
              #ifdef USE_REQUIRE_DISARM_BEFORE_REARM
              disp1->send_command_printf("vis bt_home,%i", (is_armed or is_triggered) ? 0 : 1);
              #else  // USE_REQUIRE_DISARM_BEFORE_REARM
              disp1->send_command_printf("vis bt_home,%i", (is_armed_home or is_triggered) ? 0 : 1);
              #endif  // USE_REQUIRE_DISARM_BEFORE_REARM
              feed_wdt_delay(${PAGE_ALARM_DELAY_SHORT});
            }

            // Button - Away
            if ((supported_features & 2) or (state == "armed_away")) {
              ESP_LOGV("${TAG_PAGE_ALARM}", "Button - Away");
              const bool is_armed_away = (state == "armed_away");
              disp1->set_component_pic("bt_away_pic", is_armed_away ? 43 : 42);
              disp1->set_component_background_color("bt_away_text", is_armed_away ? Colors::GREEN : Colors::GRAY_LIGHT);
              disp1->set_component_background_color("bt_away_icon", is_armed_away ? Colors::GREEN : Colors::GRAY_LIGHT);
              disp1->set_component_font_color("bt_away_text", is_armed_away ? Colors::WHITE : Colors::BLACK);
              disp1->set_component_font_color("bt_away_icon", is_armed_away ? Colors::WHITE : Colors::BLACK);
              #ifdef USE_REQUIRE_DISARM_BEFORE_REARM
              disp1->send_command_printf("vis bt_away,%i", (is_armed or is_triggered) ? 0 : 1);
              #else  // USE_REQUIRE_DISARM_BEFORE_REARM
              disp1->send_command_printf("vis bt_away,%i", (is_armed_away or is_triggered) ? 0 : 1);
              #endif  // USE_REQUIRE_DISARM_BEFORE_REARM
              feed_wdt_delay(${PAGE_ALARM_DELAY_SHORT});
            }

            // Button - Night
            if ((supported_features & 4) or (state == "armed_night")) {
              ESP_LOGV("${TAG_PAGE_ALARM}", "Button - Night");
              const bool is_armed_night = (state == "armed_night");
              disp1->set_component_pic("bt_night_pic", is_armed_night ? 43 : 42);
              disp1->set_component_background_color("bt_night_text", is_armed_night ? Colors::GREEN : Colors::GRAY_LIGHT);
              disp1->set_component_background_color("bt_night_icon", is_armed_night ? Colors::GREEN : Colors::GRAY_LIGHT);
              disp1->set_component_font_color("bt_night_text", is_armed_night ? Colors::WHITE : Colors::BLACK);
              disp1->set_component_font_color("bt_night_icon", is_armed_night ? Colors::WHITE : Colors::BLACK);
              #ifdef USE_REQUIRE_DISARM_BEFORE_REARM
              disp1->send_command_printf("vis bt_night,%i", (is_armed or is_triggered) ? 0 : 1);
              #else  // USE_REQUIRE_DISARM_BEFORE_REARM
              disp1->send_command_printf("vis bt_night,%i", (is_armed_night or is_triggered) ? 0 : 1);
              #endif  // USE_REQUIRE_DISARM_BEFORE_REARM
            }

            // Button - Vacation
            if ((supported_features & 32) or (state == "armed_vacation")) {
              ESP_LOGV("${TAG_PAGE_ALARM}", "Button - Vacation");
              const bool is_armed_vacation = (state == "armed_vacation");
              disp1->set_component_pic("bt_vacat_pic", is_armed_vacation ? 43 : 42);
              disp1->set_component_background_color("bt_vacat_text", is_armed_vacation ? Colors::GREEN : Colors::GRAY_LIGHT);
              disp1->set_component_background_color("bt_vacat_icon", is_armed_vacation ? Colors::GREEN : Colors::GRAY_LIGHT);
              disp1->set_component_font_color("bt_vacat_text", is_armed_vacation ? Colors::WHITE : Colors::BLACK);
              disp1->set_component_font_color("bt_vacat_icon", is_armed_vacation ? Colors::WHITE : Colors::BLACK);
              #ifdef USE_REQUIRE_DISARM_BEFORE_REARM
              disp1->send_command_printf("vis bt_vacat,%i", (is_armed or is_triggered) ? 0 : 1);
              #else  // USE_REQUIRE_DISARM_BEFORE_REARM
              disp1->send_command_printf("vis bt_vacat,%i", (is_armed_vacation or is_triggered) ? 0 : 1);
              #endif  // USE_REQUIRE_DISARM_BEFORE_REARM
              feed_wdt_delay(${PAGE_ALARM_DELAY_SHORT});
            }

            // Button - Custom bypass
            if ((supported_features & 16) or (state == "armed_custom_bypass")) {
              ESP_LOGV("${TAG_PAGE_ALARM}", "Button - Custom bypass");
              const bool is_triggered_custom_bypass = (state == "armed_custom_bypass");
              disp1->set_component_pic("bt_bypass_pic", is_triggered_custom_bypass ? 43 : 42);
              disp1->set_component_background_color("bt_bypass_text", is_triggered_custom_bypass ? Colors::GREEN : Colors::GRAY_LIGHT);
              disp1->set_component_background_color("bt_bypass_icon", is_triggered_custom_bypass ? Colors::GREEN : Colors::GRAY_LIGHT);
              disp1->set_component_font_color("bt_bypass_text", is_triggered_custom_bypass ? Colors::WHITE : Colors::BLACK);
              disp1->set_component_font_color("bt_bypass_icon", is_triggered_custom_bypass ? Colors::WHITE : Colors::BLACK);
              #ifdef USE_REQUIRE_DISARM_BEFORE_REARM
              disp1->send_command_printf("vis bt_bypass,%i", (is_armed or is_triggered) ? 0 : 1);
              #else  // USE_REQUIRE_DISARM_BEFORE_REARM
              disp1->send_command_printf("vis bt_bypass,%i", (is_triggered_custom_bypass or is_triggered) ? 0 : 1);
              #endif  // USE_REQUIRE_DISARM_BEFORE_REARM
              feed_wdt_delay(${PAGE_ALARM_DELAY_SHORT});
            }

            // Button - Disarm (enabled when armed, disabled when disarmed)
            ESP_LOGV("${TAG_PAGE_ALARM}", "Button - Disarm");
            const bool is_disarmed = (state == "disarmed");
            disp1->set_component_pic("bt_disarm_pic", is_disarmed ? 43 : 42);
            disp1->set_component_background_color("bt_disarm_text", is_disarmed ? Colors::GREEN : Colors::GRAY_LIGHT);
            disp1->set_component_background_color("bt_disarm_icon", is_disarmed ? Colors::GREEN : Colors::GRAY_LIGHT);
            disp1->set_component_font_color("bt_disarm_text", is_disarmed ? Colors::WHITE : Colors::BLACK);
            disp1->set_component_font_color("bt_disarm_icon", is_disarmed ? Colors::WHITE : Colors::BLACK);
            disp1->send_command_printf("vis bt_disarm,%i", (is_disarmed) ? 0 : 1);

            ESP_LOGV("${TAG_PAGE_ALARM}", "Done!");

esphome:
  platformio_options:
    build_flags:
      - -D NSPANEL_HA_BLUEPRINT_PAGE_ALARM

nspanel_ha_blueprint:
  require_disarm_before_rearm: ${require_disarm_before_rearm}
script:
  - id: !extend event_from_display  # Defined by hw_display
    then:
      - lambda: |-
          if (params[0] == "alarm") {
            // CSV Format: alarm,key,code_format,code_arm_req
            // params[0]=page, params[1]=key, params[2]=code_format, params[3]=code_arm_req, params[4]=mui

            if (params_count != 5) {
              ESP_LOGW("${TAG_PAGE_ALARM}", "Bad params");
              return;
            }

            const std::string& key = params[1];
            const std::string& code_format = params[2];
            const std::string& code_arm_req = params[3];
            const std::string& mui = params[4];
            ESP_LOGV("${TAG_PAGE_ALARM}", "key=%s, format=%s, arm_req=%s, mui=%s",
                      key.c_str(), code_format.c_str(), code_arm_req.c_str(), mui.c_str());

            if (code_format == "number" && (key == "disarm" || code_arm_req == "1")) {
              ESP_LOGV("${TAG_PAGE_ALARM}", "Open keypad");
              goto_page->execute(${PAGE_KEYB_NUM_ID});

              disp1->set_component_value("page_id", ${PAGE_ALARM_ID});
              disp1->set_component_text("domain", "alarm");
              disp1->set_component_text("key", key.c_str());
              disp1->set_component_text("value", "click");
              disp1->set_component_text("entity", detailed_entity->state.c_str());
              disp1->set_component_text("title", mui.c_str());
            } else {
              ESP_LOGV("${TAG_PAGE_ALARM}", "Executing direct alarm action: key=%s, format=%s",
                        key.c_str(), code_format.c_str());
              alarm_control_panel_action->execute(detailed_entity->state.c_str(), key.c_str(),
                                                  code_format.c_str(), "");
            }  // endif numeric keypad required
          }

  - id: alarm_control_panel_action
    mode: single
    parameters:
      entity: string
      key: string
      code_format: string
      pin: string
    then:
      - lambda: |-
          ESP_LOGV("${TAG_PAGE_ALARM}", "Alarm control panel action call");
          ESP_LOGV("${TAG_PAGE_ALARM}", "  entity_id: %s", entity.c_str());
          ESP_LOGV("${TAG_PAGE_ALARM}", "  key: %s", key.c_str());
          ESP_LOGV("${TAG_PAGE_ALARM}", "  pin provided: %s", pin.empty() ? "NO" : "YES");

          // Build action string
          static std::string action_str;
          action_str = "alarm_control_panel.alarm_";
          if (key != "disarm") action_str += "arm_";
          if (key == "bypass") action_str += "custom_";
          action_str += key;
          ESP_LOGV("${TAG_PAGE_ALARM}", "  action: %s", action_str.c_str());

          // Create action request
          esphome::api::HomeassistantActionRequest action_request;
          action_request.set_service(StringRef(action_str));
          ESP_LOGV("${TAG_PAGE_ALARM}", "Service set");

          const bool has_code = !pin.empty();

          #if ESPHOME_VERSION_CODE >= VERSION_CODE(2025, 11, 0)
          // IMPORTANT: FixedVector needs capacity before emplace_back()
          action_request.data.init(has_code ? 2 : 1);  // entity_id [+ code]
          #endif  // ESPHOME_VERSION_CODE >= VERSION_CODE(2025, 11, 0)

          // Add entity_id
          {
            auto &kv = action_request.data.emplace_back();
            kv.set_key(StringRef("entity_id"));
            kv.value = entity;
          }

          // Add code if present
          if (has_code) {
            auto &kv = action_request.data.emplace_back();
            kv.set_key(StringRef("code"));
            kv.value = pin;
          }  // if (has_code)

          ESP_LOGV("${TAG_PAGE_ALARM}", "Final data size: %zu", action_request.data.size());
          ESP_LOGV("${TAG_PAGE_ALARM}", "  (will send entity_id=%s%s)",
                  entity.c_str(), has_code ? " and code=<hidden>" : "");

          ESP_LOGV("${TAG_PAGE_ALARM}", "Sending action to Home Assistant");
          api_server->send_homeassistant_action(action_request);

  - id: !extend dump_config  # Defined by nspanel_esphome_core_base.yaml
    then:
      - lambda: |-
          // Check for requirements
          #if !defined(NSPANEL_HA_BLUEPRINT_PAGE_KEYB_NUM)
            #error "The package nspanel_esphome_standard_page_keyb_num.yaml is required."
          #endif

  - id: page_alarm
    mode: single
    then:  # There's nothing here so far

  - id: !extend page_change
    then:
      - lambda: |-
          if (new_page_id == ${PAGE_ALARM_ID})
            page_alarm->execute();

  - id: !extend stop_all
    then:
      - lambda: |-
          alarm_control_panel_action->stop();
          update_alarm_icon->stop();

  - id: !extend stop_page_constructors
    then:
      - lambda: page_alarm->stop();

  - id: update_alarm_icon
    mode: single
    parameters:
      component: string
      state: string
    then:
      - lambda: |-
          const char* icon = Icons::SHIELD_ALERT_OUTLINE;
          uint16_t color = Colors::WHITE;

          // Optimized state checking using first character for fast branching
          if (state[0] == 'd') {  // "disarmed" or "disarming"
            icon = Icons::SHIELD_OFF_OUTLINE;
            color = (state == "disarming") ? Colors::YELLOW : Colors::WHITE;
          } else if (state[0] == 'a') {  // "armed_*" or "arming"
            if (state == "arming") {
              icon = Icons::SHIELD_OUTLINE;
              color = Colors::YELLOW;
            } else {
              color = Colors::GREEN;
              if (state == "armed_home") {
                icon = Icons::SHIELD_HOME_OUTLINE;
              } else if (state == "armed_away") {
                icon = Icons::SHIELD_LOCK_OUTLINE;
              } else if (state == "armed_night") {
                icon = Icons::SHIELD_MOON_OUTLINE;
              } else if (state == "armed_vacation") {
                icon = Icons::SHIELD_AIRPLANE_OUTLINE;
              } else if (state == "armed_custom_bypass") {
                icon = Icons::SHIELD_HALF_FULL;
              }
            }
          } else if (state == "pending") {
            icon = Icons::SHIELD_OUTLINE;
            color = Colors::YELLOW;
          } else if (state == "triggered") {
            icon = Icons::SHIELD_ALERT_OUTLINE;
            color = Colors::RED;
          }

          // Apply the icon and color to the display component
          disp1->set_component_text(component.c_str(), icon);
          disp1->set_component_font_color(component.c_str(), static_cast<uint16_t>(color));
...

#####################################################################################################
##### NSPANEL ESPHOME created by Blackymas - https://github.com/Blackymas/NSPanel_HA_Blueprint  #####
##### ESPHOME CORE                                                                              #####
##### PLEASE only make changes if it is necessary and also the required knowledge is available. #####
##### For normal use with the Blueprint, no changes are necessary.                              #####
#####################################################################################################
---
substitutions:
  ##############################
  ## Change only in your      ##
  ## local yaml substitutions ##
  temp_units: "째C"
  invalid_cooldown: "100ms"
  ota_password: ${wifi_password}
  ap_password: ${wifi_password}
  device_name: NSPanel
  name: ${device_name}
  wifi_timeout: '15'
  ##### DON'T CHANGE THIS ######
  version: "4.2.4"
  ##############################

##### External components #####
external_components:
  - source: github://pr#6051  # Remove this and update min ver when that PR is released (Hopefully v2024.1.0)
    components:
      - nextion
    refresh: 300s

##### ESPHOME CONFIGURATION #####
esphome:
  name: ${name}
  min_version: 2023.12.0
  platformio_options:
    build_flags:
      - -Wno-missing-field-initializers
  on_boot:
    - priority: 600.0  # This is where most sensors are set up.
      then:
        - script.execute: restore_settings

  on_shutdown:
    then:
      - switch.turn_off: screen_power

##### TYPE OF ESP BOARD #####
esp32:
  board: esp32dev

##### WIFI SETUP #####
wifi:
  id: wifi_component
  power_save_mode: LIGHT
  networks:
    - id: wifi_default
      ssid: ${wifi_ssid}
      password: ${wifi_password}
  ap:
    ssid: "${name}"
    password: ${ap_password}
  on_connect:
    then:
      - script.execute: watchdog
  on_disconnect:
    then:
      - script.execute: watchdog

##### OTA PASSWORD #####
ota:
  id: ota_std
  password: ${ota_password}
  safe_mode: true
  reboot_timeout: 3min
  num_attempts: 3

##### JSON - Used to parse json and for Upload TFT #####
json:

##### LOGGER #####
logger:
  id: logger_std
  baud_rate: 0

##### ENABLE RINGTONE MUSIC SUPPORT #####
rtttl:
  id: buzzer
  output: buzzer_out

##### CONFIGURE INTERNAL BUZZER #####
output:
  ##### BUZZER FOR PLAYING RINGTONES #####
  - id: buzzer_out
    platform: ledc
    pin:
      number: 21

##### UART FOR NEXTION DISPLAY #####
uart:
  - id: tf_uart
    tx_pin: 16
    rx_pin: 17
    baud_rate: 115200

##### Keeps time display updated #####
time:
  - id: time_provider
    platform: homeassistant
    on_time:
      - seconds: 0
        then:
          - script.execute: refresh_datetime
      - seconds: 30
        then:
          - script.execute: watchdog

    on_time_sync:
      then:
        - logger.log: "System clock synchronized"
        - script.execute: refresh_datetime

##### START - API CONFIGURATION #####
api:
  id: api_server
  reboot_timeout: 0s
  on_client_connected:
    - script.execute: watchdog
  on_client_disconnected:
    - script.execute: watchdog

  services:
    ##### Service to send a command "printf" directly to the display #####
    - service: send_command_printf
      variables:
        cmd: string
      then:
        - lambda: 'disp1->send_command_printf("%s", cmd.c_str());'

    ##### Service to send a command "text_printf" directly to the display #####
    - service: send_command_text_printf
      variables:
        component: string
        message: string
      then:
        - lambda: 'disp1->set_component_text_printf(component.c_str(), "%s", message.c_str());'

    ##### Service to send a command "component_value (Dualstate Button)" directly to the display #####
    - service: send_command_value
      variables:
        component: string
        val: int
      then:
        - lambda: |-
            disp1->set_component_value(component.c_str(), val);

    ##### Service to send a command "hide componente" directly to the display #####
    - service: send_command_hide
      variables:
        component: string
      then:
        - lambda: 'disp1->hide_component(component.c_str());'

    ##### Service to send a command "show componente" directly to the display #####
    - service: send_command_show
      variables:
        component: string
      then:
        - lambda: 'disp1->show_component(component.c_str());'

    ##### Service to send a command "font color" directly to the display #####
    - service: set_component_color
      variables:
        component: string
        foreground: int[]
      then:
        - lambda: set_component_color->execute(component, foreground);

    ##### Service to play a rtttl tones #####
    # Example tones : https://codebender.cc/sketch:109888#RTTTL%20Songs.ino
    - service: play_rtttl
      variables:
        song_str: string
      then:
        - rtttl.play:
            rtttl: !lambda 'return song_str;'

    #### Service to populate the alarm settings page #####
    - service: alarm_settings
      variables:
        page_title: string
        state: string
        supported_features: int
        code_format: string
        code_arm_required: bool
        entity: string
        mui_alarm: string[]
      then:
        - lambda: |-
            // Is page Alarm visible?
            if (current_page->state == "alarm")  // To do: This page constructor should be moved to Blueprint
              { // Update alarm page
                  detailed_entity->publish_state(entity);

                  // Alarm page - Header
                  update_alarm_icon->execute("icon_state", state.c_str());
                  if (page_title.find("\\r") != std::string::npos) {
                    page_title = page_title.replace(page_title.find("\\r"), 2, " ");
                  }
                  disp1->set_component_text_printf("page_label", "%s", page_title.c_str());
                  disp1->set_component_text_printf("code_format", "%s", code_format.c_str());
                  if (code_arm_required) disp1->set_component_text_printf("code_arm_req", "1");
                  else disp1->set_component_text_printf("code_arm_req", "0");

                  // Alarm page - Button's text
                  display_wrapped_text->execute("bt_home_text", mui_alarm[0].c_str(), 10);
                  display_wrapped_text->execute("bt_away_text", mui_alarm[1].c_str(), 10);
                  display_wrapped_text->execute("bt_night_text", mui_alarm[2].c_str(), 10);
                  display_wrapped_text->execute("bt_vacat_text", mui_alarm[3].c_str(), 10);
                  display_wrapped_text->execute("bt_bypass_text", mui_alarm[4].c_str(), 10);
                  display_wrapped_text->execute("bt_disarm_text", mui_alarm[5].c_str(), 10);

                  // Alarm page - Buttons
                  if (supported_features & 1 or state == "armed_home") // Alarm - Button - Home
                    {
                      disp1->send_command_printf("bt_home_pic.pic=%i", (state == "armed_home") ? 43 : 42);
                      disp1->set_component_background_color("bt_home_text", (state == "armed_home") ? 19818 : 52857);
                      disp1->set_component_background_color("bt_home_icon", (state == "armed_home") ? 19818 : 52857);
                      disp1->set_component_font_color("bt_home_text", (state == "armed_home") ? 65535 : 0);
                      disp1->set_component_font_color("bt_home_icon", (state == "armed_home") ? 65535 : 0);
                      if (state == "armed_home") disp1->hide_component("bt_home"); else disp1->show_component("bt_home");
                    }
                  if (supported_features & 2 or state == "armed_away") // Alarm - Button - Away
                    {
                      disp1->send_command_printf("bt_away_pic.pic=%i", (state == "armed_away") ? 43 : 42);
                      disp1->set_component_background_color("bt_away_text", (state == "armed_away") ? 19818 : 52857);
                      disp1->set_component_background_color("bt_away_icon", (state == "armed_away") ? 19818 : 52857);
                      disp1->set_component_font_color("bt_away_text", (state == "armed_away") ? 65535 : 0);
                      disp1->set_component_font_color("bt_away_icon", (state == "armed_away") ? 65535 : 0);
                      if (state == "armed_away") disp1->hide_component("bt_away"); else disp1->show_component("bt_away");
                    }
                  if (supported_features & 4 or state == "armed_night") // Alarm - Button - Night
                    {
                      disp1->send_command_printf("bt_night_pic.pic=%i", (state == "armed_night") ? 43 : 42);
                      disp1->set_component_background_color("bt_night_text", (state == "armed_night") ? 19818 : 52857);
                      disp1->set_component_background_color("bt_night_icon", (state == "armed_night") ? 19818 : 52857);
                      disp1->set_component_font_color("bt_night_text", (state == "armed_night") ? 65535 : 0);
                      disp1->set_component_font_color("bt_night_icon", (state == "armed_night") ? 65535 : 0);
                      if (state == "armed_night") disp1->hide_component("bt_night"); else disp1->show_component("bt_night");
                    }
                  if (supported_features & 32 or state == "armed_vacation") // Alarm - Button - Vacation
                    {
                      disp1->send_command_printf("bt_vacat_pic.pic=%i", (state == "armed_vacation") ? 43 : 42);
                      disp1->set_component_background_color("bt_vacat_text", (state == "armed_vacation") ? 19818 : 52857);
                      disp1->set_component_background_color("bt_vacat_icon", (state == "armed_vacation") ? 19818 : 52857);
                      disp1->set_component_font_color("bt_vacat_text", (state == "armed_vacation") ? 65535 : 0);
                      disp1->set_component_font_color("bt_vacat_icon", (state == "armed_vacation") ? 65535 : 0);
                      if (state == "armed_vacation") disp1->hide_component("bt_vacat"); else disp1->show_component("bt_vacat");
                    }
                  if (supported_features & 16 or state == "armed_bypass") // Alarm - Button - Custom bypass
                    {
                      disp1->send_command_printf("bt_bypass_pic.pic=%i", (state == "armed_bypass") ? 43 : 42);
                      disp1->set_component_background_color("bt_bypass_text", (state == "armed_bypass") ? 19818 : 52857);
                      disp1->set_component_background_color("bt_bypass_icon", (state == "armed_bypass") ? 19818 : 52857);
                      disp1->set_component_font_color("bt_bypass_text", (state == "armed_bypass") ? 65535 : 0);
                      disp1->set_component_font_color("bt_bypass_icon", (state == "armed_bypass") ? 65535 : 0);
                      if (state == "armed_bypass") disp1->hide_component("bt_bypass"); else disp1->show_component("bt_bypass");
                    }
                  if ( true ) // Alarm - Button - Disarm
                    {
                      disp1->send_command_printf("bt_disarm_pic.pic=%i", (state == "disarmed") ? 43 : 42);
                      disp1->set_component_background_color("bt_disarm_text", (state == "disarmed") ? 19818 : 52857);
                      disp1->set_component_background_color("bt_disarm_icon", (state == "disarmed") ? 19818 : 52857);
                      disp1->set_component_font_color("bt_disarm_text", (state == "disarmed") ? 65535 : 0);
                      disp1->set_component_font_color("bt_disarm_icon", (state == "disarmed") ? 65535 : 0);
                      if (state == "disarmed") disp1->hide_component("bt_disarm"); else disp1->show_component("bt_disarm");
                    }
              }

    ##### Service for transferring relay's settings from the blueprint to ESPHome #####
    - service: relay_settings
      variables:
        relay1_local_control: bool
        relay1_icon: string
        relay1_icon_color: int
        relay1_fallback: bool
        relay2_local_control: bool
        relay2_icon: string
        relay2_icon_color: int
        relay2_fallback: bool
      then:
        - script.execute:
            id: relay_settings
            relay1_local_control: !lambda "return relay1_local_control;"
            relay1_icon: !lambda "return relay1_icon;"
            relay1_icon_color: !lambda "return relay1_icon_color;"
            relay1_fallback: !lambda "return relay1_fallback;"
            relay2_local_control: !lambda "return relay2_local_control;"
            relay2_icon: !lambda "return relay2_icon;"
            relay2_icon_color: !lambda "return relay2_icon_color;"
            relay2_fallback: !lambda "return relay2_fallback;"

    ##### Service for transferring global settings from the blueprint to ESPHome #####
    - service: global_settings
      variables:
        blueprint_version: string
        embedded_climate: bool
        embedded_climate_friendly_name: string
        embedded_indoor_temperature: bool
        temperature_unit_is_fahrenheit: bool  # Deprecated
        mui_please_confirm: string
        mui_unavailable: string
        screensaver_time: bool
        screensaver_time_color: int[]
      then:
        - script.execute:
            id: global_settings
            blueprint_version: !lambda "return blueprint_version;"
            embedded_climate: !lambda "return embedded_climate;"
            embedded_climate_friendly_name: !lambda "return embedded_climate_friendly_name;"
            embedded_indoor_temperature: !lambda "return embedded_indoor_temperature;"
            mui_please_confirm: !lambda "return mui_please_confirm;"
            mui_unavailable: !lambda "return mui_unavailable;"
            screensaver_time: !lambda "return screensaver_time;"
            screensaver_time_color: !lambda "return screensaver_time_color;"

    ##### Service to show a notification-message on the screen #####
    - service: notification_show
      variables:
        label: string
        message: string
      then:
        - lambda: |-
            ESP_LOGV("service.notification_show", "Starting");

            disp1->goto_page("notification");
            disp1->set_component_text_printf("notification.notifi_label", "%s", label.c_str());

            display_wrapped_text->execute("notification.notifi_text01", message.c_str(), display_mode->state == 2 ? 23 : 32);

            notification_label->publish_state(label.c_str());
            notification_text->publish_state(message.c_str());
            timer_reset_all->execute(current_page->state.c_str());
            refresh_notification->execute();
            notification_unread->turn_on();
            if (notification_sound->state) buzzer->play("two short:d=4,o=5,b=100:16e6,16e6");

    ##### Service to clear the notification #####
    - service: notification_clear
      then:
        - script.execute: notification_clear

    ##### Service to open information for settings-page(s)
    - service: open_entity_settings_page
      variables:
        page: string
        page_label: string
        page_icon: string
        page_icon_color: int[]
        entity: string
        back_page: string
      then:
        - script.execute:
            id: open_entity_settings_page
            page: !lambda "return page;"
            page_label: !lambda "return page_label;"
            page_icon: !lambda "return page_icon;"
            page_icon_color: !lambda "return page_icon_color;"
            entity: !lambda "return entity;"
            back_page: !lambda "return back_page;"

    # Service to show a QR code on the display (ex. for WiFi password)
    - service: qrcode
      variables:
        title: string
        qrcode: string
        show: bool
      then:
        - lambda: |-
            disp1->set_component_text_printf("qrcode.qrcode_label", "%s", title.c_str());
            disp1->set_component_text_printf("qrcode.qrcode_value", "%s", qrcode.c_str());
            if (show) disp1->goto_page("qrcode");

    #### Service to set climate state ####
    - service: set_climate
      variables:
        current_temp: float
        supported_features: int
        target_temp: float
        target_temp_high: float
        target_temp_low: float
        temp_step: int
        total_steps: int
        temp_offset: int
        climate_icon: string
        embedded_climate: bool
        entity: string
      then:
        - lambda: |-
            if (current_page->state == "climate") detailed_entity->publish_state(entity);
        - script.execute:
            id: set_climate
            current_temp: !lambda "return current_temp;"
            supported_features: !lambda "return supported_features;"
            target_temp: !lambda "return target_temp;"
            target_temp_high: !lambda "return target_temp_high;"
            target_temp_low: !lambda "return target_temp_low;"
            temp_step: !lambda "return temp_step;"
            total_steps: !lambda "return total_steps;"
            temp_offset: !lambda "return temp_offset;"
            climate_icon: !lambda "return climate_icon;"
            embedded_climate: !lambda "return embedded_climate;"

    #### Service to set the buttons ####
    - service: set_button
      variables:
        page: string
        id: string
        state: bool
        icon: string
        icon_color: int[]
        icon_font: int
        bri: string
        label: string
      then:
        - lambda: |-
            static const char *const TAG = "service.set_button";
            if (page == current_page->state) {
              std::string btnicon = id.c_str() + std::string("icon");
              std::string btntext = id.c_str() + std::string("text");
              std::string btnbri = id.c_str() + std::string("bri");
              uint8_t bg_pic = state ? 47 : 46;
              uint16_t txt_color = state ? 10597 : 65535;
              disp1->send_command_printf("%spic.picc=%u", id.c_str(), bg_pic);
              disp1->send_command_printf("%sbri.picc=%u", id.c_str(), bg_pic);
              disp1->send_command_printf("%stext.picc=%u", id.c_str(), bg_pic);
              disp1->send_command_printf("%sicon.picc=%u", id.c_str(), bg_pic);
              disp1->send_command_printf("%sicon.font=%" PRIu32, id.c_str(), icon_font);
              disp1->set_component_foreground_color(btnbri.c_str(), txt_color);
              disp1->set_component_foreground_color(btntext.c_str(), txt_color);
              set_component_color->execute(btnicon.c_str(), icon_color);
              disp1->set_component_text_printf(btnicon.c_str(), "%s", icon.c_str());
              display_wrapped_text->execute(btntext.c_str(), label.c_str(), 10);
              if (strcmp(bri.c_str(), "0") != 0)
                disp1->set_component_text_printf(btnbri.c_str(), "%s", bri.c_str());
              else
                disp1->set_component_text_printf(btnbri.c_str(), " ");
            } else {
              ESP_LOGW(TAG, "Skipping button `%s.%s` as page has changed to %s.", page.c_str(), id.c_str(), current_page->state.c_str());
            }

    ##### SERVICE TO WAKE UP THE DISPLAY #####
    - service: wake_up
      variables:
        reset_timer: bool
      then:
        - lambda: |-
            if (current_page->state == "screensaver") disp1->goto_page(id(wakeup_page_id));
            if (reset_timer)
              timer_reset_all->execute(id(page_names)[id(wakeup_page_id)].c_str());
            else {
              timer_sleep->execute(id(page_names)[id(wakeup_page_id)].c_str(), int(timeout_sleep->state));
              timer_dim->execute(id(page_names)[id(wakeup_page_id)].c_str(), int(timeout_dim->state));
            }

    #### Service to set the entities ####
    - service: set_entity
      variables:
        ent_id: string
        ent_icon: string
        ent_label: string
        ent_value: string
        ent_value_xcen: string
      then:
        - lambda: |-
            std::string enticon = ent_id.c_str() + std::string("_pic");
            std::string entlabel = ent_id.c_str() + std::string("_label");
            std::string entxcen = ent_id.c_str() + std::string(".xcen=") + ent_value_xcen.c_str();
            disp1->set_component_text_printf(enticon.c_str(), "%s", ent_icon.c_str());
            if (strcmp(ent_icon.c_str(), "0") != 0) disp1->set_component_text_printf(enticon.c_str(), "%s", ent_icon.c_str());
            disp1->set_component_text_printf(entlabel.c_str(), "%s", ent_label.c_str());
            disp1->set_component_text_printf(ent_id.c_str(), "%s", ent_value.c_str());
            if (strcmp(ent_value_xcen.c_str(), "0") != 0) disp1->send_command_printf("%s", entxcen.c_str());

    #### Service to populate the page Home #####
    - service: page_home
      variables:
        date_color: int
        time_format: string
        time_color: int
        meridiem: string[]
        chip_font_size: int
        custom_buttons_font_size: int
        notification_icon: string
        notification_icon_color_normal: int[]
        notification_icon_color_unread: int[]
        qrcode: bool
        qrcode_icon: string
        qrcode_icon_color: int[]
        entities_pages: bool
        entities_pages_icon: string
        entities_pages_icon_color: int[]
      then:
        - lambda: |-
            static const char *const TAG = "service.page_home";
            ESP_LOGV(TAG, "date_color:                      %" PRIi32, date_color);
            ESP_LOGV(TAG, "time_format:                     %s", time_format.c_str());
            ESP_LOGV(TAG, "time_color:                      %" PRIi32, time_color);
            ESP_LOGV(TAG, "meridiem:                        %i", meridiem.size());
            ESP_LOGV(TAG, "chip_font_size:                  %" PRIi32, chip_font_size);
            ESP_LOGV(TAG, "custom_buttons_font_size:        %" PRIi32, custom_buttons_font_size);
            ESP_LOGV(TAG, "notification_icon:               %s", notification_icon.c_str());
            ESP_LOGV(TAG, "notification_icon_color_normal:  %i", notification_icon_color_normal.size());
            ESP_LOGV(TAG, "notification_icon_color_unread:  %i", notification_icon_color_unread.size());
            ESP_LOGV(TAG, "qrcode:                          %s", qrcode ? "True" : "False");
            ESP_LOGV(TAG, "qrcode_icon:                     %s", qrcode_icon.c_str());
            ESP_LOGV(TAG, "qrcode_icon_color:               %i", qrcode_icon_color.size());
            ESP_LOGV(TAG, "entities_pages:                  %s", entities_pages ? "True" : "False");
            ESP_LOGV(TAG, "entities_pages_icon:             %s", entities_pages_icon.c_str());
            ESP_LOGV(TAG, "entities_pages_icon_color:       %i", entities_pages_icon_color.size());

            // Localization
            ESP_LOGV(TAG, "Load localization");
            id(mui_time_format) = time_format;
            id(mui_meridiem) = meridiem;

            // Date/Time colors
            ESP_LOGV(TAG, "Load date/time colors");
            disp1->set_component_font_color("home.date", date_color);
            disp1->set_component_font_color("home.time", time_color);
            id(home_date_color) = date_color;
            id(home_time_color) = time_color;

            // Chips icon size
            ESP_LOGV(TAG, "Chips size");
            for (int i = 1; i <= 10; ++i) {
              disp1->send_command_printf("home.icon_top_%02d.font=%" PRIu32, i, chip_font_size);
            }
            disp1->send_command_printf("home.wifi_icon.font=%" PRIu32, chip_font_size);
            id(home_chip_font_size) = chip_font_size;

            // Custom buttons icon size
            ESP_LOGV(TAG, "Custom buttons sizes");
            id(home_custom_buttons_font_size) = custom_buttons_font_size;
            for (int i = 1; i <= 7; ++i) {
              disp1->send_command_printf("home.button%02d.font=%i", i, id(home_custom_buttons_font_size));
            }
            disp1->send_command_printf("home.bt_notific.font=%i", id(home_custom_buttons_font_size));
            disp1->send_command_printf("home.bt_qrcode.font=%i", id(home_custom_buttons_font_size));
            disp1->send_command_printf("home.bt_entities.font=%i", id(home_custom_buttons_font_size));

            // Notification button
            ESP_LOGV(TAG, "Set Notification button");
            disp1->send_command_printf("is_notification=%i", (notification_text->state.empty() and notification_label->state.empty()) ? 0 : 1);
            disp1->set_component_text_printf("home.bt_notific", "%s", notification_icon.c_str());
            set_component_color->execute("home.bt_notific", notification_unread->state ? notification_icon_color_unread : notification_icon_color_normal);
            id(home_notify_icon_color_normal) = notification_icon_color_normal;
            id(home_notify_icon_color_unread) = notification_icon_color_unread;

            // QRCode button
            ESP_LOGV(TAG, "Set QRCode button");
            disp1->send_command_printf("is_qrcode=%i", qrcode ? 1 : 0);
            disp1->set_component_text_printf("home.bt_qrcode", "%s", qrcode_icon.c_str());
            set_component_color->execute("home.bt_qrcode", qrcode_icon_color);

            // Entities pages button
            ESP_LOGV(TAG, "Set Entities button");
            disp1->send_command_printf("is_entities=%i", entities_pages ? 1 : 0);
            disp1->set_component_text_printf("home.bt_entities", "%s", entities_pages_icon.c_str());
            //set_component_color->execute("home.bt_entities", entities_pages_icon_color);
            set_component_color->execute("home.bt_entities", entities_pages_icon_color);

    #### Service to populate the page Settings #####
    - service: page_settings
      variables:
        reboot: string
        brightness: string
        bright: string
        dim: string
      then:
        - lambda: |-
            if (not reboot.empty()) disp1->set_component_text_printf("settings.lbl_reboot", " %s", reboot.c_str());
            disp1->set_component_text_printf("settings.lbl_brightness", " %s", brightness.c_str());
            display_wrapped_text->execute("settings.lbl_bright", bright.c_str(), display_mode->state == 2 ? 25 : 10);
            display_wrapped_text->execute("settings.lbl_dim", dim.c_str(), display_mode->state == 2 ? 25 : 10);

    #### Service to populate the media player page #####
    - service: media_player
      variables:
        entity: string
        state: string
        is_volume_muted: bool
        friendly_name: string
        volume_level: int
        media_title: string
        media_artist: string
        media_duration: float
        media_position: float
        media_position_delta: float
        supported_features: int
      then:
        - lambda: |-
            if (current_page->state == "media_player")
              {
                detailed_entity->publish_state(entity);
                disp1->set_component_text_printf("page_label", "%s", friendly_name.c_str());
                display_wrapped_text->execute("track", media_title.c_str(), display_mode->state == 2 ? 16 : 27);
                display_wrapped_text->execute("artist", media_artist.c_str(), display_mode->state == 2 ? 26 : 40);

                // on/off button
                if (supported_features & 128 and state == "off") //TURN_ON
                  {
                    disp1->set_component_foreground_color("bt_on_off", 65535);
                    disp1->show_component("bt_on_off");
                  }
                else if (supported_features & 256 and state != "off") //TURN_OFF
                  {
                    disp1->set_component_foreground_color("bt_on_off", 10597);
                    disp1->show_component("bt_on_off");
                  }
                else disp1->hide_component("bt_on_off");

                // play/pause button
                if ((supported_features & 512 or supported_features & 16384) and state != "playing" and state != "off") //PLAY_MEDIA+PLAY
                  {
                    disp1->set_component_text_printf("bt_play_pause", "%s", "\uE409"); // mdi:play
                    disp1->show_component("bt_play_pause");
                  }
                else if (supported_features & 1 and state == "playing" ) //PAUSE
                  {
                    disp1->set_component_text_printf("bt_play_pause", "%s", "\uE3E3"); // mdi:pause
                    disp1->show_component("bt_play_pause");
                  }
                else disp1->hide_component("bt_play_pause");

                // bt_prev button - PREVIOUS_TRACK
                if (supported_features & 16 and state != "off") disp1->show_component("bt_prev"); else disp1->hide_component("bt_prev");
                // bt_next button - NEXT_TRACK
                if (supported_features & 32 and state != "off") disp1->show_component("bt_next"); else disp1->hide_component("bt_next");

                // Stop button - STOP
                //if (supported_features & 4096 and (state == "playing" or state == "paused")) disp1->show_component("bt_stop"); else disp1->hide_component("bt_stop");

                // mute/unmute button - VOLUME_MUTE
                disp1->set_component_value("is_muted", is_volume_muted ? 1 : 0);
                if (supported_features & 8 and is_volume_muted) // unmute
                  {
                    disp1->set_component_text_printf("bt_mute", "%s", "\uEE07"); // mdi:volume-variant-off
                    disp1->show_component("bt_mute");
                  }
                else if (supported_features & 8) // mute
                  {
                    disp1->set_component_text_printf("bt_mute", "%s", "\uE57E"); // mdi:volume-low
                    disp1->show_component("bt_mute");
                  }
                else disp1->hide_component("bt_mute");

                // VOLUME_SET
                if (supported_features & 4)
                  {
                    if (volume_level != id(last_volume_level))
                      {
                        id(last_volume_level) = volume_level;
                        disp1->set_component_text_printf("vol_text", "%" PRIu32 "%%", volume_level);
                        disp1->set_component_value("vol_slider", volume_level);
                      }
                    disp1->show_component("vol_slider");
                    disp1->show_component("bt_vol_down");
                    disp1->show_component("bt_vol_up");
                    disp1->show_component("vol_text");
                  }
                else
                  {
                    disp1->hide_component("vol_slider");
                    disp1->hide_component("bt_vol_down");
                    disp1->hide_component("bt_vol_up");
                    disp1->hide_component("vol_text");
                  }

                if (media_duration > 0)
                  {
                    if (media_duration != id(last_media_duration) or media_position != id(last_media_position))
                      {
                        id(last_media_duration) = media_duration;
                        id(last_media_position) = media_position;
                        disp1->set_component_value("prg_current", int(round(min(media_position + media_position_delta, media_duration))));
                      }
                    disp1->set_component_value("prg_total", int(round(media_duration)));
                    disp1->send_command_printf("prg_timer.en=%i", (state == "playing") ? 1 : 0);
                    disp1->show_component("time_current");
                    disp1->show_component("time_total");
                    disp1->show_component("time_progress");
                  }
                else
                  {
                    disp1->send_command_printf("prg_timer.en=0");
                    disp1->hide_component("time_current");
                    disp1->hide_component("time_total");
                    disp1->hide_component("time_progress");
                  }
              }

##### START - DISPLAY START CONFIGURATION #####
display:
  - id: disp1
    platform: nextion
    uart_id: tf_uart
    on_setup:
      - script.execute: setup_sequence
    on_page:
      lambda: |-
        static const char *const TAG = "display.disp1.on_page";
        if (id(is_uploading_tft)) {
          ESP_LOGD(TAG, "Page changed ignored as a TFT upload is in progress");
        } else if (x > id(page_names).size()) {
          ESP_LOGW(TAG, "Invalid page index: %i", int(x));
        } else {
          ESP_LOGD(TAG, "Nextion page changed");
          ESP_LOGD(TAG, "New page: %s (%i)" , id(page_names)[x].c_str(), x);
          page_id->update();
          if (current_page->state != id(page_names)[x].c_str() or x == 9) {
            current_page->publish_state(id(page_names)[x].c_str());
            page_changed->execute(id(page_names)[x].c_str());
          }
        }
    on_touch:
      lambda: |-
        static const char *const TAG = "display.disp1.on_touch";
        ESP_LOGV(TAG, "Nextion touch event detected!");
        ESP_LOGV(TAG, "Page:         %s", id(page_names)[page_id].c_str());
        ESP_LOGV(TAG, "Component Id: %i", component_id);
        ESP_LOGV(TAG, "Event type:   %s", touch_event ? "Press" : "Release");
        timer_reset_all->execute(id(page_names)[page_id].c_str());

##### START - GLOBALS CONFIGURATION #####
globals:
  ##### Wake-up page id #####
  - id: wakeup_page_id
    type: uint
    restore_value: true
    initial_value: '0'

  ##### Wi-Fi timeout #####
  - id: wifi_timeout
    type: uint
    restore_value: false
    initial_value: ${wifi_timeout}

  ##### Is uploading TFT #####
  - id: is_uploading_tft
    type: bool
    restore_value: false
    initial_value: 'false'

  ##### Is blueprint updated #####
  - id: is_blueprint_updated
    type: bool
    restore_value: false
    initial_value: 'false'

  ##### Is global settings loaded #####
  - id: is_global_settings_loaded
    type: bool
    restore_value: false
    initial_value: 'false'

  ##### Is settings restored ####
  - id: is_restored_settings
    type: bool
    restore_value: false
    initial_value: 'false'

  ##### Is boot sequence completed? #####
  - id: setup_sequence_completed
    type: bool
    restore_value: false
    initial_value: 'false'

  ###### Last volume level from Home Assistant ######
  - id: last_volume_level
    type: uint
    restore_value: false
    initial_value: '0'

  ###### Last duration from Home Assistant ######
  - id: last_media_duration
    type: uint
    restore_value: false
    initial_value: '0'

  ###### Last duration from Home Assistant ######
  - id: last_media_position
    type: uint
    restore_value: false
    initial_value: '0'

  ###### Relay fallback even when buttons have other entities? ######
  - id: relay_1_fallback
    type: bool
    restore_value: true
    initial_value: 'false'
  - id: relay_2_fallback
    type: bool
    restore_value: true
    initial_value: 'false'

  ##### Is embedded thermostat set as main climate entity? #####
  - id: is_embedded_thermostat
    type: bool
    restore_value: true
    initial_value: 'false'

  ##### Save Display Brightness for NSPanel reboot #####
  - id: display_brightness_global
    type: uint
    restore_value: true
    initial_value: '100'

  ##### Save Display DIM Brightness for NSPanel reboot
  - id: display_dim_brightness_global
    type: uint
    restore_value: true
    initial_value: '10'

  ##### Is embedded sensor used for indoor temperature? #####
  - id: embedded_indoor_temp
    type: bool
    restore_value: true
    initial_value: 'false'

  ##### Date/time formats #####
  - id: home_date_color
    type: uint
    restore_value: true
    initial_value: '65535'

  - id: mui_time_format
    type: std::string
    restore_value: true
    initial_value: '"%H:%M"'
  - id: home_time_color
    type: uint
    restore_value: true
    initial_value: '65535'
  - id: mui_meridiem
    type: std::vector<std::string>
    restore_value: false
    initial_value: '{"AM", "PM"}'

  #### MUI strings ####
  - id: mui_please_confirm_global
    type: std::string
    restore_value: true
    initial_value: '"Please confirm"'
  - id: mui_unavailable_global
    type: std::string
    restore_value: true
    initial_value: '"Unavailable"'

  ##### Chips #####
  - id: home_chip_font_size
    type: uint
    restore_value: true
    initial_value: '7'

  #### Custom buttons ####
  - id: home_custom_buttons_font_size
    type: uint
    restore_value: true
    initial_value: '8'

  ##### Relay icons #####
  - id: home_relay1_icon
    type: std::string
    restore_value: true
    initial_value: ''
  - id: home_relay1_icon_color
    type: uint16_t
    restore_value: true
    initial_value: '65535'

  - id: home_relay2_icon
    type: std::string
    restore_value: true
    initial_value: ''
  - id: home_relay2_icon_color
    type: uint16_t
    restore_value: true
    initial_value: '65535'

  - id: home_notify_icon_color_normal
    type: std::vector<int32_t>
    restore_value: false
  - id: home_notify_icon_color_unread
    type: std::vector<int32_t>
    restore_value: false

  ##### Screensaver #####
  - id: screensaver_display_time
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: screensaver_display_time_color
    type: std::vector<int32_t>
    restore_value: false
    initial_value: '{64, 64, 64}'

  ##### Versions #####
  - id: version_blueprint
    type: std::string
    restore_value: false
    initial_value: ''

  - id: page_names
    type: std::vector<std::string>
    restore_value: false
    initial_value:
      '{
        "home",
        "weather01",
        "weather02",
        "weather03",
        "weather04",
        "weather05",
        "climate",
        "settings",
        "boot",
        "screensaver",
        "light",
        "cover",
        "buttonpage01",
        "buttonpage02",
        "buttonpage03",
        "buttonpage04",
        "notification",
        "qrcode",
        "entitypage01",
        "entitypage02",
        "entitypage03",
        "entitypage04",
        "fan",
        "alarm",
        "keyb_num",
        "media_player",
        "confirm"
      }'

##### START - BINARY SENSOR CONFIGURATION #####
binary_sensor:

  ###### LEFT BUTTON BELOW DISPLAY TO TOGGLE RELAY#####
  - name: ${name} Left Button
    platform: gpio
    id: left_button
    pin:
      number: 14
      inverted: true
    on_multi_click:
      - timing: &long_click-timing
          - ON for at least 0.8s
        invalid_cooldown: ${invalid_cooldown}
        then:
          - logger.log: "Left button - Long click"
          - script.execute:
              id: ha_button
              page: !lambda return current_page->state.c_str();
              component: "hw_bt_left"
              command: "long_click"
      - timing: &short_click-timing
          - ON for at most 0.8s
        invalid_cooldown: ${invalid_cooldown}
        then:
          - logger.log: "Left button - Short click"
          - if:
              condition:
                or:
                  - switch.is_on: relay1_local
                  - and:
                      - lambda: !lambda return id(relay_1_fallback);
                      - or:
                          - not:
                              - api.connected:
                          - not:
                              - wifi.connected:
              then:
                - switch.toggle: relay_1
          - script.execute:
              id: ha_button
              page: !lambda return current_page->state.c_str();
              component: "hw_bt_left"
              command: "short_click"
      - timing: &hold_to_restart-timing
          - ON for at least 15.0s
        invalid_cooldown: ${invalid_cooldown}
        then:
          - switch.turn_off: screen_power
          - delay: 5s
          - switch.turn_on: screen_power
          - delay: 2s
          - lambda: disp1->soft_reset();
          - delay: 2s
          - script.execute: setup_sequence

  ##### RIGHT BUTTON BELOW DISPLAY TO TOGGLE RELAY #####
  - name: ${name} Right Button
    platform: gpio
    id: right_button
    pin:
      number: 27
      inverted: true
    on_multi_click:
      - timing: *long_click-timing
        invalid_cooldown: ${invalid_cooldown}
        then:
          - logger.log: "Right button - Long click"
          - script.execute:
              id: ha_button
              page: !lambda return current_page->state.c_str();
              component: "hw_bt_right"
              command: "long_click"
      - timing: *short_click-timing
        invalid_cooldown: ${invalid_cooldown}
        then:
          - logger.log: "Right button - Short click"
          - if:
              condition:
                or:
                  - switch.is_on: relay2_local
                  - and:
                      - lambda: !lambda return id(relay_2_fallback);
                      - or:
                          - not:
                              - api.connected:
                          - not:
                              - wifi.connected:
              then:
                - switch.toggle: relay_2
          - script.execute:
              id: ha_button
              page: !lambda return current_page->state.c_str();
              component: "hw_bt_right"
              command: "short_click"
      - timing: *hold_to_restart-timing
        invalid_cooldown: ${invalid_cooldown}
        then:  # Restart the panel
          - button.press: restart_nspanel

  ##### Restart NSPanel Button - Setting Page #####
  - name: ${name} Restart
    platform: nextion
    page_id: 7
    component_id: 9
    internal: true
    on_click:
      - button.press: restart_nspanel
  ##### Restart NSPanel Button - Boot Page #####
  - name: ${name} Restart
    platform: nextion
    page_id: 8
    component_id: 4
    internal: true
    on_click:
      - button.press: restart_nspanel

  ## Delays initial info from HA to the display #####
  - name: ${name} Nextion display
    id: nextion_init
    platform: template
    device_class: connectivity
    publish_initial_state: true
    entity_category: diagnostic
    icon: mdi:tablet-dashboard

  ##### API connection status
  - name: ${name} Status
    platform: status
    id: api_status
    on_state:
      then:
        - script.execute: watchdog

##### START - BUTTON CONFIGURATION #####
button:
  ###### REBOOT BUTTON #####
  - name: ${name} Restart
    platform: restart
    id: restart_nspanel

##### START - NUMBER CONFIGURATION #####
number:
  ##### SCREEN BRIGHTNESS #####
  - name: ${name} Display Brightness
    id: display_brightness
    platform: template
    entity_category: config
    unit_of_measurement: '%'
    min_value: 1
    max_value: 100
    initial_value: 100
    step: 1
    restore_value: true
    optimistic: true
    set_action:
      then:
        - lambda: |-
            id(display_brightness_global) = int(x);
            disp1->send_command_printf("brightness=%i", int(x));
            disp1->send_command_printf("settings.brightslider.val=%i", int(x));
            if (current_page->state != "screensaver")
              {
                disp1->set_backlight_brightness(x/100);
                current_brightness->update();
                timer_dim->execute(current_page->state.c_str(), int(timeout_dim->state));
                timer_sleep->execute(current_page->state.c_str(), int(timeout_sleep->state));
                if (current_page->state == "settings") disp1->set_component_text_printf("bright_text", "%i%%", int(x));
              }

  ##### SCREEN BRIGHTNESS DIMMED DOWN #####
  - name: ${name} Display Brightness Dimdown
    id: display_dim_brightness
    platform: template
    entity_category: config
    unit_of_measurement: '%'
    min_value: 1
    max_value: 100
    initial_value: 25
    step: 1
    restore_value: true
    optimistic: true
    set_action:
      then:
        - lambda: |-
            id(display_dim_brightness_global) = int(x);
            disp1->send_command_printf("brightness_dim=%i", int(x));
            disp1->send_command_printf("settings.dimslider.val=%i", int(x));
            if (current_page->state != "screensaver" and (current_brightness->state <= id(display_dim_brightness_global)))
              {
                set_brightness->execute(x);
                timer_sleep->execute(current_page->state.c_str(), int(timeout_sleep->state));
                if (current_page->state == "settings") disp1->set_component_text_printf("dim_text", "%i%%", int(x));
              }

  ##### SCREEN BRIGHTNESS SLEEP #####
  - name: ${name} Display Brightness Sleep
    id: display_sleep_brightness
    platform: template
    entity_category: config
    unit_of_measurement: '%'
    min_value: 0
    max_value: 100
    initial_value: 0
    step: 1
    restore_value: true
    optimistic: true
    set_action:
      then:
        - lambda: |-
            id(display_dim_brightness_global) = int(x);
            disp1->send_command_printf("brightness_sleep=%i", int(x));
            page_screensaver->execute();

  ##### Temperature Correction #####
  - name: ${name} Temperature Correction
    platform: template
    id: temperature_correction
    entity_category: config
    unit_of_measurement: ${temp_units}
    min_value: -10
    max_value: 10
    initial_value: 0
    step: 0.1
    mode: box
    restore_value: true
    internal: false
    optimistic: true
    set_action:
      - logger.log: Temperature correction changed.
      - delay: 1s
      - lambda: temp_nspanel->publish_state(temp_nspanel->raw_state);

  ##### Timers settings #####
  - name: ${name} Timeout Page
    platform: template
    id: timeout_page
    entity_category: config
    min_value: 0
    max_value: 86400
    initial_value: 15
    step: 1
    restore_value: true
    optimistic: true
    icon: mdi:timer
    unit_of_measurement: "s"
    set_action:
      - lambda: timer_page->execute(current_page->state.c_str(), int(x));
  - name: ${name} Timeout Dimming
    platform: template
    id: timeout_dim
    entity_category: config
    min_value: 0
    max_value: 86400
    initial_value: 30
    step: 1
    restore_value: true
    optimistic: true
    icon: mdi:timer
    unit_of_measurement: "s"
    set_action:
      - lambda: timer_dim->execute(current_page->state.c_str(), int(x));
  - name: ${name} Timeout Sleep
    platform: template
    id: timeout_sleep
    entity_category: config
    min_value: 0
    max_value: 86400
    initial_value: 60
    step: 1
    restore_value: true
    optimistic: true
    icon: mdi:timer
    unit_of_measurement: "s"
    set_action:
      - lambda: |-
          timer_dim->execute(current_page->state.c_str(), int(timeout_dim->state));
          timer_sleep->execute(current_page->state.c_str(), int(x));

##### START - SELECT CONFIGURATION #####
select:
  - id: baud_rate
    name: ${name} Baud rate
    platform: template
    options:
      - "2400"
      - "4800"
      - "9600"
      - "19200"
      - "31250"
      - "38400"
      - "57600"
      - "115200"
      - "230400"
      - "250000"
      - "256000"
      - "512000"
      - "921600"
    initial_option: "115200"
    optimistic: true
    restore_value: true
    internal: false
    entity_category: config
    disabled_by_default: true
    icon: mdi:swap-horizontal
    set_action:
      - lambda: set_baud_rate->execute(stoi(x), true);

  - id: wakeup_page_name
    name: ${name} Wake-up page
    platform: template
    options:
      - buttonpage01
      - buttonpage02
      - buttonpage03
      - buttonpage04
      - climate
      - entitypage01
      - entitypage02
      - entitypage03
      - entitypage04
      - home
      - qrcode
    initial_option: home
    optimistic: true
    restore_value: true
    internal: false
    entity_category: config
    icon: mdi:page-next-outline
    set_action:
      - lambda: |-
          static const char *const TAG = "select.wakeup_page_name";
          ESP_LOGD(TAG, "New wake-up page selected: %s", x.c_str());
          if (id(is_restored_settings))
            set_page_id->execute("wakeup_page_id", x.c_str());
      - script.execute: page_screensaver

##### START - SENSOR CONFIGURATION #####
sensor:
  ##### INTERNAL TEMPERATURE SENSOR, ADC VALUE #####
  - id: ntc_source
    platform: adc
    pin: 38
    update_interval: 60s
    attenuation: 11db

  ##### INTERNAL TEMPERATURE SENSOR, adc reading converted to resistance (calculation)#####
  - id: resistance_sensor
    platform: resistance
    sensor: ntc_source
    configuration: DOWNSTREAM
    resistor: 11.2kOhm

  ##### INTERNAL TEMPERATURE SENSOR, resistance to temperature (calculation) #####
  - id: temp_nspanel
    name: ${name} Temperature
    platform: ntc
    sensor: resistance_sensor
    unit_of_measurement: ${temp_units}
    internal: false
    calibration:
      b_constant: 3950
      reference_temperature: 25째C
      reference_resistance: 10kOhm
    filters:
      - lambda: |-
          std::string temp_unit = "${temp_units}";
          if (temp_unit == "째F" or temp_unit == "F" or temp_unit == "째f" or temp_unit == "f")
            return (x * (9.0/5.0)) + 32.0 + temperature_correction->state;
          else
            return x + temperature_correction->state;
    on_value:
      then:
        # Show panel's temperature if API or Wi-Fi are out
        - lambda: display_embedded_temp->execute();

  ###### Display Brightness GET VALUE FROM NSPanel SLIDER #####
  - id: brightslider
    name: ${name} brightness Slider
    platform: nextion
    variable_name: brightslider
    internal: true
    on_value:
      then:
        - number.set:
            id: display_brightness
            value: !lambda 'return int(x);'
        - lambda: |-
            timer_reset_all->execute("settings");

  ###### Display DIM Brightness GET VALUE FROM NSPanel SLIDER #####
  - id: dimslider
    name: ${name} dim brightness slider
    platform: nextion
    variable_name: dimslider
    internal: true
    on_value:
      then:
        - number.set:
            id: display_dim_brightness
            value: !lambda 'return int(x);'
        - lambda: |-
            timer_reset_all->execute("settings");

  ###### Display Brightness - Current value (%) #####
  - id: current_brightness
    name: ${name} Display Current brightness
    platform: nextion
    variable_name: dim
    precision: 0
    accuracy_decimals: 0
    unit_of_measurement: "%"
    icon: mdi:brightness-percent
    #update_interval: 60s
    internal: false
    disabled_by_default: true
    on_value:
      then:
        - lambda: |-
            static const char *const TAG = "sensor.current_brightness";
            ESP_LOGD(TAG, "Current brightness: %i%%", int(x));

  ###### Page Id - Current #####
  - id: page_id
    name: ${name} Page Id
    platform: nextion
    variable_name: dp
    precision: 0
    accuracy_decimals: 0
    internal: true
    entity_category: diagnostic
    on_value:
      then:
        - lambda: |-
            static const char *const TAG = "sensor.page_id";
            ESP_LOGD(TAG, "New page Id: %i", int(x));
            if (id(is_uploading_tft)) {
              ESP_LOGD(TAG, "Skipping actions as a TFT upload is in progress");
            } else if (x > id(page_names).size()) {
              ESP_LOGW(TAG, "Invalid page index: %i", int(x));
            } else if (current_page->state != id(page_names)[x].c_str()) {
              current_page->publish_state(id(page_names)[x].c_str());
              page_changed->execute(id(page_names)[x].c_str());
            }

  ##### Display mode (1 = EU, 2 = US, 3 = US Landscape)
  - id: display_mode
    name: ${name} Display mode
    platform: nextion
    variable_name: display_mode
    precision: 0
    accuracy_decimals: 0
    internal: true
    entity_category: diagnostic

  ##### Charset (1 = International (original), 2 = CJK languages)
  - name: ${name} Display charset
    id: display_charset
    platform: nextion
    variable_name: charset
    precision: 0
    accuracy_decimals: 0
    internal: true
    entity_category: diagnostic

  ##### WIFI Signal stregth
  - name: ${name} RSSI
    id: wifi_rssi
    platform: wifi_signal
    internal: false
    disabled_by_default: true
    entity_category: diagnostic

##### START - SWITCH CONFIGURATION #####
switch:

  ##### Notification unread #####
  - name: ${name} Notification unread
    platform: template
    id: notification_unread
    entity_category: config
    optimistic: true
    restore_mode: ALWAYS_OFF
    on_turn_on:
      - wait_until:
          condition:
            - lambda: !lambda return id(is_global_settings_loaded);
      - lambda: set_component_color->execute("home.bt_notific", id(home_notify_icon_color_unread));
    on_turn_off:
      - wait_until:
          condition:
            - lambda: !lambda return id(is_global_settings_loaded);
      - lambda: set_component_color->execute("home.bt_notific", id(home_notify_icon_color_normal));

  ##### Notification sound #####
  - name: ${name} Notification sound
    platform: template
    id: notification_sound
    entity_category: config
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  ##### PHYSICAL SWITCH 1 #####
  - name: ${name} Relay 1
    platform: gpio
    id: relay_1
    pin:
      number: 22
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      then:
        - script.execute: refresh_relays
    on_turn_off:
      then:
        - script.execute: refresh_relays
  ##### PHYSICAL SWITCH 2 ######
  - name: ${name} Relay 2
    platform: gpio
    id: relay_2
    pin:
      number: 19
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      then:
        - script.execute: refresh_relays
    on_turn_off:
      then:
        - script.execute: refresh_relays

  ##### DISPLAY ALWAYS ON #####
  - name: ${name} Nextion display - Power
    platform: gpio
    id: screen_power
    entity_category: diagnostic
    pin:
      number: 4
      inverted: true
    restore_mode: ALWAYS_ON
    internal: false
    disabled_by_default: true
    on_turn_on:
      - wait_until:
          condition:
            - lambda: !lambda return disp1->is_setup();
          timeout: 20s
      - lambda: |-
          if (id(setup_sequence_completed)) {
            nextion_init->publish_state(disp1->is_setup());
            disp1->goto_page(id(wakeup_page_id));
          }
    on_turn_off:
      - lambda: |-
          nextion_init->publish_state(false);

  ##### Relay Local control #####
  - name: ${name} Relay 1 Local
    platform: template
    id: relay1_local
    entity_category: config
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    internal: true
    on_turn_on:
      - logger.log: "Relay 1 Local turned On!"
    on_turn_off:
      - logger.log: "Relay 1 Local turned Off!"
  - name: ${name} Relay 2 Local
    platform: template
    id: relay2_local
    entity_category: config
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    internal: true
    on_turn_on:
      - logger.log: "Relay 2 Local turned On!"
    on_turn_off:
      - logger.log: "Relay 2 Local turned Off!"

##### START - TEXT SENSOR CONFIGURATION #####
text_sensor:

  ##### Entity Id of the entity displayed on the detailed pages
  - name: ${name} Detailed Entity
    id: detailed_entity
    platform: template
    icon: mdi:tablet-dashboard
    internal: false
    disabled_by_default: false

  ##### Current page name #####
  - name: ${name} Current page
    id: current_page
    platform: template
    icon: mdi:tablet-dashboard
    internal: false
    disabled_by_default: false

  - name: ${name} Notification Label
    platform: template
    id: notification_label

  - name: ${name} Notification Text
    platform: template
    id: notification_text

  ##### NSPanel event sensor, the main action sensor - push to HA #####
  - name: ${name} NSPanel event
    platform: nextion
    nextion_id: disp1
    id: disp1_nspanel_event
    component_name: nspanelevent
    internal: true
    filters:
      - lambda: |-
          x = x.c_str();
          x.shrink_to_fit();
          return x;
    on_value:
      then:
        - lambda: |-
            static const char *const TAG = "text_sensor.disp1_nspanel_event";
            ESP_LOGW(TAG, "Starting");
            DynamicJsonDocument doc(1024);
            deserializeJson(doc, x);
            std::string page = doc["page"];
            std::string component = doc["component"];
            if (not (component == "currentpage" and (page == "screensaver" or page == "home"))) timer_reset_all->execute(page.c_str());
            std::string value = doc["value"];
            std::string entity = detailed_entity->state.c_str();  // doc["entity"];
            ESP_LOGW(TAG, "page: %s", page.c_str());
            ESP_LOGW(TAG, "component: %s", component.c_str());
            ESP_LOGW(TAG, "value: %s", value.c_str());
            ESP_LOGW(TAG, "entity: %s", entity.c_str());
            auto ha_event = new esphome::api::CustomAPIDevice();
            ha_event->fire_homeassistant_event("esphome.nspanel_ha_blueprint",
              {
                {"type", "generic"},
                {"page", page},
                {"component", component},
                {"value", value},
                {"entity", entity}
              });

  ##### NSPanel event - Execute actions from ESPHome - NO push to HA #####
  - name: ${name} NSPanel local event
    platform: nextion
    nextion_id: disp1
    id: disp1_local_event
    component_name: localevent
    internal: true
    filters:
      - lambda: |-
          x = x.c_str();
          x.shrink_to_fit();
          return x;
    on_value:
      then:
        - lambda: |-
            static const char *const TAG = "text_sensor.localevent";
            DynamicJsonDocument doc(1024);
            deserializeJson(doc, x);
            std::string page = doc["page"];
            std::string event = doc["event"];
            std::string component = doc["component"];
            std::string key = doc["key"];
            std::string value = doc["value"];
            std::string entity = detailed_entity->state.c_str();  // doc["entity"];
            int embedded = doc["embedded"];
            std::string service = "";

            // Send event to Home Assistant
            if (event == "short_click" or event == "long_click") {
              ha_button->execute(page.c_str(), component.c_str(), event.c_str());
            } else if (event == "click" and page == "home" and component == "climate") {
              detailed_entity->publish_state((id(is_embedded_thermostat)) ? "embedded_climate" : "");
              disp1->set_component_value("climate.embedded", id(is_embedded_thermostat) ? 1 : 0);
              disp1->goto_page("climate");
            } else if (page == "light" or page == "climate" or page == "notification") {  // Generic event
                auto ha_event = new esphome::api::CustomAPIDevice();
                ha_event->fire_homeassistant_event("esphome.nspanel_ha_blueprint", {
                  {"type", "generic"},
                  {"page", page},
                  {"event", event},
                  {"value", value},
                  {"entity", entity}
                });
              }

            // page based actions
            if (page == "alarm")
              {
                std::string code_format = doc["code_format"];
                std::string code_arm_req = doc["code_arm_req"];
                std::string title = doc["mui"];
                if (code_format == "number" and (key == "disarm" or code_arm_req == "1"))
                  {
                    disp1->goto_page("keyb_num");
                    disp1->set_component_value("keyb_num.page_id", 23); //Calling from Alarm page
                    disp1->set_component_text_printf("keyb_num.domain", "%s", page.c_str());
                    disp1->set_component_text_printf("keyb_num.key", "%s", key.c_str());
                    disp1->set_component_text_printf("keyb_num.value", "%s", value.c_str());
                    disp1->set_component_text_printf("keyb_num.entity", "%s", entity.c_str());
                    disp1->set_component_text_printf("keyb_num.title", "%s", title.c_str());
                  }
                else service_call_alarm_control_panel->execute(entity.c_str(), key.c_str(), code_format.c_str(), "");
              }
            else if (page == "climate") {
              change_climate_state->execute((embedded==1), key.c_str(), value.c_str());
            }
            else if (page == "cover") {
              if (key == "position") ha_call_service->execute("cover.set_cover_position", key.c_str(), value.c_str(), entity.c_str());
              else ha_call_service->execute((std::string("cover.") + key.c_str()), "", "", entity.c_str());
            }
            else if (page == "fan") {
              if (key == "stop" or value == "0") ha_call_service->execute("fan.turn_off", "", "", entity.c_str());
              else ha_call_service->execute("fan.turn_on", key.c_str(), value.c_str(), entity.c_str());
            }
            else if (page == "keyb_num") {
              std::string base_domain = doc["base_domain"];
              if (base_domain == "alarm") {
                std::string code_format = doc["code_format"];
                std::string pin = doc["pin"];
                service_call_alarm_control_panel->execute(entity.c_str(), key.c_str(), code_format.c_str(), pin.c_str());
              }
              else if (base_domain == "" or base_domain.empty()) base_domain = "home";
              disp1->goto_page(base_domain.c_str());
            }
            else if (page == "light") ha_call_service->execute("light.turn_on", key.c_str(), value.c_str(), entity.c_str());
            else if (page == "media_player") {
              if (key == "volume_mute") ha_call_service->execute("media_player.volume_mute", "is_volume_muted", value.c_str(), entity.c_str());
              else if (key == "volume_set") ha_call_service->execute("media_player.volume_set", "volume_level", to_string(stof(value) / 100), entity.c_str());
              else if (not key.empty()) ha_call_service->execute((std::string("media_player.") + key.c_str()), "", "", entity.c_str());
            }

  - id: version_tft
    name: ${name} TFT version
    platform: nextion
    component_name: tft_version
    entity_category: diagnostic
    internal: true
    on_value:
      - lambda: |-
          static const char *const TAG = "text_sensor.version_tft";
          ESP_LOGD(TAG, "TFT version: %s", version_tft->state.c_str());
          if (current_page->state == "boot") {
            disp1->send_command_printf("tm_esphome.en=0");
            page_boot->execute();
            timer_reset_all->execute("boot");
          }
          check_versions->execute();

### Scripts ######
script:
  - id: change_climate_state
    mode: restart
    parameters:
      embedded: bool
      key: string
      value: string
    then:
      - lambda: |-
          if (!embedded) {
            if (key == "temperature" or key == "target_temp_high" or key == "target_temp_low")
              ha_call_service->execute("climate.set_temperature", key.c_str(), to_string(stof(value) / 10), detailed_entity->state.c_str());
            else if (key == "hvac_mode")
              ha_call_service->execute("climate.set_hvac_mode", key.c_str(), value.c_str(), detailed_entity->state.c_str());
          }

  - id: check_versions
    mode: restart
    then:
      - wait_until:
          condition:
            - lambda: |-
                auto compareVersions = [](const char* version1, const char* version2) -> bool
                  {
                    int major1 = 0, minor1 = 0;
                    int major2 = 0, minor2 = 0;

                    sscanf(version1, "%d.%d", &major1, &minor1);
                    sscanf(version2, "%d.%d", &major2, &minor2);

                    return (major1 == major2) && (minor1 == minor2);
                  };
                return (compareVersions("${version}", version_tft->state.c_str()) and compareVersions("${version}", id(version_blueprint).c_str()));
          timeout: 60s
      - lambda: |-
          static const char *const TAG = "script.check_versions";
          auto compareVersions = [](const char* version1, const char* version2) -> bool
            {
                int major1 = 0, minor1 = 0;
                int major2 = 0, minor2 = 0;

                sscanf(version1, "%d.%d", &major1, &minor1);
                sscanf(version2, "%d.%d", &major2, &minor2);

                return (major1 == major2) && (minor1 == minor2);
            };
          ESP_LOGD(TAG, "ESPHome version: ${version}");
          ESP_LOGD(TAG, "TFT version: %s", version_tft->state.c_str());
          if (not compareVersions("${version}", version_tft->state.c_str())) ESP_LOGE(TAG, "TFT version mismatch!");
          ESP_LOGD(TAG, "Blueprint version: %s", id(version_blueprint).c_str());
          if (not compareVersions("${version}", id(version_blueprint).c_str())) ESP_LOGE(TAG, "Blueprint version mismatch!");

          std::string framework = "unknown";
          #ifdef ARDUINO
          framework = "arduino";
          #elif defined(USE_ESP_IDF)
          framework = "esp-idf";
          #endif
          ESP_LOGD(TAG, "Framework: %s", framework.c_str());
          ESP_LOGD(TAG, "Baud rate: %" PRIu32, id(tf_uart).get_baud_rate());

          auto ha_event = new esphome::api::CustomAPIDevice();
          ha_event->fire_homeassistant_event("esphome.nspanel_ha_blueprint",
            {
              {"type", "version"},
              {"tft", version_tft->state.c_str()},
              {"esphome", "${version}"},
              {"blueprint", id(version_blueprint).c_str()},
              {"framework", framework.c_str()},
              {"baud_rate", to_string(id(tf_uart).get_baud_rate())}
            });

  - id: display_embedded_temp
    mode: restart
    then:
      - lambda: |-
          if (id(embedded_indoor_temp) or (!wifi_component->is_connected()) or (!api_server->is_connected()))
            disp1->set_component_text_printf("home.current_temp", "%.1f${temp_units}", temp_nspanel->state);

  - id: display_wrapped_text
    mode: queued
    parameters:
      component: string
      text_to_display: string
      line_length_limit: uint
    then:
      - lambda: |-
          int startPos = 0;
          int endPos = 0;
          std::string wrappedText = "";
          if (text_to_display.find("\\r") != std::string::npos) {
            wrappedText = text_to_display;
          } else {
            while (startPos < text_to_display.length()) {
              while (text_to_display[startPos] == ' ' and startPos < text_to_display.length()) { startPos++; }
              int endPos = startPos + line_length_limit;
              if (endPos >= text_to_display.length()) endPos = text_to_display.length();
              else
                {
                  while (endPos > startPos && text_to_display[endPos] != ' ') { endPos--; }
                  if (endPos == startPos) endPos = startPos + line_length_limit; // Handle case of long word
                }
              wrappedText += text_to_display.substr(startPos, endPos-startPos);
              if (endPos < text_to_display.length())
                {
                  while (text_to_display[endPos] == ' ') { endPos--; }
                  if (endPos >= startPos) wrappedText += "\\r";
                }
              startPos = endPos + 1; // Skip the space
              while (text_to_display[startPos] == ' ' and startPos < text_to_display.length()) { startPos++; }
            }
          }
          disp1->set_component_text_printf(component.c_str(), "%s", wrappedText.c_str());

  - id: exit_reparse
    mode: restart
    then:
      - logger.log: "Exit reparse"
      - uart.write: "DRAKJHSUYDGBNCJHGJKSHBDN"
      - uart.write: [0xFF, 0xFF, 0xFF]
      - uart.write: "recmod=0"
      - uart.write: [0xFF, 0xFF, 0xFF]
      - uart.write: "recmod=0"
      - uart.write: [0xFF, 0xFF, 0xFF]
      - uart.write: "connect"
      - uart.write: [0xFF, 0xFF, 0xFF]
      - uart.write: [0xFF, 0xFF]
      - uart.write: "connect"
      - uart.write: [0xFF, 0xFF, 0xFF]
      - uart.write: "bkcmd=3"
      - uart.write: [0xFF, 0xFF, 0xFF]

  - id: global_settings
    mode: restart
    parameters:
      blueprint_version: string
      embedded_climate: bool
      embedded_climate_friendly_name: string
      embedded_indoor_temperature: bool
      mui_please_confirm: string
      mui_unavailable: string
      screensaver_time: bool
      screensaver_time_color: int32_t[]
    then:
      - lambda: |-
          static const char *const TAG = "script.global_settings";
          // Blueprint version
          ESP_LOGV(TAG, "Check Blueprint version");
          id(version_blueprint) = blueprint_version;
          check_versions->execute();

          // Embedded thermostat
          ESP_LOGV(TAG, "Load embedded thermostat");
          id(is_embedded_thermostat) = embedded_climate;

          // Indoor temperature
          ESP_LOGV(TAG, "Set indoor temperature");
          id(embedded_indoor_temp) = embedded_indoor_temperature;
          display_embedded_temp->execute();

          // MUI strings
          id(mui_please_confirm_global) = mui_please_confirm;
          id(mui_unavailable_global) = mui_unavailable;

          // Screen saver page (sleep)
          ESP_LOGV(TAG, "Setup screensaver page");
          id(screensaver_display_time) = screensaver_time;
          id(screensaver_display_time_color) = screensaver_time_color;
          page_screensaver->execute();

          id(is_global_settings_loaded) = true;
          id(is_blueprint_updated) = true;
          disp1->send_command_printf("api=1");

          if (current_page->state != "boot") {
            // Update current page
            ESP_LOGV(TAG, "Update current page");
            page_changed->execute(current_page->state.c_str());
          }
          ESP_LOGV(TAG, "Current page: %s", current_page->state.c_str());

      - if:
          condition:
            - text_sensor.state:  # Is boot page visible?
                id: current_page
                state: boot
          then:
            - lambda: |-
                ESP_LOGV("script.global_settings", "Boot page is visible");
                disp1->set_component_text_printf("boot.bluep_version", "%s", blueprint_version.c_str());
            - wait_until:
                condition:
                  - not:
                      - text_sensor.state:  # Is boot page visible?
                          id: current_page
                          state: 'boot'
                timeout: 2s
            - if:
                condition:
                  - text_sensor.state:  # Avoid this being called twice by multiple boot triggers
                      id: current_page
                      state: 'boot'
                then:
                  - lambda: |-
                      ESP_LOGV("script.global_settings", "Boot page still visible");
                  - if:
                      condition:
                        switch.is_on: notification_sound
                      then:
                        - rtttl.play:
                            rtttl: 'two short:d=4,o=5,b=100:16e6,16e6'
                  - lambda: |-
                      ESP_LOGD("script.global_settings", "Jump to wake-up page: %s", id(page_names)[id(wakeup_page_id)].c_str());
                      disp1->goto_page(id(wakeup_page_id));
                      timer_reset_all->execute(id(page_names)[id(wakeup_page_id)].c_str());

      - lambda: |-
          ESP_LOGV("script.global_settings", "Finished");

  - id: ha_button
    mode: parallel
    parameters:
      page: string
      component: string
      command: string
    then:
      - lambda: |-
          timer_reset_all->execute(page.c_str());
          auto ha_event = new esphome::api::CustomAPIDevice();
          ha_event->fire_homeassistant_event("esphome.nspanel_ha_blueprint",
            {
              {"type", "button_click"},
              {"page", page},
              {"component", component},
              {"command", command}
            });

  - id: ha_call_service
    mode: restart
    parameters:
      service: string
      key: string
      value: string
      entity: string
    then:
      - lambda: |-
          static const char *const TAG = "script.ha_call_service";
          ESP_LOGV(TAG, "Calling Home Assisant service");
          ESP_LOGV(TAG, "  Type: service_call");
          ESP_LOGV(TAG, "  Service: %s", service.c_str());
          ESP_LOGV(TAG, "  Entity:  %s", entity.c_str());
          ESP_LOGV(TAG, "  Key:     %s", key.c_str());
          ESP_LOGV(TAG, "  Value:   %s", value.c_str());
          if (service != "" and not service.empty())
            {
              auto ha_event = new esphome::api::CustomAPIDevice();
              ha_event->fire_homeassistant_event("esphome.nspanel_ha_blueprint",
                {
                  {"type", "service_call"},
                  {"service", service},
                  {"entity", entity},
                  {"key", key},
                  {"value", value}
                });
            }
          ESP_LOGV(TAG, "Finished");

  - id: nextion_status
    mode: restart
    then:
      - lambda: |-
          static const char *const TAG = "script.nextion_status";
          ESP_LOGD(TAG, "Nextion status:");
          ESP_LOGD(TAG, "  Is detected: %s", disp1->is_detected() ? "True" : "False");
          ESP_LOGD(TAG, "  Is setup:    %s", disp1->is_setup() ? "True" : "False");
          ESP_LOGD(TAG, "  Queue size:  %d", disp1->queue_size());

  - id: notification_clear
    mode: restart
    then:
      - lambda: |-
          if (current_page->state == "notification") disp1->goto_page("home");
          notification_label->publish_state("");
          notification_text->publish_state("");
          notification_unread->turn_off();
          refresh_notification->execute();

  - id: open_entity_settings_page
    mode: restart
    parameters:
      page: string
      page_label: string
      page_icon: string
      page_icon_color: int32_t[]
      entity: string
      back_page: string
    then:
      - lambda: |-
          detailed_entity->publish_state(entity);
          if (page == "alarm_control_panel") page = "alarm";
          std::string cmd_page = std::string("page ") + page.c_str();
          disp1->send_command_printf(cmd_page.c_str());
          if (page_label.find("\\r") != std::string::npos)
            page_label = page_label.replace(page_label.find("\\r"), 2, " ");
          disp1->set_component_text_printf("page_label", "%s", page_label.c_str());
          set_page_id->execute("back_page_id", back_page.c_str());
          if (page == "climate")
              disp1->set_component_value("embedded", (entity == "embedded_climate") ? 1 : 0);
          else
            {
              if ((page_icon != std::string()) and (page_icon != ""))
                disp1->set_component_text_printf("icon_state", "%s", page_icon.c_str());
              set_component_color->execute("icon_state", page_icon_color);
            }

  - id: page_alarm
    mode: restart
    then:  # There's nothing here so far

  - id: page_blank
    mode: restart
    then:
      - lambda: |-
          static const char *const TAG = "script.page_blank";
          ESP_LOGV(TAG, "Construct blank page");
          std::string framework = "unknown";
          #ifdef ARDUINO
          framework = "arduino";
          #elif defined(USE_ESP_IDF)
          framework = "esp-idf";
          #endif
          disp1->set_component_text_printf("esp_version", "ESP: ${version}");  // ESPHome version
          disp1->set_component_text_printf("framework", framework.c_str());    // ESPHome framework
          disp1->send_command_printf("tm_esphome.en=0");

  - id: page_boot
    mode: restart
    then:
      - lambda: |-
          static const char *const TAG = "script.page_boot";
          ESP_LOGV(TAG, "Construct boot page");
          set_brightness->execute(100);

          std::string framework = "unknown";
          #ifdef ARDUINO
          framework = "arduino";
          #elif defined(USE_ESP_IDF)
          framework = "esp-idf";
          #endif
          disp1->set_component_text_printf("esph_version", "${version}");    // ESPHome version
          disp1->set_component_text_printf("framework", framework.c_str());  // ESPHome framework
          disp1->show_component("bt_reboot");

  - id: page_buttonpage
    mode: restart
    parameters:
      page_number: uint
    then:  # There's nothing here so far
  - id: page_buttonpage01
    mode: restart
    then:
      - script.execute:
          id: page_buttonpage
          page_number: 1
  - id: page_buttonpage02
    mode: restart
    then:
      - script.execute:
          id: page_buttonpage
          page_number: 2
  - id: page_buttonpage03
    mode: restart
    then:
      - script.execute:
          id: page_buttonpage
          page_number: 3
  - id: page_buttonpage04
    mode: restart
    then:
      - script.execute:
          id: page_buttonpage
          page_number: 4

  - id: page_changed
    mode: restart
    parameters:
      page: string
    then:
      - lambda: |-
          static const char *const TAG = "script.page_changed";

          // Go to boot page if not initiated
          if (page != "boot" and not nextion_init->state) disp1->goto_page("boot");
          // Reset globals
          if (page != "alarm" && //DEBOG
              page != "climate" &&
              page != "cover" &&
              page != "fan" &&
              page != "light" &&
              page != "media_player" &&
              page != "confirm" &&
              page != "keyb_num") {
              detailed_entity->publish_state("");
              disp1->send_command_printf("back_page_id=0");
          }
          if (page != "media_player") {
            id(last_volume_level) = 0;
            id(last_media_duration) = 0;
            id(last_media_position) = 0;
          }

          // Report new page to logs
          ESP_LOGD(TAG, "New page: %s", page.c_str());
          if (!detailed_entity->state.empty()) ESP_LOGD(TAG, "Entity shown: %s", detailed_entity->state.c_str());

          // Reset timers
          timer_reset_all->execute(page.c_str());

          // Report new page to Home Assistant
          ESP_LOGV(TAG, "Trigger HA event");
          auto ha_event = new esphome::api::CustomAPIDevice();
          ha_event->fire_homeassistant_event("esphome.nspanel_ha_blueprint",
            {
              {"type", "page_changed"},
              {"page", page.c_str()},
              {"entity", detailed_entity->state.c_str()}
            });

          // Call page constructor
          if (page == "alarm") page_alarm->execute();
          else if (page == "blank") page_blank->execute();
          else if (page == "boot") page_boot->execute();
          else if (page == "buttonpage01") page_buttonpage01->execute();
          else if (page == "buttonpage02") page_buttonpage02->execute();
          else if (page == "buttonpage03") page_buttonpage03->execute();
          else if (page == "buttonpage04") page_buttonpage04->execute();
          else if (page == "climate") page_climate->execute();
          else if (page == "confirm") page_confirm->execute();
          else if (page == "cover") page_cover->execute();
          else if (page == "entitypage01") page_entitypage01->execute();
          else if (page == "entitypage02") page_entitypage02->execute();
          else if (page == "entitypage03") page_entitypage03->execute();
          else if (page == "entitypage04") page_entitypage04->execute();
          else if (page == "fan") page_fan->execute();
          else if (page == "home") page_home->execute();
          else if (page == "keyb_num") page_keyb_num->execute();
          else if (page == "light") page_light->execute();
          else if (page == "media_player") page_media_player->execute();
          else if (page == "notification") page_notification->execute();
          else if (page == "qrcode") page_qrcode->execute();
          else if (page == "screensaver") page_screensaver->execute();
          else if (page == "settings") page_settings->execute();
          else if (page == "weather01") page_weather01->execute();
          else if (page == "weather02") page_weather02->execute();
          else if (page == "weather03") page_weather03->execute();
          else if (page == "weather04") page_weather04->execute();
          else if (page == "weather05") page_weather05->execute();

  - id: page_climate
    mode: restart
    then:  # There's nothing here so far

  - id: page_confirm
    mode: restart
    then:
      - lambda: |-
          if (not id(is_uploading_tft)) display_wrapped_text->execute("confirm.title", id(mui_please_confirm_global).c_str(), 15);

  - id: page_cover
    mode: restart
    then:  # There's nothing here so far

  - id: page_entitypage
    mode: restart
    parameters:
      page_number: uint
    then:  # There's nothing here so far
  - id: page_entitypage01
    mode: restart
    then:
      - script.execute:
          id: page_entitypage
          page_number: 1
  - id: page_entitypage02
    mode: restart
    then:
      - script.execute:
          id: page_entitypage
          page_number: 2
  - id: page_entitypage03
    mode: restart
    then:
      - script.execute:
          id: page_entitypage
          page_number: 3
  - id: page_entitypage04
    mode: restart
    then:
      - script.execute:
          id: page_entitypage
          page_number: 4

  - id: page_fan
    mode: restart
    then:  # There's nothing here so far

  - id: page_home
    mode: restart
    then:
      - script.execute: refresh_relays
      - script.execute: refresh_wifi_icon

  - id: page_keyb_num
    mode: restart
    then:  # There's nothing here so far

  - id: page_light
    mode: restart
    then:  # There's nothing here so far

  - id: page_media_player
    mode: restart
    then:  # There's nothing here so far

  - id: page_notification
    mode: restart
    then:
      - lambda: |-
          static const char *const TAG = "script.page_notification";
          ESP_LOGV(TAG, "Updating notification page");
          disp1->set_component_text_printf("notification.notifi_label", "%s", notification_label->state.c_str());
          display_wrapped_text->execute("notification.notifi_text01", notification_text->state.c_str(), display_mode->state == 2 ? 23 : 32);

  - id: page_qrcode
    mode: restart
    then:  # There's nothing here so far

  - id: page_screensaver
    mode: restart
    then:
      - lambda: |-
          if (current_page->state == "screensaver" and not id(is_uploading_tft)) {
            static const char *const TAG = "script.page_screensaver";
            ESP_LOGV(TAG, "Updating screensaver page");
            disp1->send_command_printf("back_page_id=%i", id(wakeup_page_id));
            if (id(screensaver_display_time)) {
              disp1->show_component("text");
              set_component_color->execute("screensaver.text",id(screensaver_display_time_color));
              refresh_datetime->execute();
            } else {
              disp1->set_backlight_brightness(0.0f);
            }
            current_brightness->update();
          }

  - id: page_settings
    mode: restart
    then:
      - lambda: |-
          static const char *const TAG = "script.page_settings";
          ESP_LOGV(TAG, "Construct settings page");
          //disp1->set_component_text_printf("bt_sleep", "%s", (id(sleep_mode).state) ? "\uEA19" : "\uEA18"); //mdi:toggle-switch-outline or mdi:toggle-switch-off-outline
          disp1->hide_component("lbl_sleep");
          disp1->hide_component("bt_sleep");

  - id: page_weather
    mode: restart
    parameters:
      page_number: uint
    then:  # There's nothing here so far
  - id: page_weather01
    mode: restart
    then:
      - script.execute:
          id: page_weather
          page_number: 1
  - id: page_weather02
    mode: restart
    then:
      - script.execute:
          id: page_weather
          page_number: 2
  - id: page_weather03
    mode: restart
    then:
      - script.execute:
          id: page_weather
          page_number: 3
  - id: page_weather04
    mode: restart
    then:
      - script.execute:
          id: page_weather
          page_number: 4
  - id: page_weather05
    mode: restart
    then:
      - script.execute:
          id: page_weather
          page_number: 5

  - id: refresh_datetime
    mode: restart
    then:
      - lambda: |-
          static const char *const TAG = "script.refresh_datetime";
          ESP_LOGV(TAG, "Updating time display");
          std::string time_format_str = id(mui_time_format);
          if (time_format_str.find("%-H") != std::string::npos) {
            time_format_str = time_format_str.replace(time_format_str.find("%-H"), sizeof("%-H")-1,
                                                      to_string((int)(id(time_provider).now().hour)));
          }
          if (time_format_str.find("%-I") != std::string::npos) {
            if (id(time_provider).now().hour>12) {
              time_format_str = time_format_str.replace(time_format_str.find("%-I"), sizeof("%-I")-1,
                                                        to_string((int)(id(time_provider).now().hour-12)));
            } else if (id(time_provider).now().hour==0) {
              time_format_str = time_format_str.replace(time_format_str.find("%-I"), sizeof("%-I")-1, "12");
            } else {
              time_format_str = time_format_str.replace(time_format_str.find("%-I"), sizeof("%-I")-1,
                                                        to_string((int)(id(time_provider).now().hour)));
            }
          }
          std::string meridiem_text = (id(time_provider).now().hour<12) ? id(mui_meridiem)[0] : id(mui_meridiem)[1];
          if (current_page->state == "screensaver" and id(screensaver_display_time)) {
              ESP_LOGV(TAG, "Updating time on screensaver page");
              std::string time_format_str_sleep = time_format_str;
              if (time_format_str_sleep.find("%p") != std::string::npos)
                time_format_str_sleep.replace(time_format_str_sleep.find("%p"), sizeof("%p")-1, meridiem_text.c_str());
              disp1->set_component_text_printf("text", "%s", id(time_provider).now().strftime(time_format_str_sleep).c_str());
          }
          ESP_LOGV(TAG, "Updating home page meridiem");
          disp1->set_component_text_printf("home.meridiem", "%s", (time_format_str.find("%p") != std::string::npos) ? meridiem_text.c_str() : " ");
          ESP_LOGV(TAG, "Updating home page time");
          disp1->set_component_text_printf("home.time", "%s", id(time_provider).now().strftime(time_format_str).c_str());

  - id: refresh_notification
    mode: restart
    then:
      - wait_until:
          condition:
            - lambda: !lambda return id(setup_sequence_completed);
      - lambda: |-
          bool is_notification = (notification_text->state.empty() and notification_label->state.empty());
          disp1->send_command_printf("is_notification=%i", is_notification ? 0 : 1);
          set_component_color->execute("home.bt_notific", notification_unread->state ? id(home_notify_icon_color_unread) : id(home_notify_icon_color_normal));
          if (current_page->state == "home") {
            if (is_notification) {
              disp1->show_component("bt_notific");
            } else {
              disp1->hide_component("bt_notific");
            }
          }

  - id: refresh_relays
    mode: restart
    then:
      - lambda: |-
          // Chips - Relays
          disp1->set_component_text_printf("home.icon_top_01", "%s", (relay_1->state) ? id(home_relay1_icon).c_str() : "\uFFFF");
          disp1->set_component_text_printf("home.icon_top_02", "%s", (relay_2->state) ? id(home_relay2_icon).c_str() : "\uFFFF");
          // Hardware buttons bars - Fallback mode
          if (relay1_local->state) disp1->send_command_printf("home.left_bt_pic.val=%i", (relay_1->state) ? 1 : 0);
          if (relay2_local->state) disp1->send_command_printf("home.right_bt_pic.val=%i", (relay_2->state) ? 1 : 0);

  - id: refresh_wifi_icon
    mode: restart
    then:
      - lambda: |-
          if (nextion_init->state) {
            // Update Wi-Fi icon color
            disp1->set_component_font_color("home.wifi_icon", (id(is_blueprint_updated)) ? (wifi_rssi->state > -70 ? 33808 : 64992) : 63488);
            // Update Wi-Fi icon
            disp1->set_component_text_printf("home.wifi_icon", "%s",
                                              wifi_component->is_connected() ?
                                                (api_server->is_connected() ?
                                                  (id(is_blueprint_updated) ? "\uE5A8" :  // mdi:wifi - All right!
                                                  "\uE7CF") :                             // mdi:home-assistant - Blueprint is out
                                                "\uF256") :                               // mdi:api-off
                                              "\uE5A9");                                  // mdi:wifi-off
          }

  - id: relay_settings
    mode: restart
    parameters:
      relay1_local_control: bool
      relay1_icon: string
      relay1_icon_color: int
      relay1_fallback: bool
      relay2_local_control: bool
      relay2_icon: string
      relay2_icon_color: int
      relay2_fallback: bool
    then:
      - lambda: |-
          static const char *const TAG = "script.relay_settings";
          // Relays
          ESP_LOGV(TAG, "Setup relays");
          relay1_local->publish_state(relay1_local_control);
          relay2_local->publish_state(relay2_local_control);
          id(relay_1_fallback) = relay1_fallback;
          id(relay_2_fallback) = relay2_fallback;
          disp1->set_component_font_color("home.icon_top_01", relay1_icon_color);
          disp1->set_component_font_color("home.icon_top_02", relay2_icon_color);
          disp1->set_component_text_printf("home.icon_top_01", "%s", relay1_icon.c_str());
          disp1->set_component_text_printf("home.icon_top_02", "%s", relay2_icon.c_str());
          id(home_relay1_icon) = relay1_icon.c_str();
          id(home_relay2_icon) = relay2_icon.c_str();
          id(home_relay1_icon_color) = relay1_icon_color;
          id(home_relay2_icon_color) = relay2_icon_color;
          ESP_LOGV(TAG, "Finished");

  - id: restore_settings
    mode: restart
    then:
      - lambda: |-
          static const char *const TAG = "script.restore_settings";
          ESP_LOGD(TAG, "Restoring settings");

          ESP_LOGV(TAG, "Restoring baud rate");
          set_baud_rate->execute(stoi(baud_rate->state), true);

          ESP_LOGV(TAG, "Restoring wake-up page selector");
          auto wakeup_page_name_call = id(wakeup_page_name).make_call();
          wakeup_page_name_call.set_option(id(page_names)[id(wakeup_page_id)]);
          wakeup_page_name_call.perform();

          ESP_LOGV(TAG, "Finishing");
          id(is_restored_settings) = true;

  - id: service_call_alarm_control_panel
    mode: restart
    parameters:
      entity: string
      key: string
      code_format: string
      pin: string
    then:
      - lambda: |-
          std::string service = "";
          if (key == "home") service = "alarm_control_panel.alarm_arm_home";
          else if (key == "away") service = "alarm_control_panel.alarm_arm_away";
          else if (key == "night") service = "alarm_control_panel.alarm_arm_night";
          else if (key == "vacation") service = "alarm_control_panel.alarm_arm_vacation";
          else if (key == "bypass") service = "alarm_control_panel.alarm_arm_custom_bypass";
          else if (key == "disarm") service = "alarm_control_panel.alarm_disarm";
          if (service != "" and not service.empty())
            {
              HomeassistantServiceResponse resp;
              HomeassistantServiceMap resp_kv;
              resp.service = service.c_str();
              resp_kv.key = "entity_id";
              resp_kv.value = entity.c_str();
              resp.data.push_back(resp_kv);
              if (pin != "" and not pin.empty())
                {
                  resp_kv.key = "code";
                  resp_kv.value = pin.c_str();
                  resp.data.push_back(resp_kv);
                }
              api_server->send_homeassistant_service_call(resp);
            }

  - id: set_baud_rate
    mode: restart
    parameters:
      baud_rate: int
      definitive: bool
    then:
      - if:
          condition:
            - lambda: !lambda return (tf_uart->get_baud_rate() != baud_rate);
          then:
            - lambda: |-
                static const char *const TAG = "script.set_baud_rate";
                ESP_LOGD(TAG, "Baud rate changing from %" PRIu32 " to %i bps", tf_uart->get_baud_rate(), baud_rate);
                ESP_LOGD(TAG, "Flush UART");
            - wait_until:
                condition:
                  - lambda: !lambda return (tf_uart->available() < 1);
                timeout: 3s
            - lambda: |-
                tf_uart->flush();
                static const char *const TAG = "script.set_baud_rate";
                ESP_LOGD(TAG, "Sending instruction '%s=%i' to Nextion", definitive ? "bauds" : "baud", baud_rate);
                disp1->send_command_printf("%s=%i", definitive ? "bauds" : "baud", baud_rate);
                ESP_LOGD(TAG, "Flush UART");
            - wait_until:
                condition:
                  - lambda: !lambda return (tf_uart->available() < 1);
                timeout: 3s
            - lambda: |-
                tf_uart->flush();
                static const char *const TAG = "script.set_baud_rate";
                ESP_LOGD(TAG, "Set ESPHome new baud rate to %i bps", baud_rate);
                tf_uart->set_baud_rate(baud_rate);
                tf_uart->load_settings();
                ESP_LOGD(TAG, "Baud rate is changet to %i bps", baud_rate);

  - id: set_brightness
    mode: restart
    parameters:
      brightness: uint
    then:
      - lambda: |-
          static const char *const TAG = "script.set_brightness";
          ESP_LOGD(TAG, "brightness: %i%%", brightness);
          if (brightness == id(display_brightness_global) and current_page->state != "screensaver")
            disp1->send_command_printf("wakeup_timer.en=1");
          else
            disp1->set_backlight_brightness(static_cast<float>(brightness) / 100.0f);
          current_brightness->update();
      - delay: 5s
      - lambda: current_brightness->update();

  - id: set_climate
    mode: restart
    parameters:
      current_temp: float
      supported_features: int
      target_temp: float
      target_temp_high: float
      target_temp_low: float
      temp_step: uint
      total_steps: uint
      temp_offset: int
      climate_icon: string
      embedded_climate: bool
    then:
      - lambda: |-
          if (id(is_uploading_tft)) set_climate->stop();
          static const char *const TAG = "script.set_climate";
          ESP_LOGD(TAG, "Starting");
          ESP_LOGD(TAG, "  current_temp:         %f", current_temp);
          ESP_LOGD(TAG, "  supported_features:   %i", supported_features);
          ESP_LOGD(TAG, "  target_temp:          %f", target_temp);
          ESP_LOGD(TAG, "  target_temp_high:     %f", target_temp_high);
          ESP_LOGD(TAG, "  target_temp_low:      %f", target_temp_low);
          ESP_LOGD(TAG, "  temp_step:            %d", temp_step);
          ESP_LOGD(TAG, "  total_steps:          %d", total_steps);
          ESP_LOGD(TAG, "  temp_offset:          %i", temp_offset);
          ESP_LOGD(TAG, "  climate_icon:         %s", climate_icon.c_str());
          ESP_LOGD(TAG, "  embedded_climate:     %s", embedded_climate ? "True" : "False");
          if (current_page->state == "climate") {
            ESP_LOGD(TAG, "Page climate is visible");
            disp1->send_command_printf("climateslider.maxval=%i", total_steps);
            disp1->send_command_printf("slider_high.maxval=%i", total_steps);
            disp1->send_command_printf("slider_low.maxval=%i", total_steps);
            disp1->set_component_value("temp_offset", temp_offset);
            disp1->set_component_value("temp_step", temp_step);
            disp1->show_component("current_temp");
            if (current_temp > -999)
              disp1->set_component_text_printf("current_temp", "%.1f째", current_temp);
            else
              disp1->set_component_text_printf("current_temp", id(mui_unavailable_global).c_str());

            if (target_temp > -999) {  // Target temp enabled
              disp1->set_component_value("active_slider", 0);
              disp1->hide_component("slider_high");
              disp1->hide_component("slider_low");
              disp1->hide_component("target_low");
              disp1->set_component_text_printf("target_high", "%.1f째", target_temp);
              disp1->show_component("target_high");
              disp1->set_component_value("climateslider", round(((10*target_temp) - temp_offset) / temp_step));
              disp1->show_component("climateslider");
            } else {
              disp1->hide_component("slider_high");
              if (target_temp_low > -999) {  // Target temp low enabled
                disp1->set_component_value("active_slider", 2);
                disp1->set_component_text_printf("target_low", "%.1f째", target_temp_low);
                disp1->show_component("target_low");
                disp1->set_component_value("slider_low", round(((10*target_temp_low) - temp_offset) / temp_step));
                disp1->show_component("slider_low");
              } else {
                disp1->hide_component("target_low");
                disp1->hide_component("slider_low");
              }
              if (target_temp_high > -999) {  // Target temp high enabled
                disp1->set_component_value("active_slider", 1);
                disp1->set_component_text_printf("target_high", "%.1f째", target_temp_high);
                disp1->show_component("target_high");
                disp1->set_component_value("slider_high", round(((10*target_temp_high) - temp_offset) / temp_step));
                disp1->show_component("slider_high");
              } else {
                disp1->hide_component("target_high");
                disp1->hide_component("slider_high");
              }
            }
            if (target_temp > -999 or target_temp_high > -999 or target_temp_low > -999) {
              disp1->set_component_text_printf("target_icon", "%s", climate_icon.c_str());
              disp1->show_component("target_icon");
              disp1->show_component("decrease_temp");
              disp1->show_component("increase_temp");
            } else {
              disp1->hide_component("target_icon");
              disp1->hide_component("decrease_temp");
              disp1->hide_component("increase_temp");
            }
            disp1->set_component_value("embedded", (embedded_climate) ? 1 : 0);
          }
          ESP_LOGD(TAG, "Finished");

  - id: set_component_color
    mode: queued
    parameters:
      component: string
      foreground: int32_t[]
    then:
      - lambda: |-
          static const char *const TAG = "script.set_component_color";
          ESP_LOGVV(TAG, "Starting:");
          ESP_LOGVV(TAG, "  Component:  %s", component.c_str());
          int fg565 = -1;
          // Foreground
          if (foreground.size() == 3 and
              foreground[0] >= 0 and
              foreground[1] >= 0 and
              foreground[2] >= 0) {
            ESP_LOGVV(TAG, "  Foreground: {%i, %i, %i}", foreground[0], foreground[1], foreground[2]);
            fg565 = ((foreground[0] & 0b11111000) << 8) | ((foreground[1] & 0b11111100) << 3) | (foreground[2] >> 3);
          }
          else if (foreground.size() == 1) fg565 = foreground[0];
          else {
            ESP_LOGE(TAG, "  Component:       %s", component.c_str());
            ESP_LOGE(TAG, "  Foreground size: %i", foreground.size());
            fg565 = -1;
          }
          ESP_LOGVV(TAG, "  Foreground: %i", fg565);
          if (fg565 >= 0) disp1->set_component_font_color(component.c_str(), fg565);

  - id: set_page_id
    mode: queued
    parameters:
      variable: string
      page: string
    then:
      - lambda: |-
          static const char *const TAG = "script.set_page_id";
          ESP_LOGV(TAG, "Starting:");
          ESP_LOGV(TAG, "  Variable: %s", variable.c_str());
          ESP_LOGV(TAG, "  Page:     %s", page.c_str());

          auto pageIndex = [](const std::string& page_name) -> uint8_t {
              for (uint8_t i = 0; i < id(page_names).size(); ++i) {
                  if (id(page_names)[i] == page_name) {
                      return i;  // Return the index if found
                  }
              }
              return 0u;  // Return 0 (home page) if not found
          };

          uint detected_page_id = pageIndex(page.c_str());
          ESP_LOGV(TAG, "%s=%i", variable.c_str(), detected_page_id);
          if (variable == "wakeup_page_id")
            id(wakeup_page_id) = detected_page_id;
          else
            disp1->send_command_printf("%s=%i", variable.c_str(), detected_page_id);

  - id: setup_sequence
    mode: restart
    then:
      - lambda: |-
          static const char *const TAG = "script.setup_sequence";
          ESP_LOGD(TAG, "Starting Nextion setup sequence");
          ESP_LOGD(TAG, "Fetching page id");
          page_id->update();
      - wait_until:
          condition:
            - lambda: !lambda return (page_id->state > 0);
          timeout: 5s
      - lambda: |-
          static const char *const TAG = "script.setup_sequence";
          ESP_LOGD(TAG, "Fetching charset");
          display_charset->update();
      - wait_until:
          condition:
            - lambda: !lambda return (display_charset->state > 0);
          timeout: 5s
      - lambda: |-
          static const char *const TAG = "script.setup_sequence";
          ESP_LOGD(TAG, "Fetching display mode");
          display_mode->update();
      - wait_until:
          condition:
            - lambda: !lambda return (display_mode->state > 0);
          timeout: 5s
      - if:
          condition:
            - lambda: !lambda return (display_mode->state > 0);
          then:  # Project's TFT detected
            - lambda: |-
                static const char *const TAG = "script.setup_sequence";
                ESP_LOGD(TAG, "Goto page Boot");
                disp1->goto_page("boot");
                ESP_LOGD(TAG, "Fetching TFT version");
                version_tft->update();
            - wait_until:
                condition:
                  - lambda: !lambda return (not version_tft->state.empty());
                timeout: 5s
            - lambda: |-
                static const char *const TAG = "script.setup_sequence";
                ESP_LOGD(TAG, "Wait for Wi-Fi");
            - wait_until:
                condition:
                  - lambda: !lambda return (wifi_component->is_connected());
                timeout: 10s
            - if:
                condition:
                  - lambda: !lambda return (wifi_component->is_connected());
                then:  # Wi-Fi connected
                  - lambda: |-
                      static const char *const TAG = "script.setup_sequence";
                      if (current_page->state == "boot") {
                        ESP_LOGD(TAG, "Publish IP address on screen");
                        disp1->set_component_text_printf("boot.ip_addr", "%s", network::get_ip_address().str().c_str());
                        set_brightness->execute(100);
                      }
                      ESP_LOGD(TAG, "Wait for API");
                  - wait_until:
                      condition:
                        - lambda: !lambda return (api_server->is_connected());
                      timeout: 10s
                  - if:
                      condition:
                        - lambda: !lambda return (api_server->is_connected());
                      then:  # API connected
                        - lambda: |-
                            static const char *const TAG = "script.setup_sequence";
                            ESP_LOGD(TAG, "Publish IP address on screen");
                            ESP_LOGD(TAG, "Report setup to Home Assistant");
                            auto ha_event = new esphome::api::CustomAPIDevice();
                            ha_event->fire_homeassistant_event("esphome.nspanel_ha_blueprint",
                              {
                                {"type", "boot"},
                                {"step", "start"}
                              });
                      else:  # API not connected
                        - lambda: |-
                            static const char *const TAG = "script.setup_sequence";
                            ESP_LOGE(TAG, "API not available");
                else:  # Wi-Fi not connected
                  - lambda: |-
                      static const char *const TAG = "script.setup_sequence";
                      ESP_LOGE(TAG, "Wi-Fi not available");
                  - lambda: |-
                      static const char *const TAG = "script.setup_sequence";
                      ESP_LOGE(TAG, "Wi-Fi not available");
            - wait_until:
                condition:
                  - lambda: !lambda return id(setup_sequence_completed);
                timeout: 1s
            - lambda: |-
                static const char *const TAG = "script.setup_sequence";
                ESP_LOGD(TAG, "Set dimming values");
                display_brightness->publish_state(id(display_brightness_global));
                display_dim_brightness->publish_state(id(display_dim_brightness_global));
                set_brightness->execute(id(display_brightness_global));
                ESP_LOGD(TAG, "Set page Settings");
                disp1->send_command_printf("brightness=%i", id(display_brightness_global));
                disp1->send_command_printf("settings.brightslider.val=%i", id(display_brightness_global));
                disp1->send_command_printf("brightness_dim=%i", id(display_dim_brightness_global));
                disp1->send_command_printf("settings.dimslider.val=%i", id(display_dim_brightness_global));
                disp1->send_command_printf("brightness_sleep=%i", int(display_sleep_brightness->state));
                ESP_LOGD(TAG, "Report to Home Assistant");
                nextion_init->publish_state(disp1->is_setup());
                if (api_server->is_connected() and disp1->is_setup()) {
                  auto ha_event = new esphome::api::CustomAPIDevice();
                  ha_event->fire_homeassistant_event("esphome.nspanel_ha_blueprint",
                    {
                      {"type", "boot"},
                      {"step", "nextion_init"}
                    });
                }
                // Chips icon size
                ESP_LOGV(TAG, "Adjusting icon's sizes");
                for (int i = 1; i <= 10; ++i) {
                  disp1->send_command_printf("home.icon_top_%02d.font=%i", i, id(home_chip_font_size));
                }
                // Custom buttons icon size
                ESP_LOGV(TAG, "Adjusting custom buttons sizes");
                for (int i = 1; i <= 7; ++i) {
                  disp1->send_command_printf("home.button%02d.font=%i", i, id(home_custom_buttons_font_size));
                }
                disp1->send_command_printf("home.bt_notific.font=%i", id(home_custom_buttons_font_size));
                disp1->send_command_printf("home.bt_qrcode.font=%i", id(home_custom_buttons_font_size));
                disp1->send_command_printf("home.bt_entities.font=%i", id(home_custom_buttons_font_size));
                disp1->send_command_printf("home.wifi_icon.font=%i", id(home_chip_font_size));
                ESP_LOGV(TAG, "Restoring relay's icons");
                disp1->set_component_text_printf("home.icon_top_01", "%s", id(home_relay1_icon).c_str());
                disp1->set_component_text_printf("home.icon_top_02", "%s", id(home_relay2_icon).c_str());
                timer_reset_all->execute("boot");
                notification_clear->execute();
                id(setup_sequence_completed) = true;
                ESP_LOGD(TAG, "Wait for leaving boot page");
            - wait_until:
                condition:
                  - not:
                      - text_sensor.state:  # Is boot page visible?
                          id: current_page
                          state: boot
                timeout: 10s
            - lambda: |-
                if (current_page->state == "boot") disp1->goto_page(id(wakeup_page_id));
          else:  # Unknown TFT
            - lambda: |-
                static const char *const TAG = "script.setup_sequence";
                ESP_LOGE(TAG, "A non-compatible TFT is installed");
                ESP_LOGE(TAG, "Display mode: %f", display_mode->state);
      - lambda: |-
          static const char *const TAG = "script.setup_sequence";
          ESP_LOGD(TAG, "Nextion setup sequence finished!");

  - id: stop_all
    mode: restart
    then:
      - lambda: |-
          static const char *const TAG = "script.stop_all";
          ESP_LOGD(TAG, "Stopping scripts...");
          change_climate_state->stop();
          check_versions->stop();
          display_embedded_temp->stop();
          display_wrapped_text->stop();
          exit_reparse->stop();
          global_settings->stop();
          ha_button->stop();
          ha_call_service->stop();
          nextion_status->stop();
          notification_clear->stop();
          open_entity_settings_page->stop();
          page_alarm->stop();
          page_blank->stop();
          page_boot->stop();
          page_buttonpage01->stop();
          page_buttonpage02->stop();
          page_buttonpage03->stop();
          page_buttonpage04->stop();
          page_buttonpage->stop();
          page_climate->stop();
          page_changed->stop();
          page_confirm->stop();
          page_cover->stop();
          page_entitypage01->stop();
          page_entitypage02->stop();
          page_entitypage03->stop();
          page_entitypage04->stop();
          page_entitypage->stop();
          page_fan->stop();
          page_home->stop();
          page_keyb_num->stop();
          page_light->stop();
          page_media_player->stop();
          page_notification->stop();
          page_qrcode->stop();
          page_screensaver->stop();
          page_settings->stop();
          page_weather01->stop();
          page_weather02->stop();
          page_weather03->stop();
          page_weather04->stop();
          page_weather05->stop();
          page_weather->stop();
          refresh_datetime->stop();
          refresh_relays->stop();
          refresh_wifi_icon->stop();
          relay_settings->stop();
          service_call_alarm_control_panel->stop();
          set_baud_rate->stop();
          set_brightness->stop();
          set_climate->stop();
          set_component_color->stop();
          set_page_id->stop();
          setup_sequence->stop();
          timer_dim->stop();
          timer_page->stop();
          timer_reset_all->stop();
          timer_sleep->stop();
          update_alarm_icon->stop();
          update_climate_icon->stop();
          watchdog->stop();
          ESP_LOGD(TAG, "Finished");

  ###### Timers ######
  - id: timer_reset_all  # Global timer reset - Triggered with a touch on the screen
    mode: restart
    parameters:
      page: string
    then:
      - lambda: |-
          ESP_LOGV("script.timer_reset_all", "Reset timers");
          timer_page->execute(page.c_str(), int(timeout_page->state));
          timer_dim->execute(page.c_str(), int(timeout_dim->state));
          timer_sleep->execute(page.c_str(), int(timeout_sleep->state));
  - id: timer_page       # Handles the fallback to home page after a timeout
    mode: restart
    parameters:
      page: string
      timeout: uint
    then:
      - lambda: |-
          ESP_LOGV("script.timer_page", "Reset timer: %is", timeout);
      - if:
          condition:
            - lambda: |-
                return (timeout >= 1 and
                        page != "boot" and
                        page != "confirm" and
                        page != "home" and
                        page != "notification" and
                        page != "screensaver");
          then:
            - delay: !lambda return (timeout *1000);
            - lambda: |-
                ESP_LOGV("script.timer_page", "Timed out on page: %s", current_page->state.c_str());
                if (timeout >= 1 and
                    current_page->state != "boot" and
                    current_page->state != "confirm" and
                    current_page->state != "home" and
                    current_page->state != "notification" and
                    current_page->state != "screensaver")
                  {
                    ESP_LOGD("script.timer_page", "Fallback to page Home");
                    disp1->goto_page("home");
                  }
  - id: timer_dim        # Handles the brightness dimming after a timeout
    mode: restart
    parameters:
      page: string
      timeout: uint
    then:
      - lambda: |-
          ESP_LOGV("script.timer_dim", "Reset timer: %is", timeout);
          if (current_brightness->state <= id(display_dim_brightness_global)
              and page != "screensaver"
              and page != "boot"
              and page != "blank-screensaver") {
            ESP_LOGD("script.timer_dim", "Waking up on page: %s", page.c_str());
            set_brightness->execute(id(display_brightness_global));
          }
      - if:
          condition:
            - lambda: !lambda return (timeout >= 1);
          then:
            - delay: !lambda return (timeout *1000);
            - lambda: |-
                if (current_page->state != "screensaver" and
                    current_page->state != "blank-screensaver" and
                    current_page->state != "boot" and
                    timeout >= 1) {
                  set_brightness->execute(id(display_dim_brightness_global));
                }
  - id: timer_sleep      # Handles the sleep (go to screensaver page) after a timeout
    mode: restart
    parameters:
      page: string
      timeout: uint
    then:
      - lambda: |-
          ESP_LOGV("script.timer_sleep", "Reset timer: %is", timeout);
      - if:
          condition:
            - lambda: |-
                return (timeout >= 1 and current_page->state != "screensaver" and current_page->state != "boot");
          then:
            - delay: !lambda return (timeout *1000);
            - lambda: |-
                if (current_page->state != "screensaver" and
                    current_page->state != "boot" and
                    timeout >= 1) {
                  ESP_LOGD("script.timer_sleep", "Going to sleep from page %s", current_page->state.c_str());
                  disp1->goto_page("screensaver");
                  set_brightness->execute(display_sleep_brightness->state);
                }

  - id: update_alarm_icon  # To do: Move to blueprint
    mode: restart
    parameters:
      component: string
      state: string
    then:
      - lambda: |-
          std::string alarm_icon = "\uEECC"; //mdi:shield-alert-outline
          int alarm_color = 65535;
          if (state == "disarmed")
            {
              alarm_icon = "\uE99B"; //mdi:shield-off-outline
              alarm_color = 65535;
            }
          else if (state == "armed_home")
            {
              alarm_icon = "\uECCA"; //mdi:shield-home-outline
              alarm_color = 19818;
            }
          else if (state == "armed_away")
            {
              alarm_icon = "\uECCB"; //mdi:shield-lock-outline
              alarm_color = 19818;
            }
          else if (state == "armed_night")
            {
              alarm_icon = "\uF828"; //mdi:shield-moon-outline
              alarm_color = 19818;
            }
          else if (state == "armed_vacation")
            {
              alarm_icon = "\uECC6"; //mdi:shield-airplane-outline
              alarm_color = 19818;
            }
          else if (state == "armed_custom_bypass")
            {
              alarm_icon = "\uE77F"; //mdi:shield-half-full
              alarm_color = 19818;
            }
          else if (state == "pending" or state == "arming")
            {
              alarm_icon = "\uE498"; //mdi:shield-outline
              alarm_color = 65024;
            }
          else if (state == "disarming")
            {
              alarm_icon = "\uE99B"; //mdi:shield-off-outline
              alarm_color = 65024;
            }
          else if (state == "triggered")
            {
              alarm_icon = "\uEECC"; //mdi:shield-alert-outline
              alarm_color = 63488;
            }
          disp1->set_component_text_printf(component.c_str(), alarm_icon.c_str());
          disp1->set_component_font_color(component.c_str(), alarm_color);

  - id: update_climate_icon
    mode: restart
    parameters:
      component: string
      action: uint
      mode: uint
    then:
      - lambda: |-
          switch (action) // CLIMATE_ACTION_OFF = 0, CLIMATE_ACTION_COOLING = 2, CLIMATE_ACTION_HEATING = 3, CLIMATE_ACTION_IDLE = 4, CLIMATE_ACTION_DRYING = 5, CLIMATE_ACTION_FAN = 6
            {
              case 0: //CLIMATE_ACTION_OFF
                switch (mode) // CLIMATE_MODE_OFF = 0, CLIMATE_MODE_HEAT_COOL = 1, CLIMATE_MODE_COOL = 2, CLIMATE_MODE_HEAT = 3, CLIMATE_MODE_FAN_ONLY = 4, CLIMATE_MODE_DRY = 5, CLIMATE_MODE_AUTO = 6
                  {
                    case 0: //CLIMATE_MODE_OFF
                      disp1->set_component_text_printf(component.c_str(), "%s", "\uFFFF"); // (E424) Don't show icon when off
                      disp1->set_component_font_color(component.c_str(), 35921); // grey (off)
                      break;
                    case 1: //CLIMATE_MODE_HEAT_COOL
                      disp1->set_component_text_printf(component.c_str(), "%s", "\uE069"); // mdi:autorenew
                      disp1->set_component_font_color(component.c_str(), 35921); // grey (off)
                      break;
                    case 2: //CLIMATE_MODE_COOL
                      disp1->set_component_text_printf(component.c_str(), "%s", "\uE716"); // mdi:snowflake
                      disp1->set_component_font_color(component.c_str(), 35921); // grey (off)
                      break;
                    case 3: //CLIMATE_MODE_HEAT
                      disp1->set_component_text_printf(component.c_str(), "%s", "\uE237"); // mdi:fire
                      disp1->set_component_font_color(component.c_str(), 35921); // grey (off)
                      break;
                    case 4: //CLIMATE_MODE_FAN_ONLY
                      disp1->set_component_text_printf(component.c_str(), "%s", "\uE20F"); // mdi:fan
                      disp1->set_component_font_color(component.c_str(), 35921); // grey (off)
                      break;
                    case 5: //CLIMATE_MODE_DRY
                      disp1->set_component_text_printf(component.c_str(), "%s", "\uE58D"); // mdi:water-percent
                      disp1->set_component_font_color(component.c_str(), 35921); // grey (off)
                      break;
                    case 6: //CLIMATE_MODE_AUTO
                      disp1->set_component_text_printf(component.c_str(), "%s", "\uEE8D"); // mdi:calendar-sync
                      disp1->set_component_font_color(component.c_str(), 35921); // grey (off)
                      break;
                  }
                  break;
              case 2: //CLIMATE_ACTION_COOLING
                disp1->set_component_text_printf(component.c_str(), "%s", "\uE716"); // mdi:snowflake
                disp1->set_component_font_color(component.c_str(), 1055); // blue
                break;
              case 3: //CLIMATE_ACTION_HEATING
                disp1->set_component_text_printf(component.c_str(), "%s", "\uE237"); // mdi:fire
                disp1->set_component_font_color(component.c_str(), 64164); // deep-orange
                break;
              case 4: //CLIMATE_ACTION_IDLE
                disp1->set_component_text_printf(component.c_str(), "%s", "\uE50E"); // mdi:thermometer
                disp1->set_component_font_color(component.c_str(), 35921); // grey (off)
                break;
              case 5: //CLIMATE_ACTION_DRYING
                disp1->set_component_text_printf(component.c_str(), "%s", "\uE58D"); // mdi:water-percent
                disp1->set_component_font_color(component.c_str(), 64704); // orange
                break;
              case 6: //CLIMATE_ACTION_FAN
                disp1->set_component_text_printf(component.c_str(), "%s", "\uE20F"); // mdi:fan
                disp1->set_component_font_color(component.c_str(), 1530); // cyan
                break;
            }

  - id: watchdog
    mode: restart
    then:
      - script.execute: refresh_relays
      - lambda: |-
          static const char *const TAG = "script.watchdog";
          ESP_LOGV(TAG, "Starting");
          if (id(is_uploading_tft)) {
            ESP_LOGW(TAG, "TFT upload in progress");
          } else {
            // report Wi-Fi status
            bool wifi_connected = wifi_component->is_connected();
            if (wifi_connected) {
              id(wifi_timeout) = ${wifi_timeout};
              float rssi = wifi_rssi->state;
              std::string rssi_status = "Unknown";
              if (rssi > -50) rssi_status = "Excellent";
              else if (rssi > -60) rssi_status = "Good";
              else if (rssi > -70) rssi_status = "Fair";
              else if (rssi > -80) rssi_status = "Weak";
              else rssi_status = "Poor";
              if (rssi > -70) ESP_LOGI(TAG, "Wi-Fi:         %s (%.0f dBm)", rssi_status.c_str(), rssi);
              else if (rssi > -80) ESP_LOGW(TAG, "Wi-Fi:         %s (%.0f dBm)", rssi_status.c_str(), rssi);
              else ESP_LOGE(TAG, "Wi-Fi:         %s (%.0f dBm)", rssi_status.c_str(), rssi);
            }
            else {
              ESP_LOGW(TAG, "Wi-Fi:         DISCONNECTED");
              if (id(wifi_timeout) > 0) {
                id(wifi_timeout)--;
                ESP_LOGI(TAG, "Retrying Wi-Fi connection");
                wifi_component->retry_connect();
              } else {
                ESP_LOGE(TAG, "Restarting ESP due to a Wi-Fi timeout...");
                App.safe_reboot();
              }
            }

            // report API status
            bool previous_blueprint_status = id(is_blueprint_updated);
            bool api_connected = api_server->is_connected();
            if (api_connected) {
              ESP_LOGI(TAG, "API:           Connected");
            } else {
              ESP_LOGW(TAG, "API:           DISCONNECTED");
              id(is_blueprint_updated) = false;
              if (current_page->state != "blank" and
                  current_page->state != "boot" and
                  current_page->state != "home" and
                  current_page->state != "screensaver" and
                  current_page->state != "settings" and
                  current_page->state != "qrcode") {
                ESP_LOGI(TAG, "Fallback to page Home");
                disp1->goto_page("home");
              }
            }

            // Report blueprint version
            id(is_blueprint_updated) = id(is_blueprint_updated) and wifi_connected and api_connected and (not id(version_blueprint).empty());
            if (id(is_blueprint_updated))
              ESP_LOGI(TAG, "Blueprint:     %s", id(version_blueprint).c_str());
            else {
              ESP_LOGW(TAG, "Blueprint:     %s", (wifi_connected and api_connected) ? "Pending" : "DISCONNECTED");
              ESP_LOGI(TAG, "Requesting blueprint settings");
              auto ha_event = new esphome::api::CustomAPIDevice();
              ha_event->fire_homeassistant_event("esphome.nspanel_ha_blueprint",
                {
                  {"type", "boot"},
                  {"step", "timeout"}
                });
            }

            // Report ESPHome
            ESP_LOGI(TAG, "ESPHome:");
            ESP_LOGI(TAG, "  Version:     ${version}");
            // Report framework
            #ifdef ARDUINO
            ESP_LOGI(TAG, "  Framework:   arduino");
            #elif defined(USE_ESP_IDF)
            ESP_LOGI(TAG, "  Framework:   esp-idf");
            #endif

            // Report UART
            ESP_LOGI(TAG, "UART:");
            ESP_LOGI(TAG, "  Baud rate:   %" PRIu32 " bps", tf_uart->get_baud_rate());
            ESP_LOGI(TAG, "  Queue size:  %d", tf_uart->available());

            // Report Nextion status
            nextion_init->publish_state(nextion_init->state and disp1->is_setup());
            ESP_LOGI(TAG, "Nextion:");
            ESP_LOGI(TAG, "  Queue size:  %d", disp1->queue_size());
            if (disp1->is_setup())
              ESP_LOGI(TAG, "  Is setup:    True");
            else {
              ESP_LOGW(TAG, "  Is setup:    False");
              ESP_LOGW(TAG, "  Is detected: %s", disp1->is_detected() ? "True" : "False");
              //exit_reparse->execute();
            }
            if (nextion_init->state) {
              ESP_LOGI(TAG, "  Init:        True");
              // Update api value on Nextion
              if (id(is_blueprint_updated) != previous_blueprint_status) disp1->send_command_printf("api=%i", id(is_blueprint_updated) ? 1 : 0);
            } else
              ESP_LOGW(TAG, "  Init:        False");
            if (version_tft->state.empty())
              ESP_LOGW(TAG, "  TFT:         UNKNOWN");
            else
              ESP_LOGI(TAG, "  TFT:         %s", version_tft->state.c_str());
          }
          refresh_wifi_icon->execute();
          ESP_LOGV(TAG, "Finished");
...
